<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ancient Athens - Visual Masterpiece</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' ry='6' fill='%23333'/%3E%3Ctext x='16' y='22' font-size='18' text-anchor='middle' fill='%23fff' font-family='Cinzel, serif'%3EA%3C/text%3E%3C/svg%3E">
<!-- Physics library -->
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
            "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js",
            "three/examples/jsm/objects/Sky.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/objects/Sky.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/UnrealBloomPass.js",
            "three/examples/jsm/utils/SkeletonUtils.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/utils/SkeletonUtils.js",
            "three/examples/jsm/lines/Line2.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/lines/Line2.js",
            "three/examples/jsm/lines/LineGeometry.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/lines/LineGeometry.js",
            "three/examples/jsm/lines/LineMaterial.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/lines/LineMaterial.js",
            "three/examples/jsm/libs/stats.module.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/libs/stats.module.js"
        }
    }
    </script>
    
    <script>
    // Essential variables to prevent undefined errors
    // These are fallback values that will be overridden by the main script when it loads
    window.AGORA_FEATURES = {
        templeOfHephaistos: { position: { x: 0, z: 0 } },
        stoaOfAttalos: { position: { x: 0, z: 0 } },
        tholos: { position: { x: 0, z: 0 } },
        bouleuterion: { position: { x: 0, z: 0 } },
        altarOfTwelveGods: { position: { x: 0, z: 0 } }
    };
    
    window.AREOPAGUS_POSITION = { x: 0, z: 0 };
    window.KERAMEIKOS_POSITION = { x: 0, z: 0 };
    window.PHALERON_POSITION = { x: 0, z: 0 };
    </script>
<script type="module">
        import { threeReady } from './src/three.js';
        import { Sky } from 'three/examples/jsm/objects/Sky.js';

        window.Sky = Sky;
        window.threeJSReady = threeReady;
    </script>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(5px);
            transition: opacity 1s ease;
        }

        .overlay-button {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
            border: 2px solid rgba(255, 215, 0, 1);
            color: #ffffff;
            font-family: 'Cinzel', serif;
            padding: 15px 30px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);
            margin-top: 20px;
        }
        .overlay-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7), 0 0 60px rgba(255, 215, 0, 0.5);
        }
        
        #fps-counter {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 100;
            border: 1px solid rgba(0, 255, 0, 0.3);
            display: none; /* Hidden by default */
        }
         #fps-counter.show {
            display: block;
        }
        
        canvas {
            display: block;
            border-radius: 0;
        }
        
        .golden-text {
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            font-family: 'Cinzel', serif;
        }
        
        .elegant-text {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 300;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        #current-district,
        .hud-district-label {
            margin-top: 4px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 1px 4px rgba(0,0,0,0.4);
        }

        .control-key {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-weight: 600;
            color: #FFD700;
        }
        
        .gemini-button {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            font-family: 'Cinzel', serif;
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            width: 100%;
        }

        .gemini-button:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 215, 0, 0.2));
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        .gemini-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .prompt {
            position: absolute;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            width: 220px;
            text-align: center;
            transform: translate(-50%, -100%);
        }
        .prompt.show {
            opacity: 1;
            pointer-events: all;
        }

        .info-scroll-overlay, .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .info-scroll-overlay.show, .modal-overlay.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .info-content, .modal-content {
            background: #fdf6e3;
            color: #584b3e;
            padding: 40px 60px;
            border-radius: 5px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Cormorant Garamond', serif;
            font-size: 20px;
            line-height: 1.7;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.2);
            border: 10px solid #c9b78e;
            position: relative;
        }
        .close-info {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #8b795e;
        }
        
        .modal-content textarea {
            width: 100%;
            height: 80px;
            margin-top: 15px;
            background: #ece5d8;
            border: 1px solid #c9b78e;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 18px;
        }
         .modal-content .gemini-response {
            margin-top: 15px;
            padding: 15px;
            background: #ece5d8;
            border-radius: 5px;
            border-left: 3px solid #c9b78e;
            font-style: italic;
            min-height: 50px;
        }


        #hud {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 50%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            color: white;
            transition: transform 0.4s ease-in-out;
            font-size: 14px;
        }

        #hud.hidden {
            transform: translateY(100%);
        }

        #hud h3 {
            margin: 0;
        }

        #hud-left, #hud-center, #hud-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #hud-center {
            font-family: 'Helvetica', Arial, sans-serif;
            font-size: 13px;
            opacity: 0.8;
        }

        #hud-right {
            text-align: right;
        }

        #toggle-hud {
            position: absolute;
            bottom: calc(100% - 1px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 18px;
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        #toggle-hud:hover {
            background: rgba(0,0,0,0.8);
        }

        #mini-map-wrapper {
            position: fixed;
            bottom: 140px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            z-index: 101;
        }

        #mini-map-container {
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #FFD700;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        #mini-map-wrapper.collapsed #mini-map-container {
            opacity: 0;
            transform: scale(0.85);
            pointer-events: none;
        }

        #mini-map-toggle {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 215, 0, 0.6);
            color: #fcefb4;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 999px;
            cursor: pointer;
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }

        #mini-map-toggle:hover,
        #mini-map-toggle:focus-visible {
            background: rgba(0, 0, 0, 0.75);
            outline: none;
        }

        #mini-map-wrapper.collapsed #mini-map-toggle {
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            #mini-map-wrapper {
                bottom: 110px;
                left: 10px;
            }

            #mini-map-container {
                width: 140px;
                height: 140px;
            }
        }
        #map-player {
            position: absolute;
            width: 10px;
            height: 10px;
            background: yellow;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
         #map-player::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -100%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid yellow;
        }
        .map-icon {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .map-icon-democracy { background-color: #4dabf7; }
        .map-icon-cultural { background-color: #FFD700; }
        .map-icon-natural { background-color: #28a745; }
        .map-icon-district {
            background-color: rgba(255, 215, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.7);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 7px;
            font-weight: 700;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.4);
        }
    </style>
</head>
<body>
<div id="start-overlay">
<button class="overlay-button" id="start-button">Enter Ancient Athens</button>
</div>
<div id="fps-counter">FPS: <span id="fps-value">60</span></div>
<div id="hud">
<div id="hud-left">
<div id="mini-map-wrapper">
<div id="mini-map-container">
<div id="map-player"></div>
</div>
<button id="mini-map-toggle" type="button" aria-controls="mini-map-container" aria-expanded="true" aria-pressed="true">Hide Map</button>
</div>
<h3 class="golden-text" style="margin: 0; font-size: 20px;">‚ö±Ô∏è Ancient Athens</h3>
<div id="current-location"></div>
</div>
<div class="elegant-text" id="hud-center">
<span class="control-key">WASD</span> Move/Rotate |
            <span class="control-key">Arrows</span> Orbit Camera |
            <span class="control-key">E</span> Interact |
            <span class="control-key">X</span> Toggle Flight |
            <span class="control-key">Space</span>/<span class="control-key">Shift</span> Fly Up/Down (Hold Shift to Run) |
<span class="control-key">M</span> Sound |
            <span class="control-key">P</span> FPS |
            <span class="control-key">K</span> Toggle Sky
        </div>
<div class="elegant-text" id="hud-right">
<div class="golden-text" style="font-weight: 600;">üåÖ Time:</div>
<span id="current-time">Golden Dawn</span>
</div>
<button id="toggle-hud">Hide UI</button>
</div>
<!-- Character Interaction UI -->
<div class="prompt" id="pnyx-scribe-prompt">
<button class="gemini-button" data-info="pnyx">üìú Learn about the Pnyx</button>
</div>
<div class="prompt" id="bouleuterion-scribe-prompt">
<button class="gemini-button" data-info="bouleuterion">üìú Learn about the Bouleuterion</button>
</div>
<div class="prompt" id="dikasteria-scribe-prompt">
<button class="gemini-button" data-info="dikasteria">üìú Learn about the Dikasteria</button>
</div>
<div class="info-scroll-overlay" id="info-scroll-overlay">
<div class="info-content">
<button class="close-info" id="close-info-scroll">√ó</button>
<h4 class="golden-text" id="info-title" style="text-align: center; margin-bottom: 20px;"></h4>
<p id="info-text"></p>
</div>
</div>
<canvas id="landmarks-canvas" style="position:fixed; right:16px; top:16px; width:420px; height:420px; z-index:150;
               border:1px solid #FFD700; border-radius:10px; background:rgba(0,0,0,.18);">
</canvas>
<script type="module">
// SAFETY helper: treat non-arrays as [] so `.map()` never crashes
const asArray = (v) => (Array.isArray(v) ? v : (v == null ? [] : [v]));

// Attempt to extract the first THREE.Material instance from a value that might
// be a mesh, a group, or one of the objects returned by setupGround.
const findFirstMaterial = (candidate, visited = new Set()) => {
    if (!candidate || typeof candidate !== 'object') {
        return null;
    }
    if (visited.has(candidate)) {
        return null;
    }
    visited.add(candidate);

    if ('material' in candidate) {
        for (const mat of asArray(candidate.material)) {
            if (mat && typeof mat === 'object' && mat.isMaterial) {
                return mat;
            }
        }
    }

    if (candidate.isObject3D && Array.isArray(candidate.children)) {
        for (const child of candidate.children) {
            const material = findFirstMaterial(child, visited);
            if (material) {
                return material;
            }
        }
    }

    const nestedKeys = ['root', 'dirt', 'grass', 'mesh', 'group'];
    for (const key of nestedKeys) {
        const value = candidate[key];
        if (value) {
            const material = findFirstMaterial(value, visited);
            if (material) {
                return material;
            }
        }
    }

    if (Array.isArray(candidate)) {
        for (const value of candidate) {
            const material = findFirstMaterial(value, visited);
            if (material) {
                return material;
            }
        }
    }

    return null;
};

        import THREE from './src/three.js';
        import { makeTemple, makeStoa, makeTholos, makeAltar, MAT, setCityWallMaterial } from './src/building-kit.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { clone } from 'three/examples/jsm/utils/SkeletonUtils.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { AmbientZoneManager } from './src/audio/ambient-zones.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { createPhotoSkydome } from './src/sky/photoSkydome.js';
        import { KNOWN_PRESETS } from './src/sky/presets.js';
        import { resolvePreset } from './src/core/presetResolver.js';
        import { nightSkyDataUrl } from './src/sky/nightSkyTextureData.js';
        import { createStarField } from './src/sky/starField.js';
        import { createMoon } from './src/sky/moon.js';
        import { createMountainRim } from './src/sky/mountainRim.js';
        import { resolveAssetUrl } from './src/utils/asset-paths.js';
import {
    setupGround,
    configureGround,
    updateTrees,
    initPerformanceStats,
    updatePerformanceStats,
    toggleStatsVisibility
} from './src/main.js';
import { setEnvironment } from './src/scene/sky.js';
import * as buildingMaterials from './src/scene/materials.js';
import { createCityWallPerimeter, createCityGatehouse } from './src/scene/city-wall.js';
import { createRoadSegment, scatterPropsAlongRoad } from './src/roads/hybridRoads.js';
import {
  createDistrictsLayer,
  setDistricts,
  getDistrictAt,
  onDistrictsChanged,
  setDistrictFillsVisible,
  setDistrictOutlinesVisible,
} from './src/scene/districts.js';

import { initDistrictHUD, watchPlayerPosition } from './src/scene/districts-hud.js';

const loadBuildingTextures =
  typeof buildingMaterials.loadBuildingTextures === 'function'
    ? buildingMaterials.loadBuildingTextures
    : () => ({});

const retargetBuildingMaterials =
  typeof buildingMaterials.retargetBuildingMaterials === 'function'
    ? buildingMaterials.retargetBuildingMaterials
    : () => {};

        const TONE_JS_SOURCES = [
            'https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js'
        ];
        let toneLoadingPromise = null;

        const HORIZON_ENABLE = true;

        function loadToneFromUrl(url) {
            return new Promise((resolve, reject) => {
                if (!url) {
                    reject(new Error('Tone.js source URL is empty.'));
                    return;
                }
                if (typeof document === 'undefined' || !document.head) {
                    reject(new Error('Tone.js can only be loaded in a document environment.'));
                    return;
                }

                const script = document.createElement('script');
                script.async = true;
                script.crossOrigin = 'anonymous';
                script.dataset.toneSource = url;
                script.src = url;

                const cleanup = () => {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                };

                script.addEventListener('load', () => {
                    if (window.Tone) {
                        cleanup();
                        resolve(window.Tone);
                    } else {
                        cleanup();
                        reject(new Error(`Tone.js loaded from ${url} but did not expose a global Tone object.`));
                    }
                }, { once: true });

                script.addEventListener('error', (event) => {
                    cleanup();
                    const error = new Error(`Failed to load Tone.js from ${url}`);
                    error.event = event;
                    reject(error);
                }, { once: true });

                document.head.appendChild(script);
            });
        }

        async function loadToneLibrary() {
            if (typeof window === 'undefined') {
                return null;
            }

            if (window.Tone) {
                return window.Tone;
            }

            if (!toneLoadingPromise) {
                toneLoadingPromise = (async () => {
                    const errors = [];
                    for (const source of TONE_JS_SOURCES) {
                        if (!source) {
                            continue;
                        }

                        try {
                            const tone = await loadToneFromUrl(source);
                            if (tone) {
                                console.info(`Tone.js loaded from ${source}`);
                                return tone;
                            }
                        } catch (error) {
                            console.warn(`Tone.js failed to load from ${source}`, error);
                            errors.push({ source, error });
                        }
                    }

                    const aggregateError = new Error('Tone.js failed to load from all configured sources.');
                    aggregateError.cause = errors;
                    throw aggregateError;
                })();

                toneLoadingPromise.catch(() => {
                    toneLoadingPromise = null;
                });
            }

            return toneLoadingPromise;
        }

        let __level = 0; // updated whenever setTimeOfDay applies a new preset
        window.addEventListener('keydown', (e) => {
            const athensSky = window.__AthensSky__;
            if (!athensSky) return;
            if (e.key.toLowerCase() === 'n') {
                __level = __level === 0 ? 0.4 : (__level === 0.4 ? 1 : 0);
                desiredSkydomeOpacity = __level;
                if (typeof athensSky.setAmount === 'function') {
                    athensSky.setAmount(skyVisible ? __level : 0);
                }
                console.log('Night level:', __level);
            }
            if (e.key === '[') {
                const deg = athensSky.mesh.rotation.y * 180 / Math.PI;
                athensSky.setYaw(deg - 5);
            }
            if (e.key === ']') {
                const deg = athensSky.mesh.rotation.y * 180 / Math.PI;
                athensSky.setYaw(deg + 5);
            }
        });

        console.log("üèõÔ∏è Initializing Enhanced Ancient Athens Experience...");

        // --- Space Night module: Milky Way skybox + dust + nebulas -----------------
        const useCubeMap = false;

        const computeModuleBaseUrl = () => {
            const fallbackBase = (typeof document !== 'undefined' && document.baseURI)
                || (typeof window !== 'undefined' && window.location?.href)
                || '';
            const metaUrl = (typeof import.meta !== 'undefined' && typeof import.meta.url === 'string')
                ? import.meta.url
                : fallbackBase;

            if (!metaUrl) {
                return fallbackBase;
            }

            try {
                const resolved = new URL(metaUrl, fallbackBase || undefined);

                if (resolved.protocol === 'blob:' || resolved.protocol === 'data:') {
                    throw new Error('Unsupported base protocol');
                }

                const path = resolved.pathname || '';
                const hasTrailingSlash = path.endsWith('/');
                if (!hasTrailingSlash) {
                    const lastSegment = path.split('/').pop() || '';
                    if (lastSegment.includes('.')) {
                        resolved.pathname = path.replace(/[^/]*$/, '');
                    } else {
                        resolved.pathname = `${path.replace(/\/?$/, '')}/`;
                    }
                }

                resolved.search = '';
                resolved.hash = '';
                return resolved.href;
            } catch (error) {
                return fallbackBase || metaUrl;
            }
        };

        const moduleBaseUrl = computeModuleBaseUrl();
        const resolveRelativeUrl = (relativePath) => {
            try {
                return new URL(relativePath, moduleBaseUrl).href;
            } catch (error) {
                console.warn(`Failed to resolve relative URL "${relativePath}" relative to ${moduleBaseUrl}`, error);
                return relativePath;
            }
        };

        // SAFETY: don't assume skyAssetLocations exists; fall back to bundled /src/sky files
        const windowSkyAssetLocations = Array.isArray(window.skyAssetLocations) ? window.skyAssetLocations : [];

        // If nothing is configured, use local defaults so the app still starts
        const defaultSkyPrefixes = windowSkyAssetLocations.length
            ? windowSkyAssetLocations
            : [{ prefix: './src/sky/', label: 'bundled' }];

        const skyAssetLocations = [
            { prefix: resolveAssetUrl('assets/sky/'), label: 'assets/sky' },
            ...defaultSkyPrefixes
        ];


        const seenNightSkyTextureUrls = new Set();
        const nightSkyTextureSources = [];

        const pushNightSkyTextureSource = ({ url, label, isFallback = false, resolve = true } = {}) => {
            if (typeof url !== 'string' || url.length === 0) {
                return;
            }

            const resolvedUrl = resolve ? resolveRelativeUrl(url) : url;
            if (typeof resolvedUrl !== 'string' || resolvedUrl.length === 0) {
                return;
            }

            if (seenNightSkyTextureUrls.has(resolvedUrl)) {
                return;
            }
            seenNightSkyTextureUrls.add(resolvedUrl);

            nightSkyTextureSources.push({
                url: resolvedUrl,
                label: label || url,
                isFallback
            });
        };

        const customNightSkySources = Array.isArray(window?.nightSkyTextureSources)
            ? window.nightSkyTextureSources
            : [];

        customNightSkySources.forEach((entry, index) => {
            if (typeof entry === 'string') {
                pushNightSkyTextureSource({
                    url: entry,
                    isFallback: index > 0
                });
                return;
            }

            if (!entry || typeof entry !== 'object') {
                return;
            }

            const { url, label, isFallback, resolve = true } = entry;
            pushNightSkyTextureSource({
                url,
                label,
                isFallback: typeof isFallback === 'boolean' ? isFallback : index > 0,
                resolve
            });
        });

        skyAssetLocations.forEach(({ prefix, label }, index) => {
            pushNightSkyTextureSource({
                url: `${prefix}night_sky.jpg`,
                label: `night_sky.jpg (${label})`,
                isFallback: customNightSkySources.length > 0 || index > 0
            });
        });

        if (typeof nightSkyDataUrl === 'string' && nightSkyDataUrl.length > 0) {
            pushNightSkyTextureSource({
                url: nightSkyDataUrl,
                label: 'embedded fallback night sky',
                isFallback: true,
                resolve: false
            });
        }

        const photoSkyTexturesByKey = new Map();

        const makePhotoSkySources = (fileName, labelPrefix, fallbackEntries = []) => {
            const sources = [];
            const seen = new Set();

            const pushSource = (entry) => {
                const url = entry?.url;
                if (!url || seen.has(url)) {
                    return;
                }
                seen.add(url);
                sources.push(entry);
            };

            skyAssetLocations.forEach(({ prefix, label }, index) => {
                const url = resolveRelativeUrl(`${prefix}${fileName}`);
                pushSource({
                    url,
                    label: `${labelPrefix} (${label})`,
                    isFallback: index > 0
                });
            });

            fallbackEntries.forEach((entry) => {
                if (!entry?.url) {
                    return;
                }
                const shouldResolve = entry.resolve !== false;
                const resolvedUrl = shouldResolve ? resolveRelativeUrl(entry.url) : entry.url;
                pushSource({
                    url: resolvedUrl,
                    label: entry.label || entry.url,
                    isFallback: true
                });
            });

            return sources;
        };

        const registerPhotoSkySources = (key, fileName, labelPrefix, fallbackEntries = []) => {
            if (photoSkyTexturesByKey.has(key)) {
                return photoSkyTexturesByKey.get(key);
            }
            const sources = makePhotoSkySources(fileName, labelPrefix, fallbackEntries);
            photoSkyTexturesByKey.set(key, sources);
            return sources;
        };

        const goldenHourPhotoSources = registerPhotoSkySources(
            'golden-hour',
            'golden_hour.jpg',
            'Golden hour sky panorama',
            [
                { url: './src/sky/sunset.jpg', label: 'Bundled sunset fallback' }
            ]
        );

        const blueHourPhotoSources = registerPhotoSkySources(
            'blue-hour',
            'blue_hour.jpg',
            'Blue hour sky panorama',
            [
                { url: './src/sky/blue_hour.jpg', label: 'Bundled night sky fallback' }
            ]
        );

        // High-noon (blue daytime) photo sources: prefer assets/, fallback to bundled
        const highNoonPhotoSources = [
            { url: resolveAssetUrl('assets/sky/high_noon.jpg'), label: 'assets/high_noon' },
            { url: resolveRelativeUrl('./src/sky/high_noon.jpg'), label: 'bundled/high_noon', isFallback: true }
        ];
        photoSkyTexturesByKey.set('high-noon', highNoonPhotoSources);

        const starlitNightPhotoSources = registerPhotoSkySources(
            'starlit-night',
            'night_sky.jpg',
            'Night sky panorama',
            typeof nightSkyDataUrl === 'string' && nightSkyDataUrl.length > 0
                ? [{ url: nightSkyDataUrl, label: 'embedded fallback night sky', resolve: false }]
                : []
        );

        const photoSkyTimeConfig = {
            'Golden Dawn': {
                textureKey: 'golden-hour',
                sources: goldenHourPhotoSources,
                skydomeOpacity: 1.0,
                envIntensity: 0.85,
                exposure: 1.05,
                spaceNightAmount: 0.15
            },
            'Blue Hour': {
                textureKey: 'blue-hour',
                sources: blueHourPhotoSources,
                skydomeOpacity: 1.0,
                envIntensity: 0.9,
                exposure: 0.95,
                spaceNightAmount: 0.25
            },
            'High Noon': {
                textureKey: 'high-noon',
                sources: highNoonPhotoSources,
                skydomeOpacity: 1.0,   // show the blue sky fully
                envIntensity: 1.0,
                exposure: 1.0,
                spaceNightAmount: 0.0  // no stars at noon
            },
            'Golden Dusk': {
                textureKey: 'golden-hour',
                sources: goldenHourPhotoSources,
                skydomeOpacity: 1.0,
                envIntensity: 0.85,
                exposure: 1.1,
                spaceNightAmount: 0.2
            },
            'Starlit Night': {
                textureKey: 'starlit-night',
                sources: starlitNightPhotoSources,
                skydomeOpacity: 1.0,
                envIntensity: 0.7,
                exposure: 0.9,
                spaceNightAmount: 1.0
            }};
        const nightSkyCubeSources = defaultSkyPrefixes.map(({ prefix, label }, index) => ({
            label: `cube map (${label})`,
            urls: [
                resolveRelativeUrl(`${prefix}night_sky_right.jpg`),
                resolveRelativeUrl(`${prefix}night_sky_left.jpg`),
                resolveRelativeUrl(`${prefix}night_sky_top.jpg`),
                resolveRelativeUrl(`${prefix}night_sky_bottom.jpg`),
                resolveRelativeUrl(`${prefix}night_sky_front.jpg`),
                resolveRelativeUrl(`${prefix}night_sky_back.jpg`)
            ],
            isFallback: index > 0
        }));

        let nightSkyTexture = null;
        let nightSkyCubeTexture = null;
        let nightSkyEnvironment = null;
        let spaceGroup = null;
        let savedDayBackground = null;
        let savedDayEnvironment = null;
        let starFieldController = null;
        let moonController = null;
        let starsEnabled = true;
        let moonEnabled = true;

        function loadNightSkyEquirectangular(scene, renderer) {
            const loader = new THREE.TextureLoader();

            const sources = nightSkyTextureSources.length > 0
                ? nightSkyTextureSources
                : [{ url: nightSkyDataUrl, label: 'embedded fallback night sky', isFallback: true }];

            const trySource = (index = 0) => {
                if (index >= sources.length) {
                    console.error('Failed to load any night sky background texture.');
                    return;
                }

                const source = sources[index];
                loader.load(
                    source.url,
                    (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        if ('colorSpace' in texture && THREE.SRGBColorSpace) {
                            texture.colorSpace = THREE.SRGBColorSpace;
                        } else if ('encoding' in texture) {
                            texture.encoding = THREE.sRGBEncoding;
                        }

                        texture.encoding = THREE.sRGBEncoding;
                        texture.minFilter = THREE.LinearMipmapLinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
                        texture.anisotropy = maxAnisotropy;
                        texture.needsUpdate = true;

                        nightSkyTexture = texture;
                        scene.background = texture;

                        if (renderer) {
                            const pmrem = new THREE.PMREMGenerator(renderer);
                            nightSkyEnvironment = pmrem.fromEquirectangular(texture).texture;
                            pmrem.dispose();
                        } else {
                            nightSkyEnvironment = texture;
                        }

                        scene.environment = nightSkyEnvironment;

                        if (source.isFallback) {
                            console.info('Loaded embedded fallback night sky texture.');
                        }
                    },
                    undefined,
                    (error) => {
                        const log = source.isFallback ? console.error : console.warn;
                        log(`Failed to load ${source.label}; ${source.isFallback ? 'no further fallbacks available.' : 'trying next source.'}`, error);
                        trySource(index + 1);
                    }
                );
            };

            trySource(0);
        }

        function loadNightSkyCube(scene, renderer, attempt = 0) {
            const loader = new THREE.CubeTextureLoader();
            const source = nightSkyCubeSources[attempt];

            if (!source) {
                console.warn('Cube map night sky failed to load from all known locations; falling back to equirectangular.');
                loadNightSkyEquirectangular(scene, renderer);
                return;
            }

            nightSkyCubeTexture = loader.load(
                source.urls,
                (texture) => {
                    if ('colorSpace' in texture && THREE.SRGBColorSpace) {
                        texture.colorSpace = THREE.SRGBColorSpace;
                    }
                    scene.background = texture;
                    nightSkyEnvironment = texture;
                    scene.environment = nightSkyEnvironment;
                },
                undefined,
                (error) => {
                    const nextAttempt = attempt + 1;
                    const hasFallback = nextAttempt < nightSkyCubeSources.length;
                    const message = hasFallback
                        ? `Cube map night sky failed to load from ${source.label}, trying fallback.`
                        : `Cube map night sky failed to load from ${source.label}; falling back to equirectangular.`;
                    console.warn(message, error);
                    loadNightSkyCube(scene, renderer, nextAttempt);
                }
            );
        }

        function ensureNightSkyBackground(scene, renderer) {
            if (useCubeMap) {
                if (nightSkyCubeTexture) {
                    scene.background = nightSkyCubeTexture;
                    scene.environment = nightSkyEnvironment ?? nightSkyCubeTexture;
                } else {
                    loadNightSkyCube(scene, renderer);
                }
            } else if (nightSkyTexture) {
                scene.background = nightSkyTexture;
                if (nightSkyEnvironment) {
                    scene.environment = nightSkyEnvironment;
                }
            } else {
                loadNightSkyEquirectangular(scene, renderer);
            }
        }

        function makeSpaceDust(count = 15000, spread = { x: 40000, y: 10000, z: 40000 }) {
            const geo = new THREE.BufferGeometry();
            const pts = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                pts[i * 3 + 0] = (Math.random() - 0.5) * spread.x;
                pts[i * 3 + 1] = (Math.random() - 0.5) * spread.y;
                pts[i * 3 + 2] = (Math.random() - 0.5) * spread.z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xaaaaaa, size: 1.2, transparent: true, opacity: 0.1,
                depthWrite: false, blending: THREE.AdditiveBlending
            });
            const dust = new THREE.Points(geo, mat);
            dust.frustumCulled = false;
            dust.userData.baseOpacity = mat.opacity;
            return dust;
        }

        function makeNebulas(textureLoader, howMany = 10) {
            const group = new THREE.Group();
            const baseMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/cloud.png', (t) => {
                if ('colorSpace' in t && 'SRGBColorSpace' in THREE) t.colorSpace = THREE.SRGBColorSpace;
            });
            for (let i = 0; i < howMany; i++) {
                const mat = new THREE.SpriteMaterial({
                    map: baseMap, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
                    opacity: 0.08, color: new THREE.Color().setHSL(Math.random(), 0.5, 0.7)
                });
                const s = Math.random() * 2000 + 1500;
                const spr = new THREE.Sprite(mat);
                spr.scale.set(s, s, 1);
                spr.position.set(
                    (Math.random() - 0.5) * 25000,
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 25000 - 1000
                );
                spr.material.rotation = Math.random() * Math.PI;
                spr.frustumCulled = false;
                spr.userData.baseOpacity = mat.opacity;
                group.add(spr);
            }
            return group;
        }

        function initSpaceNight({ scene, renderer, textureLoader, camera, requestDayEnvironment } = {}) {
            if (camera && camera.far < 50000) {
                camera.far = 50000;
                camera.updateProjectionMatrix();
            }

            savedDayBackground = scene.background || null;
            savedDayEnvironment = scene.environment || null;

            let currentNightAmount = 0;

            const captureDayState = ({
                force = false,
                captureBackground = true,
                captureEnvironment = true
            } = {}) => {
                let envFromCallback;
                let backgroundFromCallback;

                if ((captureEnvironment || captureBackground) && typeof requestDayEnvironment === 'function') {
                    try {
                        const response = requestDayEnvironment({
                            scene,
                            renderer,
                            force,
                            captureBackground,
                            captureEnvironment
                        });

                        if (response && typeof response === 'object' && !response?.isTexture) {
                            if (captureBackground && Object.prototype.hasOwnProperty.call(response, 'background')) {
                                backgroundFromCallback = response.background;
                                savedDayBackground = backgroundFromCallback ?? null;
                            }
                            if (captureEnvironment && Object.prototype.hasOwnProperty.call(response, 'environment')) {
                                envFromCallback = response.environment;
                                savedDayEnvironment = envFromCallback ?? null;
                            }
                        } else if (captureEnvironment && response !== undefined) {
                            envFromCallback = response;
                            savedDayEnvironment = envFromCallback ?? null;
                        }
                    } catch (error) {
                        console.warn('SpaceNight: failed to refresh day environment map.', error);
                    }
                }

                if (captureBackground && backgroundFromCallback === undefined) {
                    const candidateBg = scene.background;
                    if (
                        candidateBg === null ||
                        (candidateBg !== nightSkyTexture && candidateBg !== nightSkyCubeTexture)
                    ) {
                        savedDayBackground = candidateBg ?? null;
                    }
                }

                if (captureEnvironment && envFromCallback === undefined) {
                    const candidateEnv = scene.environment;
                    if (
                        candidateEnv === null ||
                        (candidateEnv !== nightSkyEnvironment && candidateEnv !== nightSkyCubeTexture)
                    ) {
                        savedDayEnvironment = candidateEnv ?? null;
                    }
                }

                return { background: savedDayBackground, environment: savedDayEnvironment };
            };

            spaceGroup = new THREE.Group();
            spaceGroup.name = 'SpaceNightFX';
            spaceGroup.renderOrder = -110;
            const dust = makeSpaceDust();
            const nebulas = makeNebulas(textureLoader);
            spaceGroup.add(dust, nebulas);

            spaceGroup.traverse(o => {
                if (o.material) {
                    o.material.fog = false;
                    o.renderOrder = -100;
                }
            });

            spaceGroup.visible = false;
            scene.add(spaceGroup);

            if (starFieldController?.points && starFieldController.points.parent) {
                starFieldController.points.parent.remove(starFieldController.points);
            }
            if (moonController?.group && moonController.group.parent) {
                moonController.group.parent.remove(moonController.group);
            }

            try {
                const devicePixelRatio = window?.devicePixelRatio ?? 1;
                const starTarget = Math.round(9500 / Math.max(1, devicePixelRatio * 0.85));
                starFieldController = createStarField({
                    count: THREE.MathUtils.clamp(starTarget, 5000, 10000),
                    innerRadius: 2000,
                    outerRadius: 2400,
                    opacity: 0.9
                });
                starFieldController.setEnabled(starsEnabled);
                starFieldController.setVisibilityFactor(0);
                if (starFieldController.points) {
                    starFieldController.points.visible = false;
                    scene.add(starFieldController.points);
                }
                window.getStarField = () => starFieldController?.points ?? null;
            } catch (error) {
                console.warn('[sky] Failed to build procedural star field.', error);
                starFieldController = null;
                window.getStarField = () => null;
            }

            try {
                moonController = createMoon({
                    textureLoader,
                    textureUrl: resolveAssetUrl('assets/sky/moon.jpg'),
                    radius: 2200,
                    sphereRadius: 52,
                    glowSize: 420
                });
                moonController.setEnabled(moonEnabled);
                moonController.setVisibilityFactor(0);
                if (moonController.group) {
                    scene.add(moonController.group);
                }
                window.getMoon = () => moonController?.mesh ?? null;
            } catch (error) {
                console.warn('[sky] Failed to initialize procedural moon.', error);
                moonController = null;
                window.getMoon = () => null;
            }

            captureDayState({ force: true });

            ensureNightSkyBackground(scene, renderer);

            let elapsedTime = 0;

            return {
                update(dt, camera) {
                    if (!spaceGroup) return;
                    elapsedTime += dt;
                    spaceGroup.children.forEach((o, i) => {
                        if (o.isPoints) o.rotation.y += dt * 0.002;
                        if (o.isSprite) o.material.rotation += (i % 2 ? 1 : -1) * dt * 0.05;
                    });
                    if (camera) {
                        spaceGroup.position.lerp(camera.position, 0.05);
                    }
                    if (starFieldController) {
                        starFieldController.update(dt, elapsedTime, camera ?? null);
                    }
                    if (moonController) {
                        moonController.update(dt, camera ?? null);
                    }
                },
                setAmount(nightAmount) {
                    if (!spaceGroup) return;
                    const clamped = THREE.MathUtils.clamp(nightAmount, 0, 1);
                    spaceGroup.visible = clamped > 0.0;
                    spaceGroup.traverse(o => {
                        const mat = o.material;
                        if (mat && typeof mat.opacity === 'number') {
                            const base = o.userData?.baseOpacity ?? mat.opacity;
                            mat.opacity = base * clamped;
                        }
                    });
                    currentNightAmount = clamped;
                    if (starFieldController) {
                        const starVisibility = starsEnabled ? clamped : 0;
                        starFieldController.setVisibilityFactor(starVisibility);
                    }
                    if (moonController) {
                        const moonVisibility = moonEnabled ? Math.pow(clamped, 0.8) : 0;
                        moonController.setVisibilityFactor(moonVisibility);
                    }
                    if (clamped > 0.6) {
                        ensureNightSkyBackground(scene, renderer);
                    } else {
                        captureDayState({ force: true });
                        scene.background = savedDayBackground ?? null;
                        scene.environment = savedDayEnvironment ?? null;
                    }
                },
                syncDayEnvironment(options = {}) {
                    const { environment, background, force = false } = options ?? {};
                    const captureBackground = background === undefined;
                    const captureEnvironment = environment === undefined;

                    if (!captureBackground) {
                        savedDayBackground = background ?? null;
                    }

                    if (!captureEnvironment) {
                        savedDayEnvironment = environment ?? null;
                    }

                    const result = captureDayState({
                        force,
                        captureBackground,
                        captureEnvironment
                    });

                    if (options?.restore === true && currentNightAmount <= 0.6) {
                        scene.background = savedDayBackground ?? null;
                        scene.environment = savedDayEnvironment ?? null;
                    }

                    return result;
                },
                get amount() {
                    return currentNightAmount;
                }
            };
        }

        // Wait for THREE.js to be available before proceeding
        // Enhanced error diagnostics utility
        function logDetailedError(context, error) {
            console.group(`üèõÔ∏è Athens Initialization Error - ${context}`);
            
            // Basic error information
            console.error('Error:', error);
            
            // Enhanced error details
            if (error instanceof Event) {
                console.warn('Error is an Event object:', {
                    type: error.type,
                    target: error.target,
                    currentTarget: error.currentTarget,
                    eventPhase: error.eventPhase,
                    bubbles: error.bubbles,
                    cancelable: error.cancelable,
                    timeStamp: error.timeStamp
                });
            } else if (error instanceof Error) {
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
            } else if (typeof error === 'object' && error !== null) {
                console.warn('Non-standard error object:', error);
                console.warn('Error properties:', Object.getOwnPropertyNames(error));
            } else {
                console.warn('Primitive error value:', typeof error, error);
            }
            
            // Browser and environment context
            console.info('Environment context:', {
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                threeJSAvailable: typeof THREE !== 'undefined',
                cannonJSAvailable: typeof CANNON !== 'undefined'
            });
            
            console.groupEnd();
        }

        // Create user-friendly error overlay
        function showErrorOverlay(context, error, isBlocking = false) {
            const existingOverlay = document.getElementById('athens-error-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            const overlay = document.createElement('div');
            overlay.id = 'athens-error-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                max-width: 400px;
                background: rgba(139, 0, 0, 0.95);
                border: 2px solid #ff6b6b;
                border-radius: 10px;
                padding: 20px;
                color: #ffffff;
                font-family: 'Cinzel', serif;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
                ${isBlocking ? 'top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 600px;' : ''}
            `;

            const errorType = error instanceof Event ? 'Event' : error?.name || 'Unknown';
            const errorMessage = error instanceof Event 
                ? `Event type: ${error.type}` 
                : error?.message || String(error);

            overlay.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 24px; margin-right: 10px;">‚ö†Ô∏è</span>
                    <h3 style="margin: 0; color: #ff6b6b;">Athens Initialization ${isBlocking ? 'Failed' : 'Warning'}</h3>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Context:</strong> ${context}<br>
                    <strong>Error Type:</strong> ${errorType}<br>
                    <strong>Details:</strong> ${errorMessage}
                </div>
                <div style="font-size: 12px; opacity: 0.8; margin-bottom: 15px;">
                    Check browser console for detailed error information and stack trace.
                </div>
                <button onclick="this.parentElement.remove()" style="
                    background: transparent;
                    border: 1px solid #ff6b6b;
                    color: #ffffff;
                    padding: 8px 16px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-family: inherit;
                ">Dismiss</button>
            `;

            document.body.appendChild(overlay);

            // Auto-dismiss non-blocking overlays after 10 seconds
            if (!isBlocking) {
                setTimeout(() => {
                    if (overlay.parentElement) {
                        overlay.remove();
                    }
                }, 10000);
            }
        }

        function readSkyFromURL() {
            if (typeof window === 'undefined') {
                return null;
            }
            try {
                const url = new URL(window.location.href);
                const value = url.searchParams.get('sky');
                return value ?? null;
            } catch (error) {
                console.debug('[Athens] Unable to parse sky preset from URL.', error);
                return null;
            }
        }

        function determineSkydomePreset(opts) {
            const fromOptions = opts?.preset ?? opts?.skydomePreset ?? null;
            const fromURL = readSkyFromURL();
            const fromEnv = typeof window !== 'undefined'
                ? window.__AthensEnv?.preset ?? window.__AthensEnv?.skydomePreset ?? null
                : null;
            const rawName = fromOptions ?? fromURL ?? fromEnv ?? null;
            const safeName = resolvePreset(rawName);

            if (!rawName) {
                console.warn('[Athens] initializeAthens(): No preset provided. Falling back to default:', safeName);
            }

            return safeName;
        }

        let initialSetupPromise = null;

        async function initializeAthens(options = {}) {
            try {
                if (window.threeJSReady) {
                    await window.threeJSReady;
                }

                if (!initialSetupPromise) {
                    initialSetupPromise = (async () => {
                        if (typeof init === 'function') {
                            await init();
                        }
                    })().catch((error) => {
                        initialSetupPromise = null;
                        throw error;
                    });
                }

                await initialSetupPromise;

                if (typeof THREE === 'undefined') {
                    console.error('THREE.js is not available. Please ensure external resources can be loaded.');
                    document.body.innerHTML = '<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;font-family:Arial,sans-serif;color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:10px;"><h2>üèõÔ∏è Ancient Athens</h2><p>External libraries are required to run this experience.<br>Please allow external resources or use a different environment.</p><p><small>THREE.js library could not be loaded.</small></p></div>';
                    return;
                }

                console.log('THREE.js is ready, initializing Athens...');

                const envOptions = typeof window !== 'undefined' ? window.__AthensOptions : null;
                const mergedOptions = { ...(envOptions || {}), ...(options || {}) };
                const presetName = determineSkydomePreset(mergedOptions || undefined);
                const mainOptions = { ...mergedOptions, preset: presetName, skydomePreset: presetName };
                if (typeof window !== 'undefined') {
                    window.__AthensOptions = mainOptions;
                    window.__AthensSkyPreset = presetName;
                    window.__AthensResolvedName = presetName;
                    window.__AthensPreset = presetName;
                }

                try {
                    await runAthens(mainOptions);
                } catch (error) {
                    console.error('üèõÔ∏è Athens Initialization Error - initializeAthens()', error);
                    throw error;
                }
            } catch (error) {
                if (!error?.__athensLogged) {
                    console.error('Athens experience failed to initialize:', error);
                    if (error?.stack) {
                        console.error(error.stack);
                    }
                    logDetailedError('Main Function Execution', error);
                    showErrorOverlay('Main Function Execution', error, true);
                    error.__athensLogged = true;
                }
                throw error;
            }
        }

        if (typeof window !== 'undefined') {
            console.info('[Athens][Inline] Preparing initializer exposure');
            window.initializeAthens = initializeAthens;
            window.runAthens = runAthens;
            if (typeof window.dispatchEvent === 'function') {
                queueMicrotask(() => {
                    const detail = { initializer: initializeAthens };
                    try {
                        window.dispatchEvent(new CustomEvent('athens:initializer-ready', { detail }));
                    } catch (error) {
                        try {
                            if (typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                                const event = document.createEvent('CustomEvent');
                                event.initCustomEvent('athens:initializer-ready', false, false, detail);
                                window.dispatchEvent(event);
                            }
                        } catch (innerError) {
                            console.debug('[Athens] Unable to dispatch initializer-ready event immediately.', innerError);
                        }
                    }
                });
            }
        }

        const CITY_SCALE = 2;
        const scaleValue = (value) => value * CITY_SCALE;
        const scaleLocation = ({ x, y = 0, z }) => new THREE.Vector3(scaleValue(x), y, scaleValue(z));
        const scaleXZ = (x, z) => ({ x: scaleValue(x), z: scaleValue(z) });
        const scaledVector3 = (x, y, z) => scaleLocation({ x, y, z });
        const setScaledPosition = (object, x, y, z) => {
            object.position.set(scaleValue(x), y, scaleValue(z));
        };

        async function runAthens(options = {}) {

            const fallbackPreset = typeof window !== 'undefined'
                ? window.__AthensPreset ?? window.__AthensResolvedName ?? window.__AthensSkyPreset ?? null
                : null;
            const providedPreset = options?.preset ?? options?.skydomePreset ?? fallbackPreset;
            const safePreset = resolvePreset(providedPreset);

            if (!providedPreset) {
                console.warn('[Athens] runAthens(): No preset passed, using default:', safePreset);
            }

            options = { ...options, preset: safePreset, skydomePreset: safePreset };

            if (typeof window !== 'undefined') {
                window.__AthensPreset = safePreset;
                window.__AthensResolvedName = safePreset;
                window.__AthensSkyPreset = safePreset;
            }

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, composer, ambientLight, directionalLight, hemisphereLight, player, ambientZoneManager;
        let world;
        let controls = { W: false, A: false, S: false, D: false, E: false, ShiftLeft: false, ShiftRight: false, Space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
        const toggleKeyTimestamps = {};
        const playerWalkSpeed = 14.0;
        const playerRunSpeed = 24.0;
        const playerRotationSpeed = 3.0;
        const flightSpeed = 30.0;
        const flightVerticalSpeed = 15.0;
        let scatterDemoGroup = null;
        let scatterDemoPromise = null;

        function disposeHybridRoadGroup(group) {
            if (!group) {
                return;
            }

            group.traverse((child) => {
                if (child.isMesh || child.isInstancedMesh) {
                    if (child.geometry && typeof child.geometry.dispose === 'function') {
                        child.geometry.dispose();
                    }

                    const { material } = child;
                    if (Array.isArray(material)) {
                        material.forEach((mat) => mat?.dispose?.());
                    } else if (material && typeof material.dispose === 'function') {
                        material.dispose();
                    }
                }
            });

            if (group.parent) {
                group.parent.remove(group);
            }
        }

        async function buildScatterDemo() {
            if (!scene) {
                console.warn('[roads] scatterTest called before the scene is ready.');
                return null;
            }

            if (scatterDemoPromise) {
                return scatterDemoPromise;
            }

            scatterDemoPromise = (async () => {
                if (scatterDemoGroup) {
                    disposeHybridRoadGroup(scatterDemoGroup);
                    scatterDemoGroup = null;
                }

                const group = new THREE.Group();
                group.name = 'debug:hybrid-road-demo';
                scene.add(group);

                const start = new THREE.Vector3(-24, 0.12, -14);
                const mid = new THREE.Vector3(0, 0.1, -2);
                const end = new THREE.Vector3(22, 0.12, 14);

                const roadSegment = await createRoadSegment('assets/textures/athens_dust.jpg', start, end, 6);
                group.add(roadSegment);

                const propsGroup = await scatterPropsAlongRoad(group, [start, mid, end], {
                    roadWidth: 6,
                    torch: { spacing: 12, startOffset: 4, offset: 1.8, maxCount: 16 },
                    rock: { maxCount: 48 },
                    grass: { maxCount: 96 }
                });

                group.userData.hybridRoadProps = propsGroup;

                scatterDemoGroup = group;
                return group;
            })();

            try {
                return await scatterDemoPromise;
            } catch (error) {
                console.warn('[roads] scatterTest failed:', error);
                throw error;
            } finally {
                scatterDemoPromise = null;
            }
        }

        window.scatterTest = () => buildScatterDemo();
        const pendingAmbientZones = [];
        function registerAmbientZone(node, options = {}) {
            if (!node) {
                return;
            }

            if (ambientZoneManager) {
                ambientZoneManager.registerZone({ node, ...options });
                return;
            }

            pendingAmbientZones.push({ node, options });
        }

        function flushPendingAmbientZones() {
            if (!ambientZoneManager || pendingAmbientZones.length === 0) {
                return;
            }

            const queued = pendingAmbientZones.splice(0, pendingAmbientZones.length);
            queued.forEach(({ node, options }) => {
                ambientZoneManager.registerZone({ node, ...options });
            });
        }
        // Controls how quickly the photographic sky panorama pans across the horizon.
        const PHOTO_SKYDOME_SCROLL_SPEED_DEG_PER_SECOND = 1.0;
        const GEO_TO_SCENE_MATRIX = Object.freeze({
            a: 0.1990872551715,
            b: -0.05643461237683576,
            c: -0.1365997066329714,
            d: 0.05987080329678062,
            tx: 94.87890378320046,
            tz: -70.43723980152546
        });

        const PROJECTED_GEO_POINTS = Object.freeze({
            acropolis: { x: 97.80053937706748, y: -75.48139950406926 },
            agora: { x: -3216.492436155211, y: 9847.555926499888 },
            pnyx: { x: -15502.191082680132, y: -23548.291311453097 },
            areopagus: { x: 8191.656307060039, y: -7963.562600419857 },
            kerameikos: { x: 9946.756113702198, y: 12073.945742354728 },
            phaleron: { x: -1788.1200260881237, y: -3775.8251193131027 },
            peiraeus: { x: -7198.027872715054, y: -3785.5099150114647 }
        });

        const applyGeoToScene = ({ x, y }) => ({
            x: GEO_TO_SCENE_MATRIX.a * x + GEO_TO_SCENE_MATRIX.b * y + GEO_TO_SCENE_MATRIX.tx,
            z: GEO_TO_SCENE_MATRIX.c * x + GEO_TO_SCENE_MATRIX.d * y + GEO_TO_SCENE_MATRIX.tz
        });

        const applyGeoOffsetToScene = ({ x, y }) => ({
            x: GEO_TO_SCENE_MATRIX.a * x + GEO_TO_SCENE_MATRIX.b * y,
            z: GEO_TO_SCENE_MATRIX.c * x + GEO_TO_SCENE_MATRIX.d * y
        });

        const AGORA_ANCHOR_SCENE = applyGeoToScene(PROJECTED_GEO_POINTS.agora);
        const ACROPOLIS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.acropolis);
        const PNYX_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.pnyx);
        const AREOPAGUS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.areopagus);
        const KERAMEIKOS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.kerameikos);
        const PHALERON_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.phaleron);
        const PEIRAEUS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.peiraeus);

        if (typeof window !== 'undefined') {
            window.ACROPOLIS_POSITION = ACROPOLIS_POSITION;
            window.PNYX_POSITION = PNYX_POSITION;
            window.AREOPAGUS_POSITION = AREOPAGUS_POSITION;
            window.KERAMEIKOS_POSITION = KERAMEIKOS_POSITION;
            window.PHALERON_POSITION = PHALERON_POSITION;
            window.PEIRAEUS_POSITION = PEIRAEUS_POSITION;
        }

        const createOffsetDistrictPolygon = (origin, offsets) => offsets.map(([dx, dz]) => [
            scaleValue(origin.x + dx),
            scaleValue(origin.z + dz)
        ]);
        const createDistrictDefinitions = () => [
            {
                id: 'agora',
                name: 'Agora',
                color: 0xffc15e,
                polygon: createOffsetDistrictPolygon(AGORA_ANCHOR_SCENE, [
                    [-150, -110],
                    [150, -120],
                    [160, 140],
                    [-160, 130]
                ]),
                dustBias: 0.35
            },
            {
                id: 'acropolis',
                name: 'Acropolis',
                color: 0xd6c1b5,
                polygon: createOffsetDistrictPolygon(ACROPOLIS_POSITION, [
                    [-110, -80],
                    [120, -70],
                    [130, 100],
                    [-120, 110]
                ]),
                dustBias: 0.2
            },
            {
                id: 'pnyx',
                name: 'Pnyx Hill',
                color: 0x7db0d6,
                polygon: createOffsetDistrictPolygon(PNYX_POSITION, [
                    [-140, -70],
                    [110, -80],
                    [130, 100],
                    [-160, 90]
                ]),
                dustBias: 0.3
            },
            {
                id: 'kerameikos',
                name: 'Kerameikos',
                color: 0xb894a6,
                polygon: createOffsetDistrictPolygon(KERAMEIKOS_POSITION, [
                    [-110, -160],
                    [150, -150],
                    [160, 80],
                    [-130, 90]
                ]),
                dustBias: 0.45
            },
            {
                id: 'areopagus',
                name: 'Areopagus',
                color: 0x9ec48d,
                polygon: createOffsetDistrictPolygon(AREOPAGUS_POSITION, [
                    [-90, -70],
                    [90, -60],
                    [100, 80],
                    [-100, 90]
                ]),
                dustBias: 0.25
            }
        ];

        const transformAgoraOffset = (offset) => {
            const delta = applyGeoOffsetToScene(offset);
            return {
                x: AGORA_ANCHOR_SCENE.x + delta.x,
                z: AGORA_ANCHOR_SCENE.z + delta.z
            };
        };

        const BUILDING_MODEL_PATH = resolveAssetUrl('assets/models/buildings/');
        if (typeof window !== 'undefined') {
            window.BUILDING_MODEL_PATH = BUILDING_MODEL_PATH;
        }

        const AGORA_FEATURES = {
            templeOfHephaistos: {
                position: transformAgoraOffset({ x: -78, y: 72 }),
                rotation: -17 * Math.PI / 180,
                asset: {
                    model: `${BUILDING_MODEL_PATH}temple_doric_medium.glb`,
                    target: { width: 14, length: 32, height: 11 }
                }
            },
            stoaOfAttalos: {
                position: transformAgoraOffset({ x: 64, y: 6 }),
                rotation: 5 * Math.PI / 180
            },
            tholos: {
                position: transformAgoraOffset({ x: -32, y: -38 }),
                rotation: 0
            },
            bouleuterion: {
                position: transformAgoraOffset({ x: -55, y: -24 }),
                rotation: -12 * Math.PI / 180
            },
            altarOfTwelveGods: {
                position: transformAgoraOffset({ x: 6, y: 52 }),
                rotation: 4 * Math.PI / 180
            }
        };

        if (typeof window !== 'undefined') {
            window.AGORA_FEATURES = AGORA_FEATURES;
        }

        const LONG_WALL_DIRECTION = Math.atan2(
            PEIRAEUS_POSITION.x - KERAMEIKOS_POSITION.x,
            PEIRAEUS_POSITION.z - KERAMEIKOS_POSITION.z
        );

        // --- LOAD THE GREEK TEMPLE GLB ---
        function loadGreekTemple() {
          const loader = new GLTFLoader();
          const targetPath = AGORA_FEATURES.templeOfHephaistos.asset?.model || `${BUILDING_MODEL_PATH}temple_doric_medium.glb`;
          console.log('Loading GLB:', targetPath);

          loader.load(
            targetPath,
            (gltf) => {
              const source = gltf.scene || gltf.scenes?.[0];
              if (!source) { console.warn('GLB loaded but no scene found'); return; }

              const temple = source.clone(true);
              temple.traverse((obj) => {
                if (obj.isMesh) {
                  obj.material = selectAgoraMaterialForMesh(obj);
                }
              });
              enableShadows(temple);
              fitModelToFootprint(temple, AGORA_FEATURES.templeOfHephaistos.asset?.target);

              setScaledPosition(temple, 15, 0, -55);
              temple.rotation.y = THREE.MathUtils.degToRad(5);

              scene.add(temple);
              console.log('Temple GLB added to scene ‚úîÔ∏è');
            },
            undefined,
            (err) => {
              console.error('‚ùå Failed to load GLB', err);
            }
          );
        }

        window.athensWorldBuilt = false;
        const externalAnimationMixers = [];
        window.externalAnimationMixers = externalAnimationMixers;


        const scaleBounds = ({ xMin, xMax, zMin, zMax }) => ({
            xMin: scaleValue(xMin),
            xMax: scaleValue(xMax),
            zMin: scaleValue(zMin),
            zMax: scaleValue(zMax)
        });
        let isFlying = false;
        const clock = new THREE.Clock();

        let cameraOffset = new THREE.Vector3(0, 3, 7);

        let audioStarted = false;
        let audioStartInProgress = false;
        const chickens = [];
        const citizens = [];
        const HOPLITE_PATROL_SCRATCH = {
            position: new THREE.Vector3(),
            forward: new THREE.Vector3(),
            quaternion: new THREE.Quaternion()
        };
        const HOPLITE_PATROL_Y_AXIS = new THREE.Vector3(0, 1, 0);
        const CITIZEN_MODEL_URL = './models/npc_athenian.glb';
        const citizenLoader = new GLTFLoader();
        let citizenModelCache = null;
        let citizenModelLoadingPromise = null;

        function loadCitizenModel() {
            if (citizenModelCache) {
                return Promise.resolve(citizenModelCache);
            }

            if (citizenModelLoadingPromise) {
                return citizenModelLoadingPromise;
            }

            citizenModelLoadingPromise = new Promise((resolve, reject) => {
                citizenLoader.load(
                    CITIZEN_MODEL_URL,
                    (gltf) => {
                        const baseModel = gltf.scene || gltf.scenes?.[0];
                        if (!baseModel) {
                            citizenModelLoadingPromise = null;
                            reject(new Error('Citizen model GLB did not include a scene graph.'));
                            return;
                        }

                        baseModel.updateMatrixWorld(true);
                        const bounds = new THREE.Box3().setFromObject(baseModel);
                        const height = Math.max(0.001, bounds.max.y - bounds.min.y);
                        const targetHeight = 2.4;
                        const scaleFactor = targetHeight / height;
                        const pivotOffset = -bounds.min.y * scaleFactor;

                        citizenModelCache = {
                            baseModel,
                            animations: gltf.animations || [],
                            scaleFactor,
                            pivotOffset
                        };

                        citizenModelLoadingPromise = null;
                        resolve(citizenModelCache);
                    },
                    undefined,
                    (error) => {
                        citizenModelLoadingPromise = null;
                        reject(error);
                    }
                );
            });

            return citizenModelLoadingPromise;
        }
        const citizenZones = [
            { name: 'agora', center: scaleLocation(AGORA_ANCHOR_SCENE), radius: scaleValue(12), count: 6 },
            { name: 'pnyx', center: scaleLocation(PNYX_POSITION), radius: scaleValue(8), count: 3 },
            { name: 'stoa', center: scaleLocation(AGORA_FEATURES.stoaOfAttalos.position), radius: scaleValue(10), count: 4 },
            { name: 'residential', center: scaleLocation({ x: -40, z: 8 }), radius: scaleValue(9), count: 4 }
        ];
        const interactables = [];
        const updatableObjects = [];
        const pointLights = [];
        const physicsObjects = [];
        let sky;
        let sun;
        const starMaterials = [];
        let starLayerInner;
        let starLayerOuter;
        let milkyWayMesh;
        let skyUniforms;
        let bloomPass;
        let fogEnabled = true;
        let spaceNight = null;
        starFieldController = null;
        moonController = null;
        starsEnabled = true;
        moonEnabled = true;
        let mountainRimMesh = null;
        let rimEnabled = HORIZON_ENABLE;
        let photoSkydome = null;
        let photoSkydomeYawDeg = 0;
        let currentPhotoSkyKey = null;
        let canChickenCluck = true;
        let lastCluckTime = 0;

        window.getSkyPreset = () => window.__AthensSkyPreset || null;
        window.getStarField = () => starFieldController?.points ?? null;
        window.getMoon = () => moonController?.mesh ?? null;
        window.toggleStars = () => {
            starsEnabled = !starsEnabled;
            if (starFieldController) {
                starFieldController.setEnabled(starsEnabled);
                starFieldController.setVisibilityFactor(starsEnabled ? (spaceNight?.amount ?? 0) : 0);
            }
            return starsEnabled;
        };
        window.toggleMoon = () => {
            moonEnabled = !moonEnabled;
            if (moonController) {
                moonController.setEnabled(moonEnabled);
                moonController.setVisibilityFactor(moonEnabled ? Math.pow(spaceNight?.amount ?? 0, 0.8) : 0);
            }
            return moonEnabled;
        };
        window.toggleRim = () => {
            rimEnabled = !rimEnabled;
            if (mountainRimMesh) {
                mountainRimMesh.visible = rimEnabled;
            }
            return rimEnabled;
        };
        
        let fps = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        
        let soundEnabled = true;
        const initialSkyPreset = safePreset;
        const initialSkyConfig = photoSkyTimeConfig?.[initialSkyPreset] || null;
        if (typeof window !== 'undefined') {
            window.__AthensSkyPreset = initialSkyPreset;
        }
        let crowdChatter, crowdPanner, marketVolume, merchantSynth, merchantVolume, merchantLoop;
        let blacksmithSound, blacksmithLoop;
        let fountainNoise, fountainPanner, fountainVolume;
        let windNoise, windPanner, windVolume;
        let seagullSynth, seagullPanner, seagullVolume, seagullLoop;
        let templeChantSynth, templeChantPanner, templeVolume, templeChantLoop;
        let animalAmbiences = null;
        let masterBus, environmentReverb;
        let landmarkLabelUpdater = null;
        let landmarkGroups = null;
        const blacksmithPosition = scaleLocation({ x: -12, y: 1, z: 10 });
        const marketAmbiencePosition = scaleLocation({ x: 12, y: 1.5, z: -8 });
        const fountainPosition = scaleLocation({ x: 24, y: 1, z: 14 });
        const hillsideWindPosition = scaleLocation({ x: -26, y: 8, z: -12 });
        const templeChantPosition = scaleLocation({ x: AGORA_FEATURES.templeOfHephaistos.position.x, y: 6, z: AGORA_FEATURES.templeOfHephaistos.position.z });
        const harbourBirdsPosition = scaleLocation({ x: PHALERON_POSITION.x, y: 10, z: PHALERON_POSITION.z });
        const kennelPosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x - 24, y: 1.2, z: AGORA_ANCHOR_SCENE.z + 18 });
        const catAlleyPosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x + 14, y: 1.2, z: AGORA_ANCHOR_SCENE.z + 6 });
        const cowPasturePosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x - 42, y: 1.5, z: AGORA_ANCHOR_SCENE.z - 26 });
        
        let enhancedLighting = true;
        const timeNames = [...KNOWN_PRESETS];
        const featureLineTimeFactors = {
            "Golden Dawn": 0.25,
            "Blue Hour": 0.85,
            "High Noon": 0.5,
            "Golden Dusk": 0.75,
            "Starlit Night": 0.0
        };
        let currentTimeOfDay = timeNames.indexOf(initialSkyPreset);
        if (currentTimeOfDay === -1) {
            currentTimeOfDay = 0;
        }
        if (typeof window !== 'undefined') {
            window.__AthensSkyPreset = timeNames[currentTimeOfDay];
        }
        const debugSkyCycleModes = ["High Noon", "Blue Hour", "Starlit Night"];
        const debugSkyLevels = [0, 0.4, 1];
        let debugSkyCycleIndex = debugSkyCycleModes.indexOf(timeNames[currentTimeOfDay] || '');
        if (debugSkyCycleIndex === -1) {
            debugSkyCycleIndex = 0;
        }
        let skipNightHotkeyOnce = false;

        // Declare texture and material variables globally
        let stoneTexture, marbleTexture, redTileTexture, groundTexture, pavedRoadTexture;
        let stoneMaterial, marbleMaterial, goldMaterial, redTileMaterial, groundMaterial, columnMaterial, waterMaterial, pavedRoadMaterial, cityWallMaterial;

        const buildingMaterialSet = loadBuildingTextures();
        if (typeof window !== 'undefined') {
            window.buildingMaterialSet = buildingMaterialSet;
        }
        cityWallMaterial = setCityWallMaterial(buildingMaterialSet?.cityWallMat);
        let groundMesh = null;
        let districtsLayer = null;
        let districtChangeUnsubscribe = null;
        let districtMiniMapIcons = [];
        let stopDistrictWatch = null;
        let currentDistricts = [];
        let districtFillsVisible = true;
        let districtOutlinesVisible = true;
        let districtDustBiasEnabled = true;
        let currentEnvironmentMode = null;
        let skyVisible = true;
        let desiredSkydomeOpacity = 0;
        let desiredSpaceNightAmount = 0;
        let desiredEnvironmentIntensity = 1.0;

        const updateSceneEnvironmentIntensity = () => {
            if (!scene) {
                return;
            }
            if (Number.isFinite(desiredEnvironmentIntensity)) {
                scene.environmentIntensity = desiredEnvironmentIntensity;
            }
        };
        let cityWallGroup = null;
        let cityGatehouseGroup = null;
        const cityGatehouseBodies = [];

        const applyEnvironmentMode = (mode = 'day') => {
            if (!renderer || !scene) {
                return;
            }
            const normalized = mode === 'night' ? 'night' : (mode === 'sunset' ? 'sunset' : 'day');
            if (currentEnvironmentMode === normalized) {
                return;
            }
            currentEnvironmentMode = normalized;
            if (!skyVisible) {
                scene.background = null;
                scene.environment = null;
                return;
            }
            const hasPhotoSky = Boolean(photoSkydome || window.__AthensSky__);
            const shouldPreserveBackground = hasPhotoSky && (
                normalized === 'sunset' || normalized === 'night' || normalized === 'day'
            );
            setEnvironment(renderer, scene, normalized, { preserveBackground: shouldPreserveBackground });
            updateSceneEnvironmentIntensity();
        };

        function setSkyVisibility(visible) {
            const nextVisible = Boolean(visible);
            if (skyVisible === nextVisible) {
                return;
            }

            skyVisible = nextVisible;

            const controller = photoSkydome || window.__AthensSky__;

            if (skyVisible) {
                if (controller?.mesh) {
                    controller.mesh.visible = true;
                }
                if (typeof controller?.setAmount === 'function') {
                    controller.setAmount(desiredSkydomeOpacity);
                }
                if (spaceNight) {
                    spaceNight.setAmount(desiredSpaceNightAmount);
                }
                if (sky) {
                    sky.visible = true;
                }
                if (starLayerInner) {
                    starLayerInner.visible = desiredSpaceNightAmount > 0;
                }
                if (starLayerOuter) {
                    starLayerOuter.visible = desiredSpaceNightAmount > 0;
                }
                if (milkyWayMesh) {
                    milkyWayMesh.visible = desiredSpaceNightAmount > 0;
                    if (milkyWayMesh.material && typeof milkyWayMesh.material.opacity === 'number' && desiredSpaceNightAmount <= 0) {
                        milkyWayMesh.material.opacity = 0;
                    }
                }
                starMaterials.forEach((mat) => {
                    if (mat && typeof mat.opacity === 'number' && desiredSpaceNightAmount <= 0) {
                        mat.opacity = 0;
                    }
                });
                applyEnvironmentMode(currentEnvironmentMode || 'day');
                updateSceneEnvironmentIntensity();
            } else {
                if (controller?.mesh) {
                    controller.mesh.visible = false;
                }
                if (typeof controller?.setAmount === 'function') {
                    controller.setAmount(0);
                }
                if (sky) {
                    sky.visible = false;
                }
                if (starLayerInner) {
                    starLayerInner.visible = false;
                }
                if (starLayerOuter) {
                    starLayerOuter.visible = false;
                }
                if (milkyWayMesh) {
                    milkyWayMesh.visible = false;
                    if (milkyWayMesh.material && typeof milkyWayMesh.material.opacity === 'number') {
                        milkyWayMesh.material.opacity = 0;
                    }
                }
                starMaterials.forEach((mat) => {
                    if (mat && typeof mat.opacity === 'number') {
                        mat.opacity = 0;
                    }
                });
                if (spaceNight) {
                    spaceNight.setAmount(0);
                }
                if (scene) {
                    scene.background = null;
                    scene.environment = null;
                }
            }
        }

        function toggleSkyVisibility() {
            setSkyVisibility(!skyVisible);
        }
        
        const baseMapBounds = { xMin: -80, xMax: 80, zMin: -80, zMax: 80 };
        const mapBounds = scaleBounds(baseMapBounds);
        const clearDistrictMiniMapIcons = () => {
            districtMiniMapIcons.forEach((icon) => {
                if (icon && icon.parentElement) {
                    icon.parentElement.removeChild(icon);
                }
            });
            districtMiniMapIcons = [];
        };
        function updateDistrictMiniMapIcons(districts = currentDistricts) {
            const container = document.getElementById('mini-map-container');
            if (!container) {
                return;
            }

            clearDistrictMiniMapIcons();

            if (!Array.isArray(districts) || districts.length === 0) {
                return;
            }

            const mapWidth = container.clientWidth || 200;
            const mapHeight = container.clientHeight || 200;
            const worldWidth = mapBounds.xMax - mapBounds.xMin;
            const worldDepth = mapBounds.zMax - mapBounds.zMin;

            if (worldWidth === 0 || worldDepth === 0) {
                return;
            }

            districts.forEach((district) => {
                if (!district || !district.centroid) {
                    return;
                }

                const { centroid, name, id } = district;
                const percentX = THREE.MathUtils.clamp((centroid.x - mapBounds.xMin) / worldWidth, 0, 1);
                const percentZ = THREE.MathUtils.clamp((centroid.z - mapBounds.zMin) / worldDepth, 0, 1);

                const icon = document.createElement('div');
                icon.className = 'map-icon map-icon-district';
                icon.textContent = (name || id || '?').charAt(0).toUpperCase();
                icon.title = name || id || 'District';
                icon.style.left = `${percentX * mapWidth}px`;
                icon.style.top = `${percentZ * mapHeight}px`;

                container.appendChild(icon);
                districtMiniMapIcons.push(icon);
            });
        }
        const getRandomWorldXZ = (padding = 0) => ({
            x: THREE.MathUtils.randFloat(mapBounds.xMin + padding, mapBounds.xMax - padding),
            z: THREE.MathUtils.randFloat(mapBounds.zMin + padding, mapBounds.zMax - padding)
        });
        const getRandomWorldVector3 = (y = 0, padding = 0) => {
            const { x, z } = getRandomWorldXZ(padding);
            return new THREE.Vector3(x, y, z);
        };
        const CHICKEN_WORLD_PADDING = scaleValue(10);
        const BARREL_WORLD_PADDING = scaleValue(20);
        const RUN_ALIGNMENT_AXIS = new THREE.Vector3(0, 1, 0);
        const RUN_ALIGNMENT_QUATERNION = new THREE.Quaternion();
        
        const infoData = {
            pnyx: {
                title: "üèõÔ∏è The Pnyx",
                text: "This is the Pnyx Hill. Here, all citizens would gather in the Assembly to debate and vote directly on the laws of Athens. This is a powerful example of **Direct Democracy**, where the people themselves, not representatives, make the rules. Remember, only adult male citizens could vote here. Women, slaves, and foreign-born residents (Metics) had no say at all."
            },
            bouleuterion: {
                title: "üèõÔ∏è The Bouleuterion",
                text: "This was the Council House, where 500 citizens, chosen by lottery for a one-year term, met to prepare the laws that would be voted on at the Pnyx. This shows the importance of **Citizen Participation** in day-to-day governance."
            },
            dikasteria: {
                title: "‚öñÔ∏è The Dikasteria",
                text: "These were the Law Courts of Athens. Juries of 201 to 501 citizens, also chosen by lottery, would hear trials and deliver verdicts. Having large juries of ordinary people ensured that justice was in the hands of the citizens, a key part of the **Rule of Law**."
            }
        };


        // --- INITIALIZATION ---
        async function init() {
            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Scene and Camera
            scene = new THREE.Scene();
            window.scene = scene;
            const farClip = 60000;
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, farClip);
            camera.far = Math.max(camera.far, 60000);
            camera.updateProjectionMatrix();
            window.camera = camera;

            ambientZoneManager = new AmbientZoneManager({ maxActive: 3, fadeTime: 0.75 });
            ambientZoneManager.setCamera(camera);
            flushPendingAmbientZones();
            
            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.physicallyCorrectLights = true;
            if ('SRGBColorSpace' in THREE) {
                renderer.outputColorSpace = THREE.SRGBColorSpace;
            } else if ('sRGBEncoding' in THREE) {
                renderer.outputEncoding = THREE.sRGBEncoding;
            }
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            initPerformanceStats();
            window.renderer = renderer;

            districtsLayer = createDistrictsLayer({ scene });
            if (typeof districtChangeUnsubscribe === 'function') {
                districtChangeUnsubscribe();
            }
            districtChangeUnsubscribe = onDistrictsChanged((districts) => {
                currentDistricts = districts;
                updateDistrictMiniMapIcons(districts);
                if (groundMesh?.userData?.refreshDistrictDustBiasTexture) {
                    groundMesh.userData.refreshDistrictDustBiasTexture();
                }
            });
            currentDistricts = setDistricts(createDistrictDefinitions());
            setDistrictFillsVisible(districtFillsVisible);
            setDistrictOutlinesVisible(districtOutlinesVisible);

            configureGround({
                getDustBiasAt: (x, z) => {
                    const district = getDistrictAt(x, z);
                    return district?.dustBias ?? 0;
                }
            });

            const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
            const textureLoader = new THREE.TextureLoader();

            if (!mountainRimMesh && HORIZON_ENABLE) {
                try {
                    mountainRimMesh = createMountainRim({
                        radius: 1600,
                        height: 120,
                        radialSegments: 192,
                        noise: 0.45,
                        color: 0x0e1b2b
                    });
                    if (mountainRimMesh) {
                        mountainRimMesh.visible = rimEnabled;
                        scene.add(mountainRimMesh);
                    }
                } catch (error) {
                    console.warn('[sky] Failed to initialize mountain rim mesh.', error);
                    mountainRimMesh = null;
                }
            }

            if (buildingMaterialSet?.marbleMat?.map) {
                buildingMaterialSet.marbleMat.map.anisotropy = Math.max(
                    buildingMaterialSet.marbleMat.map.anisotropy || 0,
                    maxAnisotropy
                );
                buildingMaterialSet.marbleMat.map.needsUpdate = true;
            }
            if (buildingMaterialSet?.roofMat?.map) {
                buildingMaterialSet.roofMat.map.anisotropy = Math.max(
                    buildingMaterialSet.roofMat.map.anisotropy || 0,
                    maxAnisotropy
                );
                buildingMaterialSet.roofMat.map.needsUpdate = true;
            }

            applyEnvironmentMode('day');
            window.setEnvironment = applyEnvironmentMode;
            window.setSkyVisible = setSkyVisibility;
            window.toggleSkyVisibility = toggleSkyVisibility;
            window.isSkyVisible = () => skyVisible;
            window.addEventListener('keydown', (event) => {
                if (event.key === '1') applyEnvironmentMode('day');
                if (event.key === '2') applyEnvironmentMode('sunset');
                if (event.key === '3') applyEnvironmentMode('night');
            });

            const initialPhotoSources = Array.isArray(initialSkyConfig?.sources) && initialSkyConfig.sources.length > 0
                ? initialSkyConfig.sources
                : highNoonPhotoSources;
            const initialPhotoYawDeg = typeof initialSkyConfig?.yawDeg === 'number' ? initialSkyConfig.yawDeg : 0;
            const initialPhotoKey = initialSkyConfig?.textureKey || (initialSkyPreset === 'High Noon' ? 'high-noon' : null);

            try {
                photoSkydome = await createPhotoSkydome({
                    scene,
                    renderer,
                    sources: initialPhotoSources,
                    radius: 5000,
                    initialYawDeg: initialPhotoYawDeg
                });

                if (photoSkydome?.mesh) {
                    photoSkydomeYawDeg = THREE.MathUtils.radToDeg(photoSkydome.mesh.rotation.y);
                }

                if (photoSkydome?.source) {
                    const { label, url, isFallback } = photoSkydome.source;
                    const description = label || url;
                    const suffix = isFallback ? ' (fallback)' : '';
                    console.info(`Photo skydome texture loaded: ${description}${suffix}`);
                }

                window.__AthensSky__ = photoSkydome;
                currentPhotoSkyKey = initialPhotoKey;
                __level = 0;

                if (!skyVisible && photoSkydome) {
                    if (photoSkydome.mesh) {
                        photoSkydome.mesh.visible = false;
                    }
                    if (typeof photoSkydome.setAmount === 'function') {
                        photoSkydome.setAmount(0);
                    }
                    scene.background = null;
                    scene.environment = null;
                }

                photoSkyTexturesByKey.forEach((sources, key) => {
                    if (!photoSkydome || key === currentPhotoSkyKey) {
                        return;
                    }
                    photoSkydome.prefetchSources(sources).catch((error) => {
                        console.debug(`Photo skydome prefetch skipped for ${key}:`, error);
                    });
                });
            } catch (error) {
                console.warn('Photo skydome initialization failed; using fallback blue sky.', error);
                photoSkydome = null;
                window.__AthensSky__ = null;
                currentPhotoSkyKey = null;
                scene.background = new THREE.Color(0x87c5eb);
                scene.environment = null;
                __level = 0;
            }

            spaceNight = initSpaceNight({
                scene,
                renderer,
                textureLoader,
                camera,
                requestDayEnvironment: ({ captureEnvironment = true, captureBackground = false } = {}) => {
                    const result = {};

                    if (captureEnvironment) {
                        if (photoSkydome && typeof photoSkydome.refreshEnvironment === 'function') {
                            try {
                                result.environment = photoSkydome.refreshEnvironment() ?? null;
                            } catch (error) {
                                console.warn('Photo skydome environment refresh failed.', error);
                                result.environment = scene.environment ?? null;
                            }
                        } else {
                            result.environment = scene.environment ?? null;
                        }
                    }

                    if (captureBackground) {
                        result.background = scene.background ?? null;
                    }

                    return result;
                }
            });

            if (!skyVisible && spaceNight) {
                spaceNight.setAmount(0);
                scene.background = null;
                scene.environment = null;
            }

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Reduced intensity
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Reduced intensity
            directionalLight.position.set(scaleValue(50), 80, scaleValue(50));
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3); // Reduced intensity
            scene.add(hemisphereLight);

            const groundSetupResult = await setupGround(scene, renderer);
            const groundCandidate = groundSetupResult?.root ?? groundSetupResult ?? null;

            if (groundCandidate?.userData?.refreshDistrictDustBiasTexture) {
                groundCandidate.userData.refreshDistrictDustBiasTexture();
            }
            if (groundCandidate?.userData?.setDistrictDustBiasEnabled) {
                groundCandidate.userData.setDistrictDustBiasEnabled(districtDustBiasEnabled);
            }

            groundMesh = groundCandidate ?? null;
            if (groundMesh && !groundMesh.isObject3D) {
                console.warn('[ground] setupGround returned a non-Object3D result; ground will not be added to the scene automatically.', groundCandidate);
            }

            const resolvedGroundMaterial = findFirstMaterial(groundCandidate);
            if (resolvedGroundMaterial) {
                groundMaterial = resolvedGroundMaterial;
                groundTexture = groundMaterial.map || null;
            } else {
                groundMaterial = null;
                groundTexture = null;
            }

            try {
                await buildScatterDemo();
            } catch (error) {
                console.warn('[roads] Unable to create hybrid road demo segment.', error);
            }

            scene.fog = null;

            // Sky, stars, and post-processing
            initSkyAndStars();

            const devicePixelRatio = window.devicePixelRatio || 1;
            let horizonSegments = 128;
            if (renderer?.capabilities?.isWebGL2 === false) {
                horizonSegments = 96;
            }
            if (devicePixelRatio < 1.25) {
                horizonSegments = Math.min(horizonSegments, 96);
            }
            if (devicePixelRatio < 1.0) {
                horizonSegments = Math.min(horizonSegments, 64);
            }

            const HORIZON_RADIUS = 900;
            const HORIZON_HEIGHT = 70;
            window.getMountainRim = () => null;
            if (HORIZON_ENABLE) {
                const mountainRim = createMountainRim({
                    radius: HORIZON_RADIUS,
                    height: HORIZON_HEIGHT,
                    radialSegments: horizonSegments,
                    noise: 0.38,
                    seed: 2025,
                    color: 0x0e1b2b
                });
                scene.add(mountainRim);
                window.getMountainRim = () => mountainRim;
            }

            setupPostFX();

            // Initialize textures and materials now that renderer exists
            stoneTexture = generateTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = '#808080';
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 5000; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const radius = Math.random() * 1.5;
                    const brightness = Math.random() * 0.2 - 0.1;
                    const gray = 128 + brightness * 100;
                    ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${Math.random() * 0.5 + 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            if (buildingMaterialSet?.marbleMat?.map) {
                marbleTexture = buildingMaterialSet.marbleMat.map;
            } else {
                marbleTexture = generateTexture(512, 512, (ctx, w, h) => {
                    ctx.fillStyle = '#F0F0F0';
                    ctx.fillRect(0, 0, w, h);
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.strokeStyle = `rgba(128, 128, 128, 0.3)`;
                    for(let i=0; i<10; i++) {
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * w, Math.random() * h);
                        ctx.bezierCurveTo(
                            Math.random() * w,
                            Math.random() * h,
                            Math.random() * w,
                            Math.random() * h,
                            Math.random() * w,
                            Math.random() * h
                        );
                        ctx.stroke();
                    }
                });
            }

            if (buildingMaterialSet?.roofMat?.map) {
                redTileTexture = buildingMaterialSet.roofMat.map;
            } else {
                redTileTexture = generateTexture(256, 256, (ctx, w, h) => {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 2;
                    for(let i = 0; i < w; i += 32) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, h);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(w, i);
                        ctx.stroke();
                    }
                });
            }
            pavedRoadTexture = generateTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = '#A9A9A9';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                for(let i=0; i < 1000; i++){
                    let x = Math.random() * w;
                    let y = Math.random() * h;
                    let size = Math.random() * 20 + 5;
                    ctx.strokeRect(x,y,size,size);
                }
            });

            if (stoneTexture) {
                stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
            }
            if (marbleTexture) {
                marbleTexture.wrapS = marbleTexture.wrapT = THREE.RepeatWrapping;
            }
            if (redTileTexture) {
                redTileTexture.wrapS = redTileTexture.wrapT = THREE.RepeatWrapping;
            }
            if (pavedRoadTexture) {
                pavedRoadTexture.wrapS = pavedRoadTexture.wrapT = THREE.RepeatWrapping;
            }

            stoneMaterial = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.85, metalness: 0.05 });

            marbleMaterial = buildingMaterialSet?.marbleMat?.clone
                ? buildingMaterialSet.marbleMat.clone()
                : new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.75, metalness: 0.0 });
            if (!marbleMaterial.map && marbleTexture) {
                marbleMaterial.map = marbleTexture;
                marbleMaterial.needsUpdate = true;
            }

            goldMaterial = createEnhancedMaterial(0xFFD700, 0.2, 0.9);

            redTileMaterial = buildingMaterialSet?.roofMat?.clone
                ? buildingMaterialSet.roofMat.clone()
                : new THREE.MeshStandardMaterial({ color: 0x8b3a2f, roughness: 0.9, metalness: 0.0 });
            if (!redTileMaterial.map && redTileTexture) {
                redTileMaterial.map = redTileTexture;
                redTileMaterial.needsUpdate = true;
            }

            columnMaterial = buildingMaterialSet?.marbleMat?.clone
                ? buildingMaterialSet.marbleMat.clone()
                : marbleMaterial.clone();
            if (!columnMaterial.map && marbleTexture) {
                columnMaterial.map = marbleTexture;
                columnMaterial.needsUpdate = true;
            }

            waterMaterial = createEnhancedMaterial(0x5f9ea0, 0.2, 0.1);
            waterMaterial.transparent = true;
            waterMaterial.opacity = 0.7;
            pavedRoadMaterial = new THREE.MeshStandardMaterial({ map: pavedRoadTexture, roughness: 0.8, metalness: 0.1 });

            if (buildingMaterialSet?.marbleMat) {
                MAT.marble.copy(buildingMaterialSet.marbleMat);
                MAT.marble.needsUpdate = true;
            }
            if (buildingMaterialSet?.roofMat) {
                MAT.roof.copy(buildingMaterialSet.roofMat);
                MAT.roof.needsUpdate = true;
            }


            // Build Scene
            buildWorld();
            createInteractables();
            initDistrictHUD();
            if (typeof stopDistrictWatch === 'function') {
                stopDistrictWatch();
            }
            stopDistrictWatch = watchPlayerPosition(() => {
                if (player?.body) {
                    return [player.body.position.x, player.body.position.z];
                }
                return [null, null];
            });
            createInteractiveObjects();
            createMapIcons();
            updateDistrictMiniMapIcons(currentDistricts);
            // Load the temple model (GLB)
            loadGreekTemple();

            try {
                const { buildFromGeoJSON } = await import('./src/buildings-from-geojson.js');
                const projectorInstance = window?.AthensGeo?.projector;
                const projector = projectorInstance && typeof projectorInstance.project === 'function'
                    ? (lon, lat) => {
                        const { x, y } = projectorInstance.project({ lat, lon });
                        return new THREE.Vector3(scaleValue(x), 0, scaleValue(y));
                    }
                    : null;
                await buildFromGeoJSON({
                    scene,
                    geoJsonUrl: './data/athens_places.geojson',
                    projector
                });
            } catch (error) {
                console.error('Failed to build procedural monuments:', error);
            }

            await setupLandmarks();



            // Event Listeners
            addEventListeners();
            
            // Set initial environment state and start animation
            updateEnvironment();
            animate();
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps-value').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // --- TEXTURES AND MATERIALS ---
        const createEnhancedMaterial = (color, roughness = 0.8, metalness = 0.1) => {
            return new THREE.MeshStandardMaterial({ 
                color, 
                roughness, 
                metalness,
                envMapIntensity: 0.5
            });
        };
        
        function generateTexture(width, height, drawFunction) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            drawFunction(context, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        // --- WORLD BUILDING ---
        function buildWorld() {
            // Ground
            if (groundMesh?.isObject3D && !scene.children.includes(groundMesh)) {
                scene.add(groundMesh);
            }
            const groundPhysMat = new CANNON.Material("groundMaterial");
            const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMat });
            groundBody.addShape(new CANNON.Plane());
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(groundBody);
            
            if(player && player.body) {
                const playerPhysMat = new CANNON.Material("playerMaterial");
                player.body.material = playerPhysMat;
                const groundPlayerContactMaterial = new CANNON.ContactMaterial(
                    groundPhysMat,
                    playerPhysMat,
                    { friction: 0.1, restitution: 0.3 }
                );
                world.addContactMaterial(groundPlayerContactMaterial);
            }


            // Structures
            // createParthenon();
            createAgoraComplex();
            createAreopagusHill();
            createKerameikosDistrict();
            createLongWallsCorridors();
            createLongWallPosts();
            createPhaleronHarbor();
            createHouses();
            createTrees();
            createCountrysideAmbienceAnchor();
            createFountain();
            createCityFortifications();
            createMarketStalls();
            createDemocracyMonuments();
            createPavedRoads();
            window.athensWorldBuilt = true;
            window.dispatchEvent(new Event('athens-world-built'));
        }

        function createEnhancedColumn(height = 8, material = columnMaterial) {
            const group = new THREE.Group();
            const baseHeight = 0.5;
            const capitalHeight = 0.5;

            const columnGeometry = new THREE.CylinderGeometry(0.8 * CITY_SCALE, 1 * CITY_SCALE, height, 16);
            const column = new THREE.Mesh(columnGeometry, material);
            column.castShadow = true;
            if (column.material.map) {
                column.material.map.repeat.set(CITY_SCALE, 2);
            }
            column.position.y = baseHeight + height / 2;
            group.add(column);

            const capitalGeometry = new THREE.CylinderGeometry(1.2 * CITY_SCALE, 0.9 * CITY_SCALE, capitalHeight, 16);
            const capital = new THREE.Mesh(capitalGeometry, goldMaterial);
            capital.position.y = baseHeight + height + capitalHeight / 2;
            capital.castShadow = true;
            group.add(capital);

            const baseGeometry = new THREE.CylinderGeometry(1.1 * CITY_SCALE, 1.3 * CITY_SCALE, baseHeight, 16);
            const base = new THREE.Mesh(baseGeometry, material);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            group.add(base);

            return group;
        }

        function createEnhancedBuilding(x, z, width, depth, height, material = stoneMaterial, options = {}) {
            const { includeDetails = true } = options;
            const group = new THREE.Group();
            const scaledWidth = scaleValue(width);
            const scaledDepth = scaleValue(depth);
            const scaledX = scaleValue(x);
            const scaledZ = scaleValue(z);
            const buildingGeometry = new THREE.BoxGeometry(scaledWidth, height, scaledDepth);
            const building = new THREE.Mesh(buildingGeometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            if (building.material.map) {
                building.material.map.repeat.set(scaledWidth / 4, height / 4);
            }
            group.add(building);

            if (includeDetails) {
                // Add doors and windows
                const detailMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
                if (width > depth) { // Horizontal building
                    const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.5), detailMaterial);
                    door.position.set(0, -height/2 + 1.25, scaledDepth/2 + 0.01);
                    group.add(door);
                } else { // Vertical building
                    const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.5), detailMaterial);
                    door.position.set(scaledWidth/2 + 0.01, -height/2 + 1.25, 0);
                    door.rotation.y = Math.PI / 2;
                    group.add(door);
                }

                if (Math.random() > 0.5) {
                    const decorGeometry = new THREE.BoxGeometry(scaledWidth * 1.1, 0.5, scaledDepth * 1.1);
                    const decoration = new THREE.Mesh(decorGeometry, goldMaterial);
                    decoration.position.y = height / 2 + 0.25;
                    decoration.castShadow = true;
                    group.add(decoration);
                }
            }
            group.position.set(scaledX, height/2, scaledZ);
            return group;
        }
        
        function createParthenon() {
            const acropolis = new THREE.Group();

            const sourceGroundMaterial = (groundMaterial && typeof groundMaterial.clone === 'function')
                ? groundMaterial
                : new THREE.MeshStandardMaterial({ color: 0xBCA67C, roughness: 0.9 });
            const hillMaterialBase = sourceGroundMaterial.clone();
            const hillLayerMaterials = [];

            const configureHillBaseTexture = () => {
                if (!groundMaterial?.map || !groundMaterial.map.image) {
                    return null;
                }

                const texture = groundMaterial.map.clone();
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(6 * CITY_SCALE, 3 * CITY_SCALE);

                const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy?.();
                if (typeof maxAnisotropy === 'number' && maxAnisotropy > 0) {
                    texture.anisotropy = Math.max(texture.anisotropy || 0, maxAnisotropy);
                }

                texture.needsUpdate = true;
                hillMaterialBase.map = texture;
                hillMaterialBase.needsUpdate = true;
                return texture;
            };

            const applyHillTextureToLayers = (texture) => {
                if (!texture) {
                    return;
                }

                const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy?.();

                hillLayerMaterials.forEach(({ material, repeatX, repeatY }) => {
                    const layerTexture = texture.clone();
                    layerTexture.wrapS = layerTexture.wrapT = THREE.RepeatWrapping;
                    layerTexture.repeat.set(repeatX, repeatY);

                    if (typeof maxAnisotropy === 'number' && maxAnisotropy > 0) {
                        layerTexture.anisotropy = Math.max(layerTexture.anisotropy || 0, maxAnisotropy);
                    } else if (texture.anisotropy) {
                        layerTexture.anisotropy = texture.anisotropy;
                    }

                    layerTexture.needsUpdate = true;
                    material.map = layerTexture;
                    material.needsUpdate = true;
                });
            };

            hillMaterialBase.color = new THREE.Color(0xBCA67C);
            hillMaterialBase.roughness = Math.min(0.98, hillMaterialBase.roughness + 0.03);

            const hillLayers = [
                { top: scaleValue(70), bottom: scaleValue(85), height: 3 },
                { top: scaleValue(55), bottom: scaleValue(70), height: 3 },
                { top: scaleValue(42), bottom: scaleValue(55), height: 2.5 },
                { top: scaleValue(34), bottom: scaleValue(42), height: 2 }
            ];

            let plateauHeight = 0;
            hillLayers.forEach((layer, index) => {
                const layerMaterial = hillMaterialBase.clone();
                hillLayerMaterials.push({
                    material: layerMaterial,
                    repeatX: (6 + index) * CITY_SCALE,
                    repeatY: 3 + index * 0.5
                });
                const terrace = new THREE.Mesh(
                    new THREE.CylinderGeometry(layer.top, layer.bottom, layer.height, 64, 1, false),
                    layerMaterial
                );
                terrace.position.y = plateauHeight + layer.height / 2;
                terrace.castShadow = true;
                terrace.receiveShadow = true;
                acropolis.add(terrace);
                plateauHeight += layer.height;
            });

            let hillBaseTexture = configureHillBaseTexture();
            if (hillBaseTexture) {
                applyHillTextureToLayers(hillBaseTexture);
            } else if (groundMaterial?.map) {
                const maxWaitFrames = 240;
                let waitCount = 0;
                const schedule = typeof requestAnimationFrame === 'function'
                    ? requestAnimationFrame
                    : (fn) => setTimeout(fn, 16);

                const waitForGroundTexture = () => {
                    const texture = configureHillBaseTexture();
                    if (texture) {
                        hillBaseTexture = texture;
                        applyHillTextureToLayers(texture);
                        return;
                    }

                    waitCount += 1;
                    if (waitCount >= maxWaitFrames) {
                        console.warn('Parthenon hill texture was unavailable; proceeding without ground detail.');
                        return;
                    }

                    schedule(waitForGroundTexture);
                };

                schedule(waitForGroundTexture);
            }

            const rockMaterial = stoneMaterial.clone();
            rockMaterial.color = new THREE.Color(0x9f8f78);
            [
                { position: scaledVector3(-26, 1.8, 28), scale: 1.3 },
                { position: scaledVector3(22, 2.6, 24), scale: 1.1 },
                { position: scaledVector3(-18, 4.2, -8), scale: 1.0 },
                { position: scaledVector3(16, 3.6, -14), scale: 1.2 }
            ].forEach(detail => {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(3 * detail.scale * CITY_SCALE, 0), rockMaterial);
                rock.position.copy(detail.position);
                rock.scale.setScalar(detail.scale);
                rock.castShadow = true;
                rock.receiveShadow = true;
                acropolis.add(rock);
            });

            const pathMaterial = pavedRoadMaterial.clone();
            if (pathMaterial.map) {
                pathMaterial.map = pathMaterial.map.clone();
                pathMaterial.map.wrapS = pathMaterial.map.wrapT = THREE.RepeatWrapping;
                pathMaterial.map.repeat.set(2 * CITY_SCALE, 12 * CITY_SCALE);
                pathMaterial.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                pathMaterial.map.needsUpdate = true;
            }
            pathMaterial.color = new THREE.Color(0xD2C3A4);

            const rampDepthBase = 60;
            const rampDepth = scaleValue(rampDepthBase);
            const rampAngle = Math.asin(Math.min(1, plateauHeight / rampDepth));
            const rampCenterZBase = -7.5 + rampDepthBase / 2;
            const rampCenterZ = scaleValue(rampCenterZBase);
            const rampHeight = plateauHeight / 2;

            const ramp = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(8), 0.4, rampDepth), pathMaterial);
            ramp.position.set(scaleValue(0), rampHeight, rampCenterZ);
            ramp.rotation.x = -rampAngle;
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            acropolis.add(ramp);

            const rampWallsMaterial = stoneMaterial.clone();
            rampWallsMaterial.color = new THREE.Color(0xE0D0B8);
            const rampWallGeometry = new THREE.BoxGeometry(scaleValue(0.6), 1.2, rampDepth);
            [-1, 1].forEach(side => {
                const wall = new THREE.Mesh(rampWallGeometry, rampWallsMaterial);
                wall.position.set(scaleValue(side * 4.4), rampHeight + 0.6, rampCenterZ);
                wall.rotation.x = -rampAngle;
                wall.castShadow = true;
                wall.receiveShadow = true;
                acropolis.add(wall);
            });

            const lowerPlaza = new THREE.Mesh(new THREE.CylinderGeometry(scaleValue(15), scaleValue(19), 0.5, 48), pathMaterial);
            lowerPlaza.position.set(scaleValue(0), 0.25, scaleValue(rampCenterZBase + rampDepthBase / 2 + 4));
            lowerPlaza.castShadow = true;
            lowerPlaza.receiveShadow = true;
            acropolis.add(lowerPlaza);

            const upperLanding = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(16), 0.4, scaleValue(10)), pathMaterial);
            upperLanding.position.set(scaleValue(0), plateauHeight - 0.2, scaleValue(-12));
            upperLanding.castShadow = true;
            upperLanding.receiveShadow = true;
            acropolis.add(upperLanding);

            const parthenon = new THREE.Group();
            const steps = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const stepGeometry = new THREE.BoxGeometry(scaleValue(35 - i), 0.5, scaleValue(18 - i));
                const step = new THREE.Mesh(stepGeometry, marbleMaterial);
                if(step.material.map) {
                    step.material.map.repeat.set(8 * CITY_SCALE, 1 * CITY_SCALE);
                }
                step.position.y = i * 0.5;
                step.castShadow = true;
                step.receiveShadow = true;
                steps.add(step);
            }
            parthenon.add(steps);
            const parthenonBase = createEnhancedBuilding(0, 0, 30, 15, 4, marbleMaterial);
            if(parthenonBase.children[0].material.map) {
                parthenonBase.children[0].material.map.repeat.set(8 * CITY_SCALE, 2 * CITY_SCALE);
            }
            parthenonBase.position.y = 3.5;
            parthenon.add(parthenonBase);
            for (let i = 0; i < 8; i++) {
                const frontColumn = createEnhancedColumn(12);
                setScaledPosition(frontColumn, -13 + i * 4, -0.5, -7.5);
                parthenon.add(frontColumn);

                const backColumn = createEnhancedColumn(12);
                setScaledPosition(backColumn, -13 + i * 4, -0.5, 7.5);
                parthenon.add(backColumn);
            }
            for (let i = 0; i < 4; i++) {
                const leftColumn = createEnhancedColumn(12);
                setScaledPosition(leftColumn, -15, -0.5, -5.5 + i * 3.5);
                parthenon.add(leftColumn);

                const rightColumn = createEnhancedColumn(12);
                setScaledPosition(rightColumn, 15, -0.5, -5.5 + i * 3.5);
                parthenon.add(rightColumn);
            }
            const roofGroup = new THREE.Group();
            const roofLength = scaleValue(32);
            const roofDepth = scaleValue(18);
            const roofHeight = 4.5;
            const halfLength = roofLength / 2;
            const halfDepth = roofDepth / 2;
            const pedimentDepth = scaleValue(0.8);
            const slopeRun = Math.sqrt(halfDepth * halfDepth + roofHeight * roofHeight);

            const roofTileTexture = redTileMaterial.map.clone();
            roofTileTexture.wrapS = roofTileTexture.wrapT = THREE.RepeatWrapping;
            roofTileTexture.repeat.set(roofLength / 4, slopeRun / 2);
            roofTileTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            roofTileTexture.needsUpdate = true;

            const roofTileMaterial = redTileMaterial.clone();
            roofTileMaterial.map = roofTileTexture;
            roofTileMaterial.roughness = Math.max(0.45, roofTileMaterial.roughness - 0.15);
            roofTileMaterial.metalness = 0.05;

            const createSlopeGeometry = (sign = 1) => {
                const geometry = new THREE.BufferGeometry();
                const positions = sign > 0
                    ? new Float32Array([
                        -halfLength, 0, halfDepth,
                         halfLength, 0, halfDepth,
                         halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                        -halfLength, roofHeight, 0,
                        -halfLength, 0, halfDepth
                    ])
                    : new Float32Array([
                        -halfLength, 0, -halfDepth,
                        -halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                         halfLength, 0, -halfDepth,
                        -halfLength, 0, -halfDepth
                    ]);
                const uvs = sign > 0
                    ? new Float32Array([
                        0, 0,
                        1, 0,
                        1, 1,
                        1, 1,
                        0, 1,
                        0, 0
                    ])
                    : new Float32Array([
                        0, 0,
                        0, 1,
                        1, 1,
                        1, 1,
                        1, 0,
                        0, 0
                    ]);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.computeVertexNormals();
                return geometry;
            };

            const southSlope = new THREE.Mesh(createSlopeGeometry(1), roofTileMaterial);
            southSlope.castShadow = true;
            southSlope.receiveShadow = true;
            roofGroup.add(southSlope);

            const northSlopeMaterial = roofTileMaterial.clone();
            northSlopeMaterial.map = roofTileTexture.clone();
            northSlopeMaterial.map.wrapS = northSlopeMaterial.map.wrapT = THREE.RepeatWrapping;
            northSlopeMaterial.map.repeat.copy(roofTileTexture.repeat);
            northSlopeMaterial.map.anisotropy = roofTileTexture.anisotropy;
            northSlopeMaterial.map.needsUpdate = true;
            const northSlope = new THREE.Mesh(createSlopeGeometry(-1), northSlopeMaterial);
            northSlope.castShadow = true;
            northSlope.receiveShadow = true;
            roofGroup.add(northSlope);

            const roofDeckTexture = marbleMaterial.map.clone();
            roofDeckTexture.wrapS = roofDeckTexture.wrapT = THREE.RepeatWrapping;
            roofDeckTexture.repeat.set(roofLength / 6, roofDepth / 4);
            roofDeckTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            roofDeckTexture.needsUpdate = true;
            const roofDeckMaterial = marbleMaterial.clone();
            roofDeckMaterial.map = roofDeckTexture;
            const roofDeck = new THREE.Mesh(new THREE.BoxGeometry(roofLength, 0.5, roofDepth), roofDeckMaterial);
            roofDeck.position.y = -0.25;
            roofDeck.castShadow = true;
            roofDeck.receiveShadow = true;
            roofGroup.add(roofDeck);

            const pedimentTexture = marbleMaterial.map.clone();
            pedimentTexture.wrapS = pedimentTexture.wrapT = THREE.RepeatWrapping;
            pedimentTexture.repeat.set(roofLength / 6, roofHeight / 2);
            pedimentTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            pedimentTexture.needsUpdate = true;
            const pedimentMaterial = marbleMaterial.clone();
            pedimentMaterial.map = pedimentTexture;
            pedimentMaterial.roughness = Math.max(0.35, pedimentMaterial.roughness - 0.05);

            const buildPedimentGeometry = () => {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const uvs = [];
                const addTriangle = (a, b, c, uva, uvb, uvc) => {
                    positions.push(a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2]);
                    uvs.push(uva[0], uva[1], uvb[0], uvb[1], uvc[0], uvc[1]);
                };

                const f0 = [-halfLength, 0, pedimentDepth / 2];
                const f1 = [halfLength, 0, pedimentDepth / 2];
                const f2 = [0, roofHeight, pedimentDepth / 2];
                const b0 = [-halfLength, 0, -pedimentDepth / 2];
                const b1 = [halfLength, 0, -pedimentDepth / 2];
                const b2 = [0, roofHeight, -pedimentDepth / 2];

                addTriangle(f0, f1, f2, [0, 0], [1, 0], [0.5, 1]);
                addTriangle(b0, b2, b1, [0, 0], [0.5, 1], [1, 0]);
                addTriangle(f0, f1, b1, [0, 0], [1, 0], [1, 1]);
                addTriangle(f0, b1, b0, [0, 0], [1, 1], [0, 1]);
                addTriangle(f0, b2, b0, [0, 0], [1, 1], [1, 0]);
                addTriangle(f0, f2, b2, [0, 0], [1, 0], [1, 1]);
                addTriangle(f1, b1, b2, [0, 0], [0, 1], [1, 1]);
                addTriangle(f1, b2, f2, [0, 0], [1, 1], [1, 0]);

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uvs), 2));
                geometry.computeVertexNormals();
                return geometry;
            };

            const pedimentGeometry = buildPedimentGeometry();
            const reliefMaterial = createEnhancedMaterial(0xD5C7A8, 0.6, 0.1);
            reliefMaterial.side = THREE.FrontSide;

            const createPediment = (isFront = true) => {
                const group = new THREE.Group();
                const pedimentMesh = new THREE.Mesh(pedimentGeometry, pedimentMaterial);
                pedimentMesh.castShadow = true;
                pedimentMesh.receiveShadow = true;
                group.add(pedimentMesh);

                const reliefInset = scaleValue(2.5);
                const reliefShape = new THREE.Shape();
                reliefShape.moveTo(-halfLength + reliefInset, 0.6);
                reliefShape.lineTo(halfLength - reliefInset, 0.6);
                reliefShape.lineTo(0, roofHeight - 0.8);
                reliefShape.closePath();
                const reliefGeometry = new THREE.ShapeGeometry(reliefShape);
                const relief = new THREE.Mesh(reliefGeometry, reliefMaterial);
                relief.position.z = pedimentDepth / 2 + 0.02;
                relief.castShadow = true;
                group.add(relief);

                if (!isFront) {
                    group.rotation.y = Math.PI;
                }
                group.position.z = isFront ? halfDepth - pedimentDepth / 2 : -halfDepth + pedimentDepth / 2;
                return group;
            };

            const frontPediment = createPediment(true);
            const backPediment = createPediment(false);
            roofGroup.add(frontPediment);
            roofGroup.add(backPediment);

            const ridgeMaterial = pedimentMaterial.clone();
            ridgeMaterial.map = pedimentTexture.clone();
            ridgeMaterial.map.wrapS = ridgeMaterial.map.wrapT = THREE.RepeatWrapping;
            ridgeMaterial.map.repeat.set(roofLength / 6, 1);
            ridgeMaterial.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
            ridgeMaterial.map.needsUpdate = true;
            const ridge = new THREE.Mesh(new THREE.BoxGeometry(roofLength + scaleValue(0.2), 0.3, scaleValue(0.6)), ridgeMaterial);
            ridge.position.y = roofHeight - 0.1;
            ridge.castShadow = true;
            ridge.receiveShadow = true;
            roofGroup.add(ridge);

            roofGroup.position.y = 12.55;
            parthenon.add(roofGroup);
            const athenaGeometry = new THREE.CylinderGeometry(0.5 * CITY_SCALE, 0.8 * CITY_SCALE, 8);
            const athena = new THREE.Mesh(athenaGeometry, goldMaterial);
            athena.position.set(0, 10, 0);
            athena.castShadow = true;
            parthenon.add(athena);

            parthenon.position.y = plateauHeight;
            acropolis.add(parthenon);

          setScaledPosition(acropolis, 120, 0, -90);
            scene.add(acropolis);
        }
        
        function createPedimentMesh(width, height, depth, material) {
            const shape = new THREE.Shape();
            shape.moveTo(-width / 2, 0);
            shape.lineTo(0, height);
            shape.lineTo(width / 2, 0);
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled: false });
            geometry.translate(0, 0, -depth / 2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createTempleOfHephaistosStructure() {
            const group = new THREE.Group();
            const stylobateHeight = 1.2;
            const stylobateMaterial = marbleMaterial.clone();
            stylobateMaterial.roughness = Math.max(0.45, stylobateMaterial.roughness - 0.05);
            const stylobate = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(28), stylobateHeight, scaleValue(13)), stylobateMaterial);
            stylobate.position.y = stylobateHeight / 2;
            stylobate.castShadow = true;
            stylobate.receiveShadow = true;
            group.add(stylobate);

            const cellaHeight = 6.2;
            const cellaMaterial = marbleMaterial.clone();
            cellaMaterial.color = cellaMaterial.color.clone().offsetHSL(-0.02, -0.02, 0.03);
            const cella = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(18), cellaHeight, scaleValue(7)), cellaMaterial);
            cella.position.y = stylobateHeight + cellaHeight / 2;
            cella.castShadow = true;
            cella.receiveShadow = true;
            group.add(cella);

            const columnHeight = 6.5;
            const columnsPerLongSide = 13;
            const columnsPerShortSide = 6;
            const halfLength = scaleValue(28) / 2;
            const halfWidth = scaleValue(13) / 2;
            const marginX = scaleValue(2.4);
            const marginZ = scaleValue(1.8);
            const spacingLong = (2 * (halfLength - marginX)) / (columnsPerLongSide - 1);
            const spacingShort = (2 * (halfWidth - marginZ)) / (columnsPerShortSide - 1);

            for (let i = 0; i < columnsPerLongSide; i++) {
                const xPos = -halfLength + marginX + i * spacingLong;
                const northColumn = createEnhancedColumn(columnHeight);
                northColumn.position.set(xPos, stylobateHeight, halfWidth - marginZ);
                group.add(northColumn);

                const southColumn = createEnhancedColumn(columnHeight);
                southColumn.position.set(xPos, stylobateHeight, -halfWidth + marginZ);
                group.add(southColumn);
            }

            for (let i = 1; i < columnsPerShortSide - 1; i++) {
                const zPos = -halfWidth + marginZ + i * spacingShort;
                const westColumn = createEnhancedColumn(columnHeight);
                westColumn.position.set(-halfLength + marginX, stylobateHeight, zPos);
                group.add(westColumn);

                const eastColumn = createEnhancedColumn(columnHeight);
                eastColumn.position.set(halfLength - marginX, stylobateHeight, zPos);
                group.add(eastColumn);
            }

            const roofHeight = 1.6;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(12 * CITY_SCALE, 4 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(26), roofHeight, scaleValue(11)), roofMaterial);
            roof.position.y = stylobateHeight + columnHeight + roofHeight / 2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            const pedimentMaterial = marbleMaterial.clone();
            pedimentMaterial.roughness = Math.max(0.4, pedimentMaterial.roughness - 0.05);
            const pedimentDepth = scaleValue(1.4);
            const pedimentHeight = 2.4;
            const pedimentWidth = scaleValue(11);

            const frontPediment = createPedimentMesh(pedimentWidth, pedimentHeight, pedimentDepth, pedimentMaterial);
            frontPediment.position.set(0, roof.position.y + roofHeight / 2 - 0.2, halfWidth - pedimentDepth / 2);
            group.add(frontPediment);

            const backPediment = createPedimentMesh(pedimentWidth, pedimentHeight, pedimentDepth, pedimentMaterial);
            backPediment.position.set(0, roof.position.y + roofHeight / 2 - 0.2, -halfWidth + pedimentDepth / 2);
            backPediment.rotation.y = Math.PI;
            group.add(backPediment);

            const statueMaterial = goldMaterial.clone();
            statueMaterial.emissive = new THREE.Color(0x6f5b2e);
            const statue = new THREE.Mesh(new THREE.CylinderGeometry(0.22 * CITY_SCALE, 0.3 * CITY_SCALE, 2, 12), statueMaterial);
            statue.position.set(0, stylobateHeight + 1, halfWidth + 0.5 * CITY_SCALE);
            statue.castShadow = true;
            group.add(statue);

            return group;
        }

        function createStoaOfAttalosStructure() {
            const group = new THREE.Group();
            const baseHeight = 0.8;
            const length = 62;
            const depth = 18;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(0, -0.05, 0.05);
            const base = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(length), baseHeight, scaleValue(depth)), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const walkwayMaterial = pavedRoadMaterial.clone();
            const walkway = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(length * 1.05), scaleValue(depth * 0.6)), walkwayMaterial);
            walkway.rotation.x = -Math.PI / 2;
            walkway.position.set(0, 0.05, scaleValue(depth / 2));
            walkway.receiveShadow = true;
            group.add(walkway);

            const columnsLower = 14;
            const halfLength = scaleValue(length) / 2;
            const frontOffset = scaleValue(depth / 2 - 1.8);
            const innerOffset = scaleValue(depth / 2 - 5);
            const margin = scaleValue(2);
            const spacing = (2 * (halfLength - margin)) / (columnsLower - 1);

            for (let i = 0; i < columnsLower; i++) {
                const xPos = -halfLength + margin + i * spacing;
                const frontColumn = createEnhancedColumn(7.2);
                frontColumn.position.set(xPos, baseHeight, frontOffset);
                group.add(frontColumn);

                const innerColumn = createEnhancedColumn(6.8);
                innerColumn.position.set(xPos, baseHeight, innerOffset);
                group.add(innerColumn);
            }

            const upperLevelHeight = 4.2;
            const upperOffset = scaleValue(depth / 2 - 4.2);
            for (let i = 0; i < columnsLower; i++) {
                const xPos = -halfLength + margin + i * spacing;
                const upperColumn = createEnhancedColumn(upperLevelHeight);
                upperColumn.scale.setScalar(0.7);
                upperColumn.position.set(xPos, baseHeight + 7.4, upperOffset);
                group.add(upperColumn);
            }

            const roofHeight = 1.4;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(20 * CITY_SCALE, 6 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(length + 2), roofHeight, scaleValue(depth + 2)), roofMaterial);
            roof.position.y = baseHeight + 7.2 + upperLevelHeight + roofHeight / 2 + 0.6;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            return group;
        }

        function createTholosStructure() {
            const group = new THREE.Group();
            const podiumHeight = 0.6;
            const podiumRadius = scaleValue(8);
            const podium = new THREE.Mesh(new THREE.CylinderGeometry(podiumRadius, podiumRadius, podiumHeight, 32), marbleMaterial.clone());
            podium.position.y = podiumHeight / 2;
            podium.castShadow = true;
            podium.receiveShadow = true;
            group.add(podium);

            const columnCount = 12;
            const columnHeight = 5.2;
            const radius = scaleValue(6.2);
            for (let i = 0; i < columnCount; i++) {
                const angle = (i / columnCount) * Math.PI * 2;
                const column = createEnhancedColumn(columnHeight);
                column.position.set(Math.cos(angle) * radius, podiumHeight, Math.sin(angle) * radius);
                group.add(column);
            }

            const drum = new THREE.Mesh(new THREE.CylinderGeometry(scaleValue(4), scaleValue(4), 3, 24), marbleMaterial.clone());
            drum.position.y = podiumHeight + columnHeight / 2;
            drum.castShadow = true;
            drum.receiveShadow = true;
            group.add(drum);

            const roofMaterial = redTileMaterial.clone();
            const roof = new THREE.Mesh(new THREE.ConeGeometry(scaleValue(6.5), 2.5, 24), roofMaterial);
            roof.position.y = podiumHeight + columnHeight + 1.2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            return group;
        }

        function createBouleuterionStructure() {
            const group = new THREE.Group();
            const baseHeight = 0.6;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(0.02, -0.05, -0.05);
            const base = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(24), baseHeight, scaleValue(20)), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const hallHeight = 6.8;
            const hallMaterial = marbleMaterial.clone();
            hallMaterial.color = hallMaterial.color.clone().offsetHSL(-0.02, -0.05, 0.02);
            const hall = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(18), hallHeight, scaleValue(14)), hallMaterial);
            hall.position.y = baseHeight + hallHeight / 2;
            hall.castShadow = true;
            hall.receiveShadow = true;
            group.add(hall);

            const roofHeight = 1.4;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(12 * CITY_SCALE, 6 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(20), roofHeight, scaleValue(16)), roofMaterial);
            roof.position.y = baseHeight + hallHeight + roofHeight / 2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            const portico = new THREE.Group();
            const columnCount = 4;
            const spacing = scaleValue(12) / (columnCount - 1);
            for (let i = 0; i < columnCount; i++) {
                const column = createEnhancedColumn(5.8);
                column.position.set(-scaleValue(6) + i * spacing, baseHeight, scaleValue(9));
                portico.add(column);
            }
            const architrave = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 0.8, scaleValue(4.5)), marbleMaterial.clone());
            architrave.position.set(0, baseHeight + 5.8, scaleValue(9));
            architrave.castShadow = true;
            architrave.receiveShadow = true;
            portico.add(architrave);

            group.add(portico);

            return group;
        }

        function createAltarOfTwelveGodsStructure() {
            const group = new THREE.Group();
            const tiers = [
                { width: 14, depth: 8, height: 0.4 },
                { width: 11.5, depth: 5.5, height: 0.4 },
                { width: 8, depth: 3, height: 0.6 }
            ];
            let elevation = 0;
            tiers.forEach((tier, index) => {
                const material = marbleMaterial.clone();
                material.roughness = Math.max(0.35, material.roughness - 0.05 * (index + 1));
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(tier.width), tier.height, scaleValue(tier.depth)), material);
                elevation += tier.height / 2;
                mesh.position.y = elevation;
                elevation += tier.height / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            });

            const bowlMaterial = goldMaterial.clone();
            const fireBowl = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * CITY_SCALE, 0.8 * CITY_SCALE, 0.7, 16), bowlMaterial);
            fireBowl.position.y = elevation + 0.35;
            fireBowl.castShadow = true;
            group.add(fireBowl);

            return group;
        }

// Pristine Agora Builder Function
// Insert this function into your existing Athens code and call it from createAgoraComplex()

function createPristineAgoraComplex() {
    const agoraGroup = new THREE.Group();
    const buildings = [];

    // Helper function to create perfect columns
    function createPerfectColumn(height = 8, radius = 0.8) {
        const group = new THREE.Group();
        
        // Pristine marble material
        const marbleMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFAF0,
            shininess: 50,
            specular: 0x222222
        });
        
        // Perfect base
        const baseGeo = new THREE.CylinderGeometry(radius * 1.4, radius * 1.6, 1, 20);
        const base = new THREE.Mesh(baseGeo, marbleMat);
        base.position.y = 0.5;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);
        
        // Fluted column shaft
        const columnGeo = new THREE.CylinderGeometry(radius, radius * 1.1, height, 20);
        const column = new THREE.Mesh(columnGeo, marbleMat);
        column.position.y = 1 + height / 2;
        column.castShadow = true;
        column.receiveShadow = true;
        group.add(column);
        
        // Golden capital
        const capGeo = new THREE.CylinderGeometry(radius * 1.5, radius * 1.1, 1.2, 20);
        const capMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700,
            shininess: 80,
            specular: 0x333333
        });
        const capital = new THREE.Mesh(capGeo, capMat);
        capital.position.y = 1 + height + 0.6;
        capital.castShadow = true;
        group.add(capital);
        
        // Decorative abacus
        const abacusGeo = new THREE.BoxGeometry(radius * 3, 0.3, radius * 3);
        const abacus = new THREE.Mesh(abacusGeo, capMat);
        abacus.position.y = 1 + height + 1.35;
        abacus.castShadow = true;
        group.add(abacus);
        
        return group;
    }

    // Create pristine marble plaza
    const plazaGeometry = new THREE.PlaneGeometry(scaleValue(90), scaleValue(70));
    const plazaMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xFAF0E6,
        shininess: 30,
        specular: 0x111111
    });
    const plaza = new THREE.Mesh(plazaGeometry, plazaMaterial);
    plaza.rotation.x = -Math.PI / 2;
    plaza.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.02, scaleValue(AGORA_ANCHOR_SCENE.z));
    plaza.receiveShadow = true;
    agoraGroup.add(plaza);

    // Elegant processional way
    const processional = new THREE.Mesh(
        new THREE.PlaneGeometry(scaleValue(70), scaleValue(8)), 
        new THREE.MeshPhongMaterial({ color: 0xF0F8FF, shininess: 40 })
    );
    processional.rotation.x = -Math.PI / 2;
    processional.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.03, scaleValue(AGORA_ANCHOR_SCENE.z));
    processional.receiveShadow = true;
    agoraGroup.add(processional);

    // Temple of Hephaestus - Pristine Version
    function createPristineTempleOfHephaestus() {
        const temple = new THREE.Group();
        
        // Stepped platform
        for (let i = 0; i < 3; i++) {
            const stepGeo = new THREE.BoxGeometry(scaleValue(35 - i), 0.5, scaleValue(18 - i * 0.5));
            const stepMat = new THREE.MeshPhongMaterial({ 
                color: 0xF8F8FF,
                shininess: 40
            });
            const step = new THREE.Mesh(stepGeo, stepMat);
            step.position.y = i * 0.5 + 0.25;
            step.castShadow = true;
            step.receiveShadow = true;
            temple.add(step);
        }
        
        // Main temple structure
        const cellaMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFAF0,
            shininess: 50
        });
        const cella = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(20), 8, scaleValue(10)), 
            cellaMat
        );
        cella.position.y = 1.5 + 4;
        cella.castShadow = true;
        cella.receiveShadow = true;
        temple.add(cella);
        
        // Perfect columns - front peristyle
        for (let i = 0; i < 8; i++) {
            const column = createPerfectColumn(12, 0.8);
            column.position.set(scaleValue(-14 + i * 4), 1.5, scaleValue(9));
            temple.add(column);
        }
        
        // Back peristyle
        for (let i = 0; i < 8; i++) {
            const column = createPerfectColumn(12, 0.8);
            column.position.set(scaleValue(-14 + i * 4), 1.5, scaleValue(-9));
            temple.add(column);
        }
        
        // Side columns
        for (let i = 0; i < 4; i++) {
            const leftColumn = createPerfectColumn(12, 0.8);
            leftColumn.position.set(scaleValue(-16), 1.5, scaleValue(-6 + i * 4));
            temple.add(leftColumn);
            
            const rightColumn = createPerfectColumn(12, 0.8);
            rightColumn.position.set(scaleValue(16), 1.5, scaleValue(-6 + i * 4));
            temple.add(rightColumn);
        }
        
        // Pristine roof with painted pediments
        const roofMat = new THREE.MeshPhongMaterial({ 
            color: 0xDC143C,
            shininess: 20
        });
        const roof = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(32), 2, scaleValue(16)), 
            roofMat
        );
        roof.position.y = 1.5 + 12 + 1;
        roof.castShadow = true;
        temple.add(roof);
        
        // Painted pediment triangles
        const pedimentGeo = new THREE.ConeGeometry(scaleValue(8), 4, 3);
        const pedimentMat = new THREE.MeshPhongMaterial({ 
            color: 0x4169E1
        });
        
        const frontPediment = new THREE.Mesh(pedimentGeo, pedimentMat);
        frontPediment.position.set(0, 1.5 + 12 + 3, scaleValue(8));
        frontPediment.rotation.x = Math.PI / 2;
        frontPediment.rotation.z = Math.PI / 6;
        temple.add(frontPediment);
        
        const backPediment = new THREE.Mesh(pedimentGeo, pedimentMat);
        backPediment.position.set(0, 1.5 + 12 + 3, scaleValue(-8));
        backPediment.rotation.x = -Math.PI / 2;
        backPediment.rotation.z = Math.PI / 6;
        temple.add(backPediment);
        
        return temple;
    }

    // Stoa of Attalos - Grand Version
    function createGrandStoaOfAttalos() {
        const stoa = new THREE.Group();
        
        // Grand foundation
        const foundationMat = new THREE.MeshPhongMaterial({ 
            color: 0xF5F5DC,
            shininess: 40
        });
        const foundation = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(80), 2, scaleValue(20)), 
            foundationMat
        );
        foundation.position.y = 1;
        foundation.castShadow = true;
        foundation.receiveShadow = true;
        stoa.add(foundation);
        
        // Two-story structure
        const buildingMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFAF0,
            shininess: 50
        });
        
        // First floor
        const firstFloor = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(75), 8, scaleValue(15)), 
            buildingMat
        );
        firstFloor.position.y = 2 + 4;
        firstFloor.castShadow = true;
        firstFloor.receiveShadow = true;
        stoa.add(firstFloor);
        
        // Second floor
        const secondFloor = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(75), 6, scaleValue(15)), 
            buildingMat
        );
        secondFloor.position.y = 2 + 8 + 3;
        secondFloor.castShadow = true;
        secondFloor.receiveShadow = true;
        stoa.add(secondFloor);
        
        // Lower colonnade
        for (let i = 0; i < 15; i++) {
            const column = createPerfectColumn(8, 0.7);
            column.position.set(scaleValue(-35 + i * 5), 2, scaleValue(10));
            stoa.add(column);
        }
        
        // Upper colonnade
        for (let i = 0; i < 15; i++) {
            const column = createPerfectColumn(6, 0.5);
            column.position.set(scaleValue(-35 + i * 5), 2 + 8, scaleValue(10));
            stoa.add(column);
        }
        
        // Colorful roof
        const roofMat = new THREE.MeshPhongMaterial({ 
            color: 0x8B4513,
            shininess: 30
        });
        const roof = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(82), 3, scaleValue(22)), 
            roofMat
        );
        roof.position.y = 2 + 8 + 6 + 1.5;
        roof.castShadow = true;
        stoa.add(roof);
        
        return stoa;
    }

    // Magnificent Tholos
    function createMagnificentTholos() {
        const tholos = new THREE.Group();
        
        // Circular marble platform
        const platformMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFAF0,
            shininess: 50
        });
        const platform = new THREE.Mesh(
            new THREE.CylinderGeometry(scaleValue(12), scaleValue(12), 1.5, 32), 
            platformMat
        );
        platform.position.y = 0.75;
        platform.castShadow = true;
        platform.receiveShadow = true;
        tholos.add(platform);
        
        // Central circular chamber
        const chamberMat = new THREE.MeshPhongMaterial({ 
            color: 0xF8F8FF,
            shininess: 40
        });
        const chamber = new THREE.Mesh(
            new THREE.CylinderGeometry(scaleValue(6), scaleValue(6), 6, 24), 
            chamberMat
        );
        chamber.position.y = 1.5 + 3;
        chamber.castShadow = true;
        chamber.receiveShadow = true;
        tholos.add(chamber);
        
        // Perfect ring of columns
        for (let i = 0; i < 18; i++) {
            const angle = (i / 18) * Math.PI * 2;
            const column = createPerfectColumn(8, 0.6);
            column.position.set(
                Math.cos(angle) * scaleValue(9),
                1.5,
                Math.sin(angle) * scaleValue(9)
            );
            tholos.add(column);
        }
        
        // Conical roof with golden akroterion
        const roofMat = new THREE.MeshPhongMaterial({ 
            color: 0xDC143C,
            shininess: 30
        });
        const roof = new THREE.Mesh(
            new THREE.ConeGeometry(scaleValue(10), 6, 24), 
            roofMat
        );
        roof.position.y = 1.5 + 8 + 3;
        roof.castShadow = true;
        tholos.add(roof);
        
        // Golden ornament on top
        const ornamentMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700,
            shininess: 100
        });
        const ornament = new THREE.Mesh(
            new THREE.SphereGeometry(scaleValue(0.8), 16, 12), 
            ornamentMat
        );
        ornament.position.y = 1.5 + 8 + 6 + scaleValue(0.8);
        ornament.castShadow = true;
        tholos.add(ornament);
        
        return tholos;
    }

    // Sacred Altar
    function createSacredAltar() {
        const altar = new THREE.Group();
        
        // Multi-tiered marble altar
        const marbleMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFAF0,
            shininess: 60
        });
        
        // Base tier
        const base = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(12), 1, scaleValue(8)), 
            marbleMat
        );
        base.position.y = 0.5;
        base.castShadow = true;
        base.receiveShadow = true;
        altar.add(base);
        
        // Middle tier
        const middle = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(8), 1, scaleValue(5)), 
            marbleMat
        );
        middle.position.y = 1.5;
        middle.castShadow = true;
        middle.receiveShadow = true;
        altar.add(middle);
        
        // Top tier
        const top = new THREE.Mesh(
            new THREE.BoxGeometry(scaleValue(5), 1.5, scaleValue(3)), 
            marbleMat
        );
        top.position.y = 2.75;
        top.castShadow = true;
        top.receiveShadow = true;
        altar.add(top);
        
        // Golden fire bowl
        const bowlMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700,
            shininess: 100
        });
        const bowl = new THREE.Mesh(
            new THREE.CylinderGeometry(scaleValue(1.2), scaleValue(1.5), 1, 16), 
            bowlMat
        );
        bowl.position.y = 4;
        bowl.castShadow = true;
        altar.add(bowl);
        
        // Sacred fire
        const fireMat = new THREE.MeshBasicMaterial({ 
            color: 0xFF6347,
            transparent: true,
            opacity: 0.8
        });
        const fire = new THREE.Mesh(
            new THREE.ConeGeometry(scaleValue(0.8), 2.5, 8), 
            fireMat
        );
        fire.position.y = 5.5;
        altar.add(fire);
        
        return altar;
    }

    // Create and position all buildings
    const temple = createPristineTempleOfHephaestus();
    temple.rotation.y = AGORA_FEATURES.templeOfHephaistos.rotation;
    temple.position.set(
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.x),
        0,
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.z)
    );
    agoraGroup.add(temple);
    buildings.push({ mesh: temple, name: "Temple of Hephaestus", position: temple.position.clone() });

    const stoa = createGrandStoaOfAttalos();
    stoa.rotation.y = AGORA_FEATURES.stoaOfAttalos.rotation;
    stoa.position.set(
        scaleValue(AGORA_FEATURES.stoaOfAttalos.position.x),
        0,
        scaleValue(AGORA_FEATURES.stoaOfAttalos.position.z)
    );
    agoraGroup.add(stoa);
    buildings.push({ mesh: stoa, name: "Stoa of Attalos", position: stoa.position.clone() });

    const tholos = createMagnificentTholos();
    tholos.position.set(
        scaleValue(AGORA_FEATURES.tholos.position.x),
        0,
        scaleValue(AGORA_FEATURES.tholos.position.z)
    );
    agoraGroup.add(tholos);
    buildings.push({ mesh: tholos, name: "The Tholos", position: tholos.position.clone() });

    const altar = createSacredAltar();
    altar.rotation.y = AGORA_FEATURES.altarOfTwelveGods.rotation;
    altar.position.set(
        scaleValue(AGORA_FEATURES.altarOfTwelveGods.position.x),
        0,
        scaleValue(AGORA_FEATURES.altarOfTwelveGods.position.z)
    );
    agoraGroup.add(altar);
    buildings.push({ mesh: altar, name: "Altar of Twelve Gods", position: altar.position.clone() });

    return { group: agoraGroup, buildings: buildings };
}

// Integration instructions:
// 1. Replace your existing createAgoraComplex() function with this:
// FIXED VERSION - Replace your createAgoraComplex() function with this:

function createAgoraComplex() {
    const agoraGroup = new THREE.Group();
    agoraGroup.name = 'Agora Precinct';
    scene.add(agoraGroup);
    registerAmbientZone(agoraGroup, {
        id: 'agora-market',
        type: 'market',
        radius: scaleValue(45),
        maxDistance: scaleValue(240),
        volume: 0.58,
        rolloff: 2.4
    });

    const plazaMaterial = new THREE.MeshStandardMaterial({
        color: 0xb9a880,
        roughness: 0.85,
        metalness: 0.04
    });
    const plaza = new THREE.Mesh(
        new THREE.PlaneGeometry(scaleValue(90), scaleValue(70)),
        plazaMaterial
    );
    plaza.rotation.x = -Math.PI / 2;
    plaza.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.02, scaleValue(AGORA_ANCHOR_SCENE.z));
    plaza.receiveShadow = true;
    agoraGroup.add(plaza);

    const processional = new THREE.Mesh(
        new THREE.PlaneGeometry(scaleValue(70), scaleValue(8)),
        new THREE.MeshStandardMaterial({ color: 0xa9a9a9, roughness: 0.78, metalness: 0.03 })
    );
    processional.rotation.x = -Math.PI / 2;
    processional.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.03, scaleValue(AGORA_ANCHOR_SCENE.z));
    processional.receiveShadow = true;
    agoraGroup.add(processional);

    const loader = new GLTFLoader();
    const featureDefinitions = [
        {
            key: 'templeOfHephaistos',
            name: 'Temple of Hephaistos',
            asset: AGORA_FEATURES.templeOfHephaistos.asset,
            fallback: () => makeTemple({ width: 14, length: 32, colsShort: 6, colsLong: 13, colH: 8.5 })
        },
        {
            key: 'stoaOfAttalos',
            name: 'Stoa of Attalos',
            fallback: () => makeStoa({ length: 115, depth: 20, colH: 9, colR: 0.6, cols: 46 })
        },
        {
            key: 'tholos',
            name: 'The Tholos',
            fallback: () => makeTholos({ radius: 12, colH: 6.5, colR: 0.5, cols: 18 })
        },
        {
            key: 'bouleuterion',
            name: 'Bouleuterion',
            fallback: () => createBouleuterionPrimitive()
        },
        {
            key: 'altarOfTwelveGods',
            name: 'Altar of the Twelve Gods',
            fallback: () => makeAltar({ width: 10, depth: 6, height: 3 })
        }
    ];

    const placedBuildings = [];

    featureDefinitions.forEach((definition) => {
        const feature = AGORA_FEATURES[definition.key];
        if (!feature) {
            return;
        }

        const featureGroup = new THREE.Group();
        featureGroup.name = definition.name;
        featureGroup.position.set(
            scaleValue(feature.position.x),
            feature.position.y ?? 0,
            scaleValue(feature.position.z)
        );
        featureGroup.rotation.y = feature.rotation ?? 0;
        agoraGroup.add(featureGroup);

        const addFallback = () => {
            if (!definition.fallback) {
                return;
            }
            const fallbackMesh = definition.fallback();
            enableShadows(fallbackMesh);
            featureGroup.add(fallbackMesh);
        };

        const assetConfig = definition.asset;
        if (assetConfig?.model) {
            loader.load(
                assetConfig.model,
                (gltf) => {
                    const source = gltf.scene || gltf.scenes?.[0];
                    if (!source) {
                        addFallback();
                        return;
                    }
                    const model = source.clone(true);
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = selectAgoraMaterialForMesh(child);
                        }
                    });
                    enableShadows(model);
                    fitModelToFootprint(model, assetConfig.target);
                    featureGroup.add(model);
                },
                undefined,
                (error) => {
                    console.warn(`Failed to load ${assetConfig.model}`, error);
                    addFallback();
                }
            );
        } else {
            addFallback();
        }

        placedBuildings.push({ mesh: featureGroup, name: definition.name, position: featureGroup.position.clone() });
    });

    if (typeof createEnhancedTree === 'function') {
        const groveConfigs = [
            { x: AGORA_FEATURES.templeOfHephaistos.position.x - 8, z: AGORA_FEATURES.templeOfHephaistos.position.z + 12, scale: 1.2 },
            { x: AGORA_FEATURES.templeOfHephaistos.position.x - 12, z: AGORA_FEATURES.templeOfHephaistos.position.z - 8, scale: 1.0 },
            { x: AGORA_FEATURES.stoaOfAttalos.position.x + 10, z: AGORA_FEATURES.stoaOfAttalos.position.z - 12, scale: 0.9 }
        ];
        groveConfigs.forEach((config) => {
            try {
                const tree = createEnhancedTree(0, 0, config.scale);
                tree.position.set(scaleValue(config.x), 0, scaleValue(config.z));
                agoraGroup.add(tree);
            } catch (error) {
                console.warn('Could not create tree:', error);
            }
        });
    }

    window.agoraBuildings = placedBuildings;
    return { group: agoraGroup, buildings: placedBuildings };
}

function createBouleuterionPrimitive() {
    const group = new THREE.Group();

    const podium = new THREE.Mesh(new THREE.BoxGeometry(32, 0.6, 26), MAT.marble.clone());
    podium.position.y = 0.3;
    group.add(podium);

    const hallHeight = 8.2;
    const hall = new THREE.Mesh(new THREE.BoxGeometry(26, hallHeight, 20), MAT.stone.clone());
    hall.position.y = 0.6 + hallHeight / 2;
    group.add(hall);

    const roofThickness = 1.0;
    const roofDepth = 12.5;
    const roofLength = 28.5;
    const roofPitch = THREE.MathUtils.degToRad(16);

    const roofFront = new THREE.Mesh(new THREE.BoxGeometry(roofLength, roofThickness, roofDepth), MAT.roof.clone());
    roofFront.position.set(0, hall.position.y + hallHeight / 2 + roofThickness / 2, -roofDepth / 2);
    roofFront.rotation.x = roofPitch;
    const roofBack = roofFront.clone();
    roofBack.position.z = roofDepth / 2;
    roofBack.rotation.x = -roofPitch;
    group.add(roofFront, roofBack);

    const pedimentShape = new THREE.Shape();
    pedimentShape.moveTo(-roofLength / 2, 0);
    pedimentShape.lineTo(roofLength / 2, 0);
    pedimentShape.lineTo(0, 4.2);
    pedimentShape.closePath();
    const pedimentGeo = new THREE.ExtrudeGeometry(pedimentShape, { depth: 1.2, bevelEnabled: false });
    const pedimentFront = new THREE.Mesh(pedimentGeo, MAT.marble.clone());
    pedimentFront.rotation.x = Math.PI / 2;
    pedimentFront.position.set(0, hall.position.y + hallHeight / 2 + 1.8, 10.2);
    const pedimentBack = pedimentFront.clone();
    pedimentBack.position.z = -10.2 - 1.2;
    group.add(pedimentFront, pedimentBack);

    const colGeo = new THREE.CylinderGeometry(0.55, 0.55, 6.5, 16, 1);
    const colMat = MAT.marble.clone();
    const peristyle = new THREE.InstancedMesh(colGeo, colMat, 6);
    const columnX = [-6.3, -2.2, 2.2, 6.3];
    let idx = 0;
    const columnY = 0.6 + 3.25;
    columnX.forEach((x) => {
        peristyle.setMatrixAt(idx++, new THREE.Matrix4().makeTranslation(x, columnY, 10.2));
        if (idx < peristyle.count) {
            peristyle.setMatrixAt(idx++, new THREE.Matrix4().makeTranslation(x, columnY, -10.2));
        }
    });
    group.add(peristyle);

    const clerestory = new THREE.Mesh(new THREE.BoxGeometry(18, 2.1, 10), MAT.stone.clone());
    clerestory.position.set(0, hall.position.y + hallHeight / 2 + 1.6, 0);
    group.add(clerestory);

    return group;
}

function enableShadows(object) {
    object.traverse?.((child) => {
        if (child.isMesh || child.isInstancedMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
        }
    });
}

function selectAgoraMaterialForMesh(mesh) {
    const label = `${mesh.name ?? ''} ${(mesh.material && mesh.material.name) || ''}`.toLowerCase();
    if (label.includes('roof') || label.includes('tile')) {
        return MAT.roof.clone();
    }
    if (label.includes('column') || label.includes('capital') || label.includes('pediment') || label.includes('marble')) {
        return MAT.marble.clone();
    }
    return MAT.stone.clone();
}

function fitModelToFootprint(model, target = {}) {
    const box = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3();
    box.getSize(size);

    const scales = [];
    if (target.width && size.x > 0) scales.push(target.width / size.x);
    if (target.length && size.z > 0) scales.push(target.length / size.z);
    if (target.height && size.y > 0) scales.push(target.height / size.y);

    if (scales.length) {
        const scale = Math.min(...scales.filter((value) => Number.isFinite(value) && value > 0));
        if (Number.isFinite(scale) && scale > 0) {
            model.scale.multiplyScalar(scale);
        }
    }

    const finalBox = new THREE.Box3().setFromObject(model);
    const lift = finalBox.min.y;
    if (lift !== 0) {
        model.position.y -= lift;
    }
}


// Safe pristine building creation
function createPristineAgoraBuildings() {
    const buildings = [];

    // Helper function to create materials safely
    function createSafeMaterial(color, shininess = 30) {
        return new THREE.MeshPhongMaterial({ 
            color: color,
            shininess: shininess,
            specular: 0x222222
        });
    }

    // Helper function to create perfect columns
    function createPerfectColumn(height = 8, radius = 0.8) {
        const group = new THREE.Group();
        
        const marbleMat = createSafeMaterial(0xFFFAF0, 50);
        const goldMat = createSafeMaterial(0xFFD700, 80);
        
        // Base
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(radius * 1.4, radius * 1.6, 1, 20), 
            marbleMat
        );
        base.position.y = 0.5;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);
        
        // Column
        const column = new THREE.Mesh(
            new THREE.CylinderGeometry(radius, radius * 1.1, height, 20), 
            marbleMat
        );
        column.position.y = 1 + height / 2;
        column.castShadow = true;
        column.receiveShadow = true;
        group.add(column);
        
        // Capital
        const capital = new THREE.Mesh(
            new THREE.CylinderGeometry(radius * 1.5, radius * 1.1, 1.2, 20), 
            goldMat
        );
        capital.position.y = 1 + height + 0.6;
        capital.castShadow = true;
        group.add(capital);
        
        return group;
    }

    // Temple of Hephaestus
    const temple = new THREE.Group();
    
    // Platform
    const platform = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(32), 1.5, scaleValue(16)), 
        createSafeMaterial(0xF8F8FF)
    );
    platform.position.y = 0.75;
    platform.castShadow = true;
    platform.receiveShadow = true;
    temple.add(platform);
    
    // Main structure
    const cella = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(20), 8, scaleValue(10)), 
        createSafeMaterial(0xFFFAF0)
    );
    cella.position.y = 1.5 + 4;
    cella.castShadow = true;
    cella.receiveShadow = true;
    temple.add(cella);
    
    // Columns
    for (let i = 0; i < 8; i++) {
        const frontColumn = createPerfectColumn(12, 0.8);
        frontColumn.position.set(scaleValue(-14 + i * 4), 1.5, scaleValue(8));
        temple.add(frontColumn);
        
        const backColumn = createPerfectColumn(12, 0.8);
        backColumn.position.set(scaleValue(-14 + i * 4), 1.5, scaleValue(-8));
        temple.add(backColumn);
    }
    
    // Roof
    const roof = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(30), 2, scaleValue(14)), 
        createSafeMaterial(0xDC143C, 20)
    );
    roof.position.y = 1.5 + 12 + 1;
    roof.castShadow = true;
    temple.add(roof);
    
    temple.rotation.y = AGORA_FEATURES.templeOfHephaistos.rotation;
    temple.position.set(
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.x),
        0,
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.z)
    );
    buildings.push({ mesh: temple, name: "üî® Temple of Hephaestus", position: temple.position.clone() });

    // Stoa of Attalos
    const stoa = new THREE.Group();
    
    const stoaBase = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(70), 2, scaleValue(18)), 
        createSafeMaterial(0xF5F5DC)
    );
    stoaBase.position.y = 1;
    stoaBase.castShadow = true;
    stoaBase.receiveShadow = true;
    stoa.add(stoaBase);
    
    const stoaBuilding = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(65), 10, scaleValue(15)), 
        createSafeMaterial(0xFFFAF0)
    );
    stoaBuilding.position.y = 2 + 5;
    stoaBuilding.castShadow = true;
    stoaBuilding.receiveShadow = true;
    stoa.add(stoaBuilding);
    
    // Colonnade
    for (let i = 0; i < 12; i++) {
        const column = createPerfectColumn(10, 0.7);
        column.position.set(scaleValue(-30 + i * 5), 2, scaleValue(9));
        stoa.add(column);
    }
    
    stoa.rotation.y = AGORA_FEATURES.stoaOfAttalos.rotation;
    stoa.position.set(
        scaleValue(AGORA_FEATURES.stoaOfAttalos.position.x),
        0,
        scaleValue(AGORA_FEATURES.stoaOfAttalos.position.z)
    );
    buildings.push({ mesh: stoa, name: "üèõÔ∏è Stoa of Attalos", position: stoa.position.clone() });

    // Tholos
    const tholos = new THREE.Group();
    
    const tholosBase = new THREE.Mesh(
        new THREE.CylinderGeometry(scaleValue(10), scaleValue(10), 1.5, 32), 
        createSafeMaterial(0xFFFAF0)
    );
    tholosBase.position.y = 0.75;
    tholosBase.castShadow = true;
    tholosBase.receiveShadow = true;
    tholos.add(tholosBase);
    
    // Ring of columns
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const column = createPerfectColumn(8, 0.6);
        column.position.set(
            Math.cos(angle) * scaleValue(7),
            1.5,
            Math.sin(angle) * scaleValue(7)
        );
        tholos.add(column);
    }
    
    // Conical roof
    const tholosRoof = new THREE.Mesh(
        new THREE.ConeGeometry(scaleValue(8), 6, 24), 
        createSafeMaterial(0xDC143C)
    );
    tholosRoof.position.y = 1.5 + 8 + 3;
    tholosRoof.castShadow = true;
    tholos.add(tholosRoof);
    
    tholos.position.set(
        scaleValue(AGORA_FEATURES.tholos.position.x),
        0,
        scaleValue(AGORA_FEATURES.tholos.position.z)
    );
    buildings.push({ mesh: tholos, name: "‚öñÔ∏è The Tholos", position: tholos.position.clone() });

    return buildings;
}

// Fallback function if pristine version fails
function createBasicAgoraFallback() {
    console.log('Creating basic Agora fallback...');
    
    // Create very basic structures using existing materials
    const basicMaterial = stoneMaterial || new THREE.MeshLambertMaterial({ color: 0x808080 });
    
    // Simple temple
    const simpleTemple = new THREE.Mesh(
        new THREE.BoxGeometry(scaleValue(25), 8, scaleValue(12)), 
        basicMaterial
    );
    simpleTemple.position.set(
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.x),
        4,
        scaleValue(AGORA_FEATURES.templeOfHephaistos.position.z)
    );
    simpleTemple.castShadow = true;
    simpleTemple.receiveShadow = true;
    scene.add(simpleTemple);
    
    console.log('Basic Agora fallback created');
}

        function createAreopagusHill() {
            const hillGroup = new THREE.Group();
            const baseRadius = scaleValue(20);
            const baseHeight = 3.2;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(-0.05, -0.05, -0.05);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(baseRadius * 0.9, baseRadius, baseHeight, 24), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            hillGroup.add(base);

            const midLayer = new THREE.Mesh(new THREE.CylinderGeometry(baseRadius * 0.7, baseRadius * 0.9, 2.6, 20), baseMaterial);
            midLayer.position.y = baseHeight + 1.3;
            midLayer.castShadow = true;
            midLayer.receiveShadow = true;
            hillGroup.add(midLayer);

            for (let i = 0; i < 6; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2.2 * CITY_SCALE + Math.random() * CITY_SCALE), baseMaterial.clone());
                const angle = Math.random() * Math.PI * 2;
                const radius = baseRadius * 0.6 + Math.random() * baseRadius * 0.3;
                rock.position.set(Math.cos(angle) * radius, baseHeight + 1 + Math.random() * 2, Math.sin(angle) * radius);
                rock.castShadow = true;
                rock.receiveShadow = true;
                hillGroup.add(rock);
            }

            const stairMaterial = pavedRoadMaterial.clone();
            const stairs = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(6), 0.4, scaleValue(18)), stairMaterial);
            stairs.position.set(0, baseHeight + 0.2, -scaleValue(7));
            stairs.rotation.x = Math.PI / 18;
            stairs.receiveShadow = true;
            hillGroup.add(stairs);

            const altarMaterial = marbleMaterial.clone();
            const altar = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(5), 1, scaleValue(3)), altarMaterial);
            altar.position.set(0, baseHeight + 3.8, scaleValue(2));
            altar.castShadow = true;
            altar.receiveShadow = true;
            hillGroup.add(altar);

            const olive = createEnhancedTree(0, 0, 0.9);
            olive.position.set(scaleValue(3), baseHeight + 1, scaleValue(6));
            hillGroup.add(olive);

            hillGroup.position.set(scaleValue(AREOPAGUS_POSITION.x), 0, scaleValue(AREOPAGUS_POSITION.z));
            scene.add(hillGroup);
        }

        function createKerameikosDistrict() {
            const kerameikosGroup = new THREE.Group();
            const groundMaterialVariant = groundMaterial.clone();
            groundMaterialVariant.color = groundMaterialVariant.color.clone().offsetHSL(-0.05, 0.02, 0.04);
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(60), scaleValue(50)), groundMaterialVariant);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.02;
            ground.receiveShadow = true;
            kerameikosGroup.add(ground);

            const gateFloor = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(18), scaleValue(28)), pavedRoadMaterial.clone());
            gateFloor.rotation.x = -Math.PI / 2;
            gateFloor.position.set(0, 0.03, -scaleValue(12));
            gateFloor.receiveShadow = true;
            kerameikosGroup.add(gateFloor);

            const towerMaterial = stoneMaterial.clone();
            towerMaterial.color = towerMaterial.color.clone().offsetHSL(0, -0.05, -0.1);
            const towerGeometry = new THREE.BoxGeometry(scaleValue(10), 10, scaleValue(10));
            const westTower = new THREE.Mesh(towerGeometry, towerMaterial);
            westTower.position.set(-scaleValue(8), 5, 0);
            westTower.castShadow = true;
            westTower.receiveShadow = true;
            kerameikosGroup.add(westTower);

            const eastTower = westTower.clone();
            eastTower.position.x = scaleValue(8);
            kerameikosGroup.add(eastTower);

            const gateMaterial = marbleMaterial.clone();
            gateMaterial.color = gateMaterial.color.clone().offsetHSL(-0.05, -0.05, 0.05);
            const gate = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 6, scaleValue(4)), gateMaterial);
            gate.position.set(0, 3.2, 0);
            gate.castShadow = true;
            gate.receiveShadow = true;
            kerameikosGroup.add(gate);

            const lintel = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 1.2, scaleValue(8)), gateMaterial);
            lintel.position.set(0, 5.8, -scaleValue(2));
            lintel.castShadow = true;
            lintel.receiveShadow = true;
            kerameikosGroup.add(lintel);

            const steleMaterial = marbleMaterial.clone();
            for (let i = 0; i < 7; i++) {
                const height = 2.4 + Math.random() * 1.2;
                const stele = new THREE.Mesh(new THREE.CylinderGeometry(0.45 * CITY_SCALE, 0.55 * CITY_SCALE, height, 8), steleMaterial);
                const angle = (i / 7) * Math.PI + Math.PI / 4;
                const radius = scaleValue(18 + Math.random() * 6);
                stele.position.set(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
                stele.castShadow = true;
                stele.receiveShadow = true;
                kerameikosGroup.add(stele);
            }

            const olive = createEnhancedTree(0, 0, 0.85);
            olive.position.set(-scaleValue(16), 0, scaleValue(10));
            kerameikosGroup.add(olive);

            kerameikosGroup.rotation.y = LONG_WALL_DIRECTION;
            kerameikosGroup.position.set(scaleValue(KERAMEIKOS_POSITION.x), 0, scaleValue(KERAMEIKOS_POSITION.z));
            scene.add(kerameikosGroup);
        }

        function createLongWallsCorridors() {
            const createCorridor = (endPosition, { width = 10, height = 4.5, thickness = 1.4, maxLength = 160 } = {}) => {
                const start = KERAMEIKOS_POSITION;
                const dx = endPosition.x - start.x;
                const dz = endPosition.z - start.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                if (length < 1e-3) {
                    return;
                }
                const clampRatio = Math.min(1, maxLength / length);
                const target = {
                    x: start.x + dx * clampRatio,
                    z: start.z + dz * clampRatio
                };
                const actualLength = length * clampRatio;
                const angle = Math.atan2(target.x - start.x, target.z - start.z);
                const corridorGroup = new THREE.Group();
                const scaledLength = scaleValue(actualLength);

                const walkway = new THREE.Mesh(new THREE.PlaneGeometry(scaledLength, scaleValue(width)), pavedRoadMaterial.clone());
                walkway.rotation.x = -Math.PI / 2;
                walkway.position.y = 0.06;
                walkway.receiveShadow = true;
                corridorGroup.add(walkway);

                const wallMaterial = stoneMaterial.clone();
                wallMaterial.color = wallMaterial.color.clone().offsetHSL(-0.05, -0.05, -0.05);
                const wallGeometry = new THREE.BoxGeometry(scaleValue(thickness), height, scaledLength);
                const wallOffset = scaleValue(width / 2 - thickness / 2);

                const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
                wallLeft.position.set(wallOffset, height / 2, 0);
                wallLeft.castShadow = true;
                wallLeft.receiveShadow = true;
                corridorGroup.add(wallLeft);

                const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
                wallRight.position.set(-wallOffset, height / 2, 0);
                wallRight.castShadow = true;
                wallRight.receiveShadow = true;
                corridorGroup.add(wallRight);

                const parapetMaterial = wallMaterial.clone();
                const parapetGeometry = new THREE.BoxGeometry(scaleValue(thickness) * 0.8, 0.6, scaledLength);
                const parapetLeft = new THREE.Mesh(parapetGeometry, parapetMaterial);
                parapetLeft.position.set(wallOffset, height + 0.3, 0);
                corridorGroup.add(parapetLeft);
                const parapetRight = parapetLeft.clone();
                parapetRight.position.x = -wallOffset;
                corridorGroup.add(parapetRight);

                corridorGroup.rotation.y = angle;
                const midX = (start.x + target.x) / 2;
                const midZ = (start.z + target.z) / 2;
                corridorGroup.position.set(scaleValue(midX), 0, scaleValue(midZ));
                scene.add(corridorGroup);
            };

            createCorridor(PEIRAEUS_POSITION, { maxLength: 170, width: 12 });
            createCorridor(PHALERON_POSITION, { maxLength: 140, width: 10 });
        }

        function createLongWallPosts() {
            const start = KERAMEIKOS_POSITION;
            const spacing = 24;
            const postHeight = 3.4;
            const postGeometry = new THREE.CylinderGeometry(0.6 * CITY_SCALE, 0.8 * CITY_SCALE, postHeight, 6);
            const capGeometry = new THREE.ConeGeometry(0.9 * CITY_SCALE, 1.2, 4);
            const braceGeometry = new THREE.BoxGeometry(scaleValue(2.6), 0.45, scaleValue(0.9));
            const postMaterial = stoneMaterial.clone();
            postMaterial.color = postMaterial.color.clone().offsetHSL(-0.08, -0.06, -0.06);
            const capMaterial = postMaterial.clone();
            capMaterial.color = capMaterial.color.clone().offsetHSL(0.12, 0.12, 0.22);
            const braceMaterial = postMaterial.clone();
            braceMaterial.color = braceMaterial.color.clone().offsetHSL(-0.05, -0.04, -0.12);
            const baseRoadMaterial = pavedRoadMaterial.clone();
            baseRoadMaterial.color = baseRoadMaterial.color.clone().offsetHSL(-0.12, -0.15, 0.12);
            baseRoadMaterial.transparent = true;
            baseRoadMaterial.opacity = 0.25;
            baseRoadMaterial.side = THREE.DoubleSide;

            const corridors = [
                { end: PEIRAEUS_POSITION, orientation: LONG_WALL_DIRECTION },
                { end: PHALERON_POSITION, orientation: Math.atan2(PHALERON_POSITION.x - start.x, PHALERON_POSITION.z - start.z) }
            ];

            corridors.forEach(({ end, orientation }) => {
                const dx = end.x - start.x;
                const dz = end.z - start.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (!Number.isFinite(distance) || distance <= spacing) {
                    return;
                }
                const steps = Math.floor(distance / spacing);
                if (steps < 2) {
                    return;
                }
                const angle = orientation ?? Math.atan2(dx, dz);
                const midX = (start.x + end.x) / 2;
                const midZ = (start.z + end.z) / 2;

                const decalGroup = new THREE.Group();
                const corridorMaterial = baseRoadMaterial.clone();
                const decal = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(distance), scaleValue(4.2)), corridorMaterial);
                decal.rotation.x = -Math.PI / 2;
                decal.receiveShadow = true;
                decalGroup.add(decal);
                decalGroup.rotation.y = angle;
                decalGroup.position.set(scaleValue(midX), 0.035, scaleValue(midZ));
                scene.add(decalGroup);

                for (let i = 1; i < steps; i += 1) {
                    const ratio = (i * spacing) / distance;
                    const px = start.x + dx * ratio;
                    const pz = start.z + dz * ratio;

                    const postGroup = new THREE.Group();

                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.y = postHeight / 2;
                    post.castShadow = true;
                    post.receiveShadow = true;
                    postGroup.add(post);

                    const cap = new THREE.Mesh(capGeometry, capMaterial);
                    cap.position.y = postHeight;
                    cap.castShadow = true;
                    cap.receiveShadow = true;
                    postGroup.add(cap);

                    const brace = new THREE.Mesh(braceGeometry, braceMaterial);
                    brace.position.y = postHeight * 0.65;
                    brace.castShadow = true;
                    brace.receiveShadow = true;
                    postGroup.add(brace);

                    postGroup.position.set(scaleValue(px), 0, scaleValue(pz));
                    postGroup.rotation.y = angle;
                    scene.add(postGroup);
                }
            });
        }

        function createPhaleronHarbor() {
            const harborGroup = new THREE.Group();
            const water = waterMaterial.clone();
            const basin = new THREE.Mesh(new THREE.CircleGeometry(scaleValue(14), 40), water);
            basin.rotation.x = -Math.PI / 2;
            basin.position.y = 0.04;
            basin.receiveShadow = true;
            harborGroup.add(basin);

            const quayMaterial = stoneMaterial.clone();
            const quay = new THREE.Mesh(new THREE.RingGeometry(scaleValue(10), scaleValue(14), 40), quayMaterial);
            quay.rotation.x = -Math.PI / 2;
            quay.position.y = 0.03;
            quay.receiveShadow = true;
            harborGroup.add(quay);

            const pierMaterial = createEnhancedMaterial(0x8b5a2b, 0.9, 0.1);
            const pier = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 0.6, scaleValue(3.5)), pierMaterial);
            pier.position.set(0, 0.3, -scaleValue(7));
            pier.castShadow = true;
            pier.receiveShadow = true;
            harborGroup.add(pier);

            const boatMaterial = createEnhancedMaterial(0x4a5e7a, 0.7, 0.1);
            const boatHull = new THREE.Mesh(new THREE.ConeGeometry(0.9 * CITY_SCALE, 2.5, 5), boatMaterial);
            boatHull.rotation.z = Math.PI;
            boatHull.position.set(scaleValue(4), 0.8, 0);
            boatHull.castShadow = true;
            harborGroup.add(boatHull);

            harborGroup.position.set(scaleValue(PHALERON_POSITION.x), 0, scaleValue(PHALERON_POSITION.z));
            scene.add(harborGroup);
        }

        function createHouses() {
            const houseConfigs = [ {x: -50, z: 0, w: 8, d: 6, style: 'wealthy'}, {x: -50, z: 15, w: 6, d: 8, style: 'middle'}, {x: 50, z: 0, w: 7, d: 7, style: 'wealthy'}, {x: 50, z: -20, w: 9, d: 6, style: 'artisan'}, {x: 30, z: 50, w: 6, d: 6, style: 'middle'}, {x: -30, z: 50, w: 8, d: 7, style: 'wealthy'} ];
            houseConfigs.forEach(config => {
                const material = config.style === 'wealthy' ? marbleMaterial : stoneMaterial;
                const house = createEnhancedBuilding(config.x, config.z, config.w, config.d, 6, material);
                const roofMaterial = config.style === 'wealthy' ? goldMaterial : redTileMaterial;
                const houseRoof = createEnhancedBuilding(config.x, config.z, config.w + 1, config.d + 1, 1, roofMaterial, { includeDetails: false });
                if(houseRoof.children[0].material.map) {
                    houseRoof.children[0].material.map.repeat.set((config.w/2) * CITY_SCALE, (config.d/2) * CITY_SCALE);
                }
                houseRoof.position.y = 7.5;
                scene.add(house);
                scene.add(houseRoof);
            });
        }
        
        function createEnhancedTree(x, z, scale = 1) {
            const tree = new THREE.Group();
            const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale * CITY_SCALE, 0.5 * scale * CITY_SCALE, 5 * scale, 8);
            const trunkMaterial = createEnhancedMaterial(0x8B4513, 1.0, 0.0);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5 * scale;
            trunk.castShadow = true;
            tree.add(trunk);
            for (let i = 0; i < 3; i++) {
                const leavesGeometry = new THREE.SphereGeometry((2.5 - i * 0.3) * scale * CITY_SCALE, 8, 6);
                const leavesMaterial = createEnhancedMaterial(0x228B22, 0.8, 0.0);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = (5 + i * 0.5) * scale;
                leaves.castShadow = true;
                tree.add(leaves);
            }
            setScaledPosition(tree, x, 0, z);
            return tree;
        }

        function createTrees() {
            const treePositions = [ {x: 25, z: 25, scale: 1.2}, {x: -25, z: 25, scale: 0.9}, {x: 35, z: -15, scale: 1.1}, {x: -35, z: 10, scale: 1.0}, {x: 45, z: 35, scale: 0.8}, {x: -40, z: -10, scale: 1.3} ];
            treePositions.forEach(pos => { scene.add(createEnhancedTree(pos.x, pos.z, pos.scale)); });
        }
        
        function initSkyAndStars() {
            const SkyClass = window.Sky;
            if (!SkyClass) {
                console.warn('Sky class is unavailable; skipping sky dome and starfield.');
                return;
            }

            starMaterials.length = 0;

            if (sky) {
                scene.remove(sky);
            }
            if (starLayerInner) {
                scene.remove(starLayerInner);
            }
            if (starLayerOuter) {
                scene.remove(starLayerOuter);
            }
            if (milkyWayMesh) {
                scene.remove(milkyWayMesh);
            }

            sky = new SkyClass();

            if (sky?.material) {
                sky.material.depthWrite = false;
                sky.material.side = THREE.BackSide;
            }

            sky.renderOrder = -1;
            sky.scale.setScalar(450000);
            scene.add(sky);

            skyUniforms = sky.material.uniforms;
            skyUniforms.turbidity.value = 2.0;
            skyUniforms.rayleigh.value = 1.2;
            skyUniforms.mieCoefficient.value = 0.003;
            skyUniforms.mieDirectionalG.value = 0.8;

            sun = new THREE.Vector3();
            setSun(-10, 120);

            starLayerInner = makeStars(5000, 2500, 0.8);
            starLayerOuter = makeStars(8000, 4200, 1.2);
            scene.add(starLayerInner, starLayerOuter);

            const mwGeo = new THREE.RingGeometry(3000, 3050, 128, 1, 0, Math.PI * 1.4);
            const mwMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false, depthTest: false });
            milkyWayMesh = new THREE.Mesh(mwGeo, mwMat);
            milkyWayMesh.rotation.set(Math.PI / 4, 0, Math.PI / 8);
            milkyWayMesh.position.y = 50;
            scene.add(milkyWayMesh);

            renderer.setClearColor(0x03050a, 1.0);
            if (scene.fog) {
                scene.fog.color.set(0x03050a);
            }
        }

        function makeStars(count, radius, size = 1.0) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = radius * (0.985 + 0.015 * Math.random());
                positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.cos(phi);
                positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ size, sizeAttenuation: true, transparent: true, opacity: 0.0, depthWrite: false });
            starMaterials.push(mat);
            const pts = new THREE.Points(geo, mat);
            pts.frustumCulled = false;
            return pts;
        }

        function setupPostFX() {
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 0.0;
            bloomPass.radius = 0.2;
            composer.addPass(bloomPass);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function setSun(elevationDeg, azimuthDeg) {
            if (!sun) {
                sun = new THREE.Vector3();
            }

            const phi = THREE.MathUtils.degToRad(90 - elevationDeg);
            const theta = THREE.MathUtils.degToRad(azimuthDeg);
            sun.setFromSphericalCoords(1, phi, theta);

            if (sky && sky.material && sky.material.uniforms && sky.material.uniforms.sunPosition) {
                sky.material.uniforms.sunPosition.value.copy(sun);
            }

            if (directionalLight) {
                const lightDistance = 3200;
                directionalLight.position.copy(sun).multiplyScalar(lightDistance);
                directionalLight.target.position.set(0, 0, 0);
                directionalLight.target.updateMatrixWorld();
            }
        }

        function setTimeOfDay(name) {
            const presetName = resolvePreset(name);
            if (typeof window !== 'undefined') {
                window.__AthensSkyPreset = presetName;
            }
            const timeInfo = document.getElementById('current-time');
            if (timeInfo) {
                timeInfo.textContent = presetName;
            }

            const settings = {
                elevation: 45,
                azimuth: 180,
                ambientIntensity: 0.28,
                ambientColor: 0xffffff,
                directionalIntensity: 0.85,
                directionalColor: 0xffffff,
                hemisphereIntensity: 0.35,
                hemiSkyColor: 0x87ceeb,
                hemiGroundColor: 0x8b4513,
                exposure: 1.0,
                bloomStrength: 0.0,
                fogColor: 0xcfe8ff,
                fogNear: 600,
                fogFar: 6000,
                starOpacity: 0.0,
                skyTurbidity: 4.0,
                skyRayleigh: 1.4,
                skyMie: 0.002,
                skyMieDirectional: 0.8
            };

            const skydomePreset = photoSkyTimeConfig[presetName];

            switch (presetName) {
                case 'Golden Dawn':
                    settings.elevation = 6;
                    settings.azimuth = 95;
                    settings.ambientIntensity = 0.26;
                    settings.ambientColor = 0xffeecc;
                    settings.directionalIntensity = 0.65;
                    settings.directionalColor = 0xffeac3;
                    settings.hemisphereIntensity = 0.32;
                    settings.hemiSkyColor = 0xffd8a3;
                    settings.hemiGroundColor = 0xb48666;
                    settings.exposure = 0.94;
                    settings.fogColor = 0xffe6cc;
                    settings.skyTurbidity = 8.0;
                    settings.skyRayleigh = 2.2;
                    settings.skyMie = 0.0065;
                    break;
                case 'Blue Hour':
                    settings.elevation = -3;
                    settings.azimuth = 110;
                    settings.ambientIntensity = 0.18;
                    settings.ambientColor = 0x9fb5d1;
                    settings.directionalIntensity = 0.18;
                    settings.directionalColor = 0x7ba4d9;
                    settings.hemisphereIntensity = 0.26;
                    settings.hemiSkyColor = 0x3f5a7a;
                    settings.hemiGroundColor = 0x1c2432;
                    settings.exposure = 0.82;
                    settings.fogColor = 0x4a5c78;
                    settings.starOpacity = 0.25;
                    settings.skyTurbidity = 2.5;
                    settings.skyRayleigh = 3.4;
                    settings.skyMie = 0.0015;
                    break;
                case 'High Noon':
                    settings.elevation = 70;            // high sun
                    settings.azimuth = 180;
                    settings.ambientIntensity = 0.35;
                    settings.ambientColor = 0xffffff;
                    settings.directionalIntensity = 1.1;
                    settings.directionalColor = 0xffffff;
                    settings.hemisphereIntensity = 0.35;
                    settings.hemiSkyColor = 0xdfefff;   // pale blue
                    settings.hemiGroundColor = 0xcbd5e1;
                    settings.exposure = 1.0;
                    settings.bloomStrength = 0.0;

                    // HAZE / FOG: minimal at noon
                    settings.fogColor = 0xdfe9f2;       // light blue-gray fog color
                    settings.fogNear = 150;             // push fog away so it doesn't wash the ground
                    settings.fogFar  = 3000;

                    // Physical sky scattering (if used): low haze
                    settings.skyTurbidity = 2.0;        // lower = clearer
                    settings.skyRayleigh  = 1.0;        // modest
                    settings.skyMie       = 0.0015;     // very low forward scatter
                    break;
                case 'Golden Dusk':
                    settings.elevation = 4;
                    settings.azimuth = 265;
                    settings.ambientIntensity = 0.24;
                    settings.ambientColor = 0xffddc4;
                    settings.directionalIntensity = 0.6;
                    settings.directionalColor = 0xffc694;
                    settings.hemisphereIntensity = 0.3;
                    settings.hemiSkyColor = 0xffb482;
                    settings.hemiGroundColor = 0x947e73;
                    settings.exposure = 0.9;
                    settings.fogColor = 0xffdbc2;
                    settings.skyTurbidity = 9.0;
                    settings.skyRayleigh = 2.0;
                    settings.skyMie = 0.0065;
                    break;
                case 'Starlit Night':
                default:
                    settings.elevation = -10;
                    settings.azimuth = 220;
                    settings.ambientIntensity = 0.1;
                    settings.ambientColor = 0x1a2335;
                    settings.directionalIntensity = 0.08;
                    settings.directionalColor = 0x1c2845;
                    settings.hemisphereIntensity = 0.15;
                    settings.hemiSkyColor = 0x0a1330;
                    settings.hemiGroundColor = 0x020205;
                    settings.exposure = 0.85;
                    settings.fogColor = 0x0a101b;
                    settings.starOpacity = 1.0;
                    settings.skyTurbidity = 1.2;
                    settings.skyRayleigh = 1.1;
                    settings.skyMie = 0.0008;
                    break;
            }

            setSun(settings.elevation, settings.azimuth);

            if (ambientLight) {
                ambientLight.color.setHex(settings.ambientColor);
                ambientLight.intensity = settings.ambientIntensity;
            }
            if (directionalLight) {
                directionalLight.color.setHex(settings.directionalColor);
                directionalLight.intensity = settings.directionalIntensity;
            }
            if (hemisphereLight) {
                hemisphereLight.color.setHex(settings.hemiSkyColor);
                hemisphereLight.groundColor.setHex(settings.hemiGroundColor);
                hemisphereLight.intensity = settings.hemisphereIntensity;
            }

            if (skyUniforms) {
                skyUniforms.turbidity.value = settings.skyTurbidity;
                skyUniforms.rayleigh.value = settings.skyRayleigh;
                skyUniforms.mieCoefficient.value = settings.skyMie;
                skyUniforms.mieDirectionalG.value = settings.skyMieDirectional;
            } else if (scene.background) {
                scene.background.setHex(settings.fogColor);
            }

            const showCityLights = settings.starOpacity > 0.2;
            pointLights.forEach(light => {
                light.visible = showCityLights;
            });

            if (composer && bloomPass) {
                bloomPass.strength = settings.bloomStrength;
            }

            const overrideExposure = typeof skydomePreset?.exposure === 'number'
                ? THREE.MathUtils.clamp(skydomePreset.exposure, 0.5, 2.0)
                : undefined;
            const targetExposure = Number.isFinite(overrideExposure) ? overrideExposure : settings.exposure;

            if (renderer) {
                if (Number.isFinite(targetExposure)) {
                    renderer.toneMappingExposure = targetExposure;
                }
                const fogCol = new THREE.Color(settings.fogColor);
                const fogNear = Number.isFinite(settings.fogNear) ? settings.fogNear : 600;
                const fogFar = Number.isFinite(settings.fogFar) ? settings.fogFar : 6000;
                if (fogEnabled) {
                    if (!scene.fog) {
                        scene.fog = new THREE.Fog(fogCol, fogNear, fogFar);
                    } else {
                        scene.fog.color.copy(fogCol);
                        scene.fog.near = fogNear;
                        scene.fog.far = fogFar;
                    }
                } else {
                    scene.fog = null;
                }
            }

            const fallbackEnvIntensity = presetName === 'Starlit Night'
                ? 0.7
                : (presetName === 'Blue Hour' ? 0.9 : 1.0);
            const targetEnvIntensity = typeof skydomePreset?.envIntensity === 'number'
                ? THREE.MathUtils.clamp(skydomePreset.envIntensity, 0, 5)
                : fallbackEnvIntensity;
            desiredEnvironmentIntensity = targetEnvIntensity;
            updateSceneEnvironmentIntensity();
            const featureLinesGetter = typeof window !== 'undefined' ? window.getFeatureLines : null;
            if (typeof featureLinesGetter === 'function') {
                const featureLines = featureLinesGetter();
                featureLines?.setTimeFactor?.(timeFactor);
            }

            const fallbackNightLevel = presetName === 'Starlit Night' ? 1 : (presetName === 'Blue Hour' ? 0.4 : 0);
            const targetNightAmount = typeof skydomePreset?.spaceNightAmount === 'number'
                ? THREE.MathUtils.clamp(skydomePreset.spaceNightAmount, 0, 1)
                : fallbackNightLevel;
            desiredSpaceNightAmount = targetNightAmount;
            if (spaceNight) {
                spaceNight.setAmount(skyVisible ? targetNightAmount : 0);
            }
            if (starLayerInner) {
                starLayerInner.visible = skyVisible && targetNightAmount > 0;
            }
            if (starLayerOuter) {
                starLayerOuter.visible = skyVisible && targetNightAmount > 0;
            }
            if (milkyWayMesh) {
                milkyWayMesh.visible = skyVisible && targetNightAmount > 0;
                if (!milkyWayMesh.visible && milkyWayMesh.material && typeof milkyWayMesh.material.opacity === 'number') {
                    milkyWayMesh.material.opacity = 0;
                }
            }

            const targetOpacity = typeof skydomePreset?.skydomeOpacity === 'number'
                ? THREE.MathUtils.clamp(skydomePreset.skydomeOpacity, 0, 1)
                : fallbackNightLevel;
            const shouldDelaySkydome = Boolean(
                photoSkydome && skydomePreset?.textureKey && currentPhotoSkyKey !== skydomePreset.textureKey
            );
            const activeSkyController = photoSkydome || window.__AthensSky__;
            const currentControllerOpacity = skyVisible
                ? (typeof activeSkyController?.opacity === 'number' ? activeSkyController.opacity : 0)
                : desiredSkydomeOpacity;
            if (activeSkyController) {
                const nextOpacity = shouldDelaySkydome
                    ? Math.min(currentControllerOpacity, targetOpacity)
                    : targetOpacity;
                desiredSkydomeOpacity = nextOpacity;
                if (skyVisible) {
                    activeSkyController.setAmount(nextOpacity);
                } else if (typeof activeSkyController.setAmount === 'function') {
                    activeSkyController.setAmount(0);
                }
                if (typeof skydomePreset?.yawDeg === 'number') {
                    activeSkyController.setYaw(skydomePreset.yawDeg);
                    photoSkydomeYawDeg = THREE.MathUtils.euclideanModulo(skydomePreset.yawDeg, 360);
                }
                if (scene && nextOpacity > 0 && skyVisible) {
                    scene.background = null;
                }
            }
            __level = targetOpacity;

            if (photoSkydome && skydomePreset?.textureKey && Array.isArray(skydomePreset.sources)) {
                if (currentPhotoSkyKey !== skydomePreset.textureKey) {
                    const targetKey = skydomePreset.textureKey;
                    const targetName = presetName;
                    photoSkydome.swapTexture({ sources: skydomePreset.sources })
                        .then((result) => {
                            if (!result) {
                                return;
                            }
                            const activeName = timeNames[currentTimeOfDay];
                            if (activeName !== targetName) {
                                return;
                            }
                            currentPhotoSkyKey = targetKey;
                            desiredSkydomeOpacity = targetOpacity;
                            const controller = photoSkydome || window.__AthensSky__;
                            if (controller && typeof controller.setAmount === 'function') {
                                if (skyVisible) {
                                    controller.setAmount(targetOpacity);
                                } else {
                                    controller.setAmount(0);
                                }
                            }
                            const refreshedEnv = typeof photoSkydome.refreshEnvironment === 'function'
                                ? photoSkydome.refreshEnvironment()
                                : undefined;
                            if (spaceNight && typeof spaceNight.syncDayEnvironment === 'function') {
                                spaceNight.syncDayEnvironment({
                                    environment: refreshedEnv,
                                    force: true
                                });
                            }
                            if (!skyVisible && scene) {
                                scene.background = null;
                                scene.environment = null;
                            }
                            if (result.source) {
                                const { label, url, isFallback } = result.source;
                                const description = label || url;
                                const suffix = isFallback ? ' (fallback)' : '';
                                console.info(`Photo skydome texture loaded for ${targetName}: ${description}${suffix}`);
                            }
                        })
                        .catch((error) => {
                            console.warn(`Photo skydome texture swap failed for ${targetName}:`, error);
                        });
                } else {
                    const refreshedEnv = typeof photoSkydome.refreshEnvironment === 'function'
                        ? photoSkydome.refreshEnvironment()
                        : undefined;
                    if (spaceNight && typeof spaceNight.syncDayEnvironment === 'function') {
                        spaceNight.syncDayEnvironment({
                            environment: refreshedEnv,
                            force: true
                        });
                    }
                    if (!skyVisible && scene) {
                        scene.background = null;
                        scene.environment = null;
                    }
                }
            }

            let environmentMode = 'day';
            if (presetName === 'Starlit Night' || presetName === 'Blue Hour') {
                environmentMode = 'night';
            } else if (presetName === 'Golden Dawn' || presetName === 'Golden Dusk') {
                environmentMode = 'sunset';
            }
            applyEnvironmentMode(environmentMode);
        }

        function updatePhotoSkydomeScroll(dt = 0.016) {
            if (!Number.isFinite(dt) || dt <= 0) {
                return;
            }

            const controller = photoSkydome || window.__AthensSky__;
            if (!controller || typeof controller.setYaw !== 'function' || !controller.mesh) {
                return;
            }

            const mesh = controller.mesh;
            const currentYawDeg = THREE.MathUtils.radToDeg(mesh.rotation.y);

            if (!Number.isFinite(photoSkydomeYawDeg)) {
                photoSkydomeYawDeg = currentYawDeg;
            } else {
                const normalizedDiff = Math.abs(
                    THREE.MathUtils.euclideanModulo(currentYawDeg - photoSkydomeYawDeg + 180, 360) - 180
                );
                if (normalizedDiff > 0.05) {
                    photoSkydomeYawDeg = currentYawDeg;
                }
            }

            const scrollDelta = PHOTO_SKYDOME_SCROLL_SPEED_DEG_PER_SECOND * dt;
            if (!Number.isFinite(scrollDelta) || scrollDelta === 0) {
                return;
            }

            photoSkydomeYawDeg = THREE.MathUtils.euclideanModulo(photoSkydomeYawDeg + scrollDelta, 360);
            controller.setYaw(photoSkydomeYawDeg);
        }

        function updateNightCycle(dt = 0.016) {
            if (!skyVisible) {
                if (renderer) {
                    renderer.setClearColor(0x000000, 1);
                }
                return;
            }
            if (!renderer || !sky || !sky.material || !sky.material.uniforms) {
                return;
            }

            const sunPosition = sky.material.uniforms.sunPosition.value;
            const isNight = sunPosition.y < 0.0;

            const starTarget = isNight ? 0.9 : 0.0;
            const mwTarget = isNight ? 0.35 : 0.0;

            starMaterials.forEach((material) => {
                material.opacity += (starTarget - material.opacity) * 0.02;
            });

            if (milkyWayMesh && milkyWayMesh.material) {
                milkyWayMesh.material.opacity += (mwTarget - milkyWayMesh.material.opacity) * 0.02;
            }

            if (starLayerInner) {
                starLayerInner.rotation.y += dt * 0.0007;
                starLayerInner.rotation.x += dt * 0.0002;
            }
            if (starLayerOuter) {
                starLayerOuter.rotation.y -= dt * 0.0004;
                starLayerOuter.rotation.z += dt * 0.00015;
            }

            const clearNight = 0x03050a;
            const clearDay = 0x87a6ff;
            renderer.setClearColor(isNight ? clearNight : clearDay, 1);
            if (scene.fog) {
                const dayColor = new THREE.Color(clearDay);
                const nightColor = new THREE.Color(clearNight);
                scene.fog.color.lerpColors(dayColor, nightColor, isNight ? 1 : 0);
            }
        }

        function createFountain() {
            const fountainGroup = new THREE.Group();

            // Base
            const baseGeo = new THREE.CylinderGeometry(4 * CITY_SCALE, 4 * CITY_SCALE, 0.5, 32);
            const base = new THREE.Mesh(baseGeo, stoneMaterial);
            base.receiveShadow = true;
            fountainGroup.add(base);

            // Water in base
            const waterBaseGeo = new THREE.CylinderGeometry(3.8 * CITY_SCALE, 3.8 * CITY_SCALE, 0.4, 32);
            const waterBase = new THREE.Mesh(waterBaseGeo, waterMaterial);
            waterBase.position.y = 0.2;
            fountainGroup.add(waterBase);

            // Pillar
            const pillarGeo = new THREE.CylinderGeometry(0.5 * CITY_SCALE, 0.5 * CITY_SCALE, 3, 16);
            const pillar = new THREE.Mesh(pillarGeo, marbleMaterial);
            pillar.position.y = 1.75;
            pillar.castShadow = true;
            fountainGroup.add(pillar);

            // Top Basin
            const topBasinGeo = new THREE.CylinderGeometry(1.5 * CITY_SCALE, 1.5 * CITY_SCALE, 0.3, 24);
            const topBasin = new THREE.Mesh(topBasinGeo, stoneMaterial);
            topBasin.position.y = 3.25;
            topBasin.castShadow = true;
            fountainGroup.add(topBasin);

            // Water in top basin
            const waterTopGeo = new THREE.CylinderGeometry(1.4 * CITY_SCALE, 1.4 * CITY_SCALE, 0.2, 24);
            const waterTop = new THREE.Mesh(waterTopGeo, waterMaterial);
            waterTop.position.y = 3.2;
            fountainGroup.add(waterTop);

            fountainGroup.position.set(0, 0.25, 0);
            scene.add(fountainGroup);

            // Particle System for water spray
            const particleCount = 200;
            const particlesGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3 + 0] = 0; // x
                positions[i3 + 1] = 3.5; // y
                positions[i3 + 2] = 0; // z

                particleVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 1.5,
                    Math.random() * 3 + 2,
                    (Math.random() - 0.5) * 1.5
                ));
            }

            particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xadd8e6,
                size: 0.1,
                transparent: true,
                opacity: 0.7
            });

            const fountainSpray = new THREE.Points(particlesGeo, particleMaterial);
            fountainSpray.position.copy(fountainGroup.position);
            scene.add(fountainSpray);

            const fountainSprayObject = {
                particles: fountainSpray,
                velocities: particleVelocities,
                tick: function(delta) {
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 0; i < this.velocities.length; i++) {
                        const i3 = i * 3;
                        
                        this.velocities[i].y -= 9.8 * delta * 0.5;

                        positions[i3 + 0] += this.velocities[i].x * delta;
                        positions[i3 + 1] += this.velocities[i].y * delta;
                        positions[i3 + 2] += this.velocities[i].z * delta;

                        // Reset particle if it falls below the top basin
                        if (positions[i3 + 1] < 3.3 ) {
                            positions[i3 + 0] = 0;
                            positions[i3 + 1] = 3.5;
                            positions[i3 + 2] = 0;
                            this.velocities[i].set(
                                (Math.random() - 0.5) * 1.5,
                                Math.random() * 3 + 2,
                                (Math.random() - 0.5) * 1.5
                            );
                        }
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
            };
            updatableObjects.push(fountainSprayObject);
        }
        
        function createCityFortifications() {
// Guard clause from main
if (!scene || !world) {
  return;
}

const wallSize = 80;

// City wall geometry is now generated procedurally from GeoJSON using the
// textured asset in assets/textures/wall_city.jpg. Retain the
// gatehouse structures to frame the Kerameikos approach.

// Gatehouse
const towerWidth = 8;
const towerHeight = 15;
const gateGap = 10;

const tower1 = createEnhancedBuilding(
  -gateGap,
  -wallSize,
  towerWidth,
  towerWidth,
  towerHeight,
  stoneMaterial,
  { includeDetails: false }
);
scene.add(tower1);
const tower1Body = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Box(
    new CANNON.Vec3(scaleValue(towerWidth) / 2, towerHeight / 2, scaleValue(towerWidth) / 2)
  )
});
tower1Body.position.copy(tower1.position);
world.addBody(tower1Body);

const tower2 = createEnhancedBuilding(
  gateGap,
  -wallSize,
  towerWidth,
  towerWidth,
  towerHeight,
  stoneMaterial,
  { includeDetails: false }
);
scene.add(tower2);
const tower2Body = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Box(
    new CANNON.Vec3(scaleValue(towerWidth) / 2, towerHeight / 2, scaleValue(towerWidth) / 2)
  )
});
tower2Body.position.copy(tower2.position);
world.addBody(tower2Body);

const arch = new THREE.Mesh(
  new THREE.BoxGeometry(scaleValue(gateGap * 2), 4, scaleValue(towerWidth)),
  stoneMaterial
);
setScaledPosition(arch, 0, towerHeight - 2, -wallSize);
scene.add(arch);
const archBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Box(new CANNON.Vec3(scaleValue(gateGap), 2, scaleValue(towerWidth) / 2))
});
archBody.position.copy(arch.position);
world.addBody(archBody);


            if (!cityWallGroup) {
                cityWallGroup = createCityWallPerimeter({ material: cityWallMaterial });
            }
            if (cityWallGroup && !scene.children.includes(cityWallGroup)) {
                scene.add(cityWallGroup);
            }

            if (!cityGatehouseGroup) {
                const { group, colliders } = createCityGatehouse({ material: cityWallMaterial });
                cityGatehouseGroup = group;
                if (cityGatehouseGroup) {
                    scene.add(cityGatehouseGroup);
                }
                if (Array.isArray(colliders)) {
                    colliders.forEach((collider) => {
                        if (!collider) {
                            return;
                        }
                        const { center, halfExtents, quaternion } = collider;
                        if (!center || !halfExtents) {
                            return;
                        }
                        const shape = new CANNON.Box(new CANNON.Vec3(halfExtents.x, halfExtents.y, halfExtents.z));
                        const body = new CANNON.Body({ mass: 0, shape });
                        body.position.set(center.x, center.y, center.z);
                        if (quaternion) {
                            body.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
                        }
                        world.addBody(body);
                        cityGatehouseBodies.push(body);
                    });
                }
            } else if (cityGatehouseGroup && !scene.children.includes(cityGatehouseGroup)) {
                scene.add(cityGatehouseGroup);
            }
        }
        
        function createMarketStalls() {
            const woodMaterial = createEnhancedMaterial(0x8B4513, 0.9, 0.1);
            
            function createMarketStall(x, z, color) {
                const stallGroup = new THREE.Group();

                // Posts
                const postGeo = new THREE.CylinderGeometry(0.1 * CITY_SCALE, 0.1 * CITY_SCALE, 2, 8);
                const postPositions = [
                    {x: -1.4, z: -0.9}, {x: 1.4, z: -0.9},
                    {x: -1.4, z: 0.9}, {x: 1.4, z: 0.9}
                ];
                postPositions.forEach(pos => {
                    const post = new THREE.Mesh(postGeo, woodMaterial);
                    const { x: postX, z: postZ } = scaleXZ(pos.x, pos.z);
                    post.position.set(postX, 1, postZ);
                    post.castShadow = true;
                    stallGroup.add(post);
                });

                // Tabletop
                const tableGeo = new THREE.BoxGeometry(scaleValue(3), 0.2, scaleValue(2));
                const table = new THREE.Mesh(tableGeo, woodMaterial);
                table.position.y = 1;
                table.castShadow = true;
                table.receiveShadow = true;
                stallGroup.add(table);

                // Canopy
                const canopyMat = createEnhancedMaterial(color, 0.8, 0.1);
                const canopyGeo = new THREE.PlaneGeometry(scaleValue(3.2), scaleValue(2.2));
                const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                canopy.position.y = 2.1;
                canopy.rotation.x = -Math.PI / 12;
                canopy.castShadow = true;
                stallGroup.add(canopy);

                // Goods
                for (let i = 0; i < 5; i++) {
                    const potGeo = new THREE.CylinderGeometry((Math.random() * 0.2 + 0.1) * CITY_SCALE, (Math.random() * 0.2 + 0.1) * CITY_SCALE, Math.random() * 0.4 + 0.2, 8);
                    const pot = new THREE.Mesh(potGeo, createEnhancedMaterial(0xCD853F, 0.8, 0.2));
                    const randomXZ = scaleXZ(Math.random() * 2 - 1, Math.random() * 1.5 - 0.75);
                    pot.position.set(randomXZ.x, 1.2 + pot.geometry.parameters.height / 2, randomXZ.z);
                    pot.castShadow = true;
                    stallGroup.add(pot);
                }

                setScaledPosition(stallGroup, x, 0, z);
                scene.add(stallGroup);
            }

            createMarketStall(-10, 5, 0xc23b22);
            createMarketStall(-15, 5, 0x006994);
            createMarketStall(10, 5, 0x50c878);
        }
        
        function createDemocracyMonuments() {
             const pnyx = new THREE.Group();
             for(let i=0; i<3; i++){
                const step = new THREE.Mesh(
                    new THREE.CylinderGeometry(scaleValue(15 - i*2), scaleValue(15 - i*2), 0.5, 64, 1, false, 0, Math.PI),
                    stoneMaterial
                );
                step.position.y = (i * 0.5) + 0.25;
                pnyx.add(step);
             }
             const bema = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(2),0.5,scaleValue(2)), marbleMaterial);
             bema.position.y = 1.75;
             bema.position.z = scaleValue(-12);
             pnyx.add(bema);
             setScaledPosition(pnyx, PNYX_POSITION.x, 0, PNYX_POSITION.z);
             pnyx.rotation.y = -Math.PI / 2;
             scene.add(pnyx);
             registerAmbientZone(pnyx, {
                id: 'assembly-pnyx',
                type: 'assembly',
                radius: scaleValue(35),
                maxDistance: scaleValue(220),
                volume: 0.6,
                rolloff: 2.0
             });

             const dikasteria = createEnhancedBuilding(0, -15, 8, 12, 6, marbleMaterial);
             const colonnade = new THREE.Group();
             for(let i=0; i<5; i++){
                 const column = createEnhancedColumn(6);
                 setScaledPosition(column, 0, 0, i * 2.5);
                 colonnade.add(column);
             }
             colonnade.position.set(scaleValue(4.5), -3, scaleValue(-5));
             dikasteria.add(colonnade);
             scene.add(dikasteria);
        }
        
        function createPavedRoads() {
            const panathenaicWayMaterial = pavedRoadMaterial.clone();
            if (pavedRoadMaterial.map) {
                panathenaicWayMaterial.map = pavedRoadMaterial.map.clone();
            }
            const panathenaicWay = new THREE.Mesh(
                new THREE.PlaneGeometry(scaleValue(8), scaleValue(120)),
                panathenaicWayMaterial
            );
            panathenaicWay.rotation.x = -Math.PI / 2;
            panathenaicWay.position.set(scaleValue(0), 0.01, scaleValue(-20));
            if (panathenaicWayMaterial.map) {
                panathenaicWayMaterial.map.repeat.set(2 * CITY_SCALE, 30 * CITY_SCALE);
                panathenaicWayMaterial.map.needsUpdate = true;
            }
            panathenaicWay.receiveShadow = true;
            scene.add(panathenaicWay);

            const stoaWayMaterial = pavedRoadMaterial.clone();
            if (pavedRoadMaterial.map) {
                stoaWayMaterial.map = pavedRoadMaterial.map.clone();
            }
            const stoaWay = new THREE.Mesh(
                new THREE.PlaneGeometry(scaleValue(60), scaleValue(6)),
                stoaWayMaterial
            );
            stoaWay.rotation.x = -Math.PI / 2;
            stoaWay.position.set(scaleValue(40), 0.01, scaleValue(8));
            if (stoaWayMaterial.map) {
                stoaWayMaterial.map.repeat.set(15 * CITY_SCALE, 2 * CITY_SCALE);
                stoaWayMaterial.map.needsUpdate = true;
            }
            stoaWay.receiveShadow = true;
            scene.add(stoaWay);
        }

        function createCountrysideAmbienceAnchor() {
            const countrysideAnchor = new THREE.Object3D();
            countrysideAnchor.name = 'Countryside Ambience Anchor';
            setScaledPosition(countrysideAnchor, -140, 6, 130);
            scene.add(countrysideAnchor);
            registerAmbientZone(countrysideAnchor, {
                id: 'countryside-hills',
                type: 'countryside',
                radius: scaleValue(60),
                maxDistance: scaleValue(280),
                volume: 0.65,
                rolloff: 1.6
            });
            return countrysideAnchor;
        }

        // --- NPC AND INTERACTIVE OBJECTS ---

        function brightenNPCMaterial(material, lightenAmount = 0.25, emissiveBoost = 0.25) {
            const targetColor = new THREE.Color(0xffffff);
            const applyEnhancements = (mat) => {
                if (!mat) return;

                if (mat.color && mat.color.isColor) {
                    mat.color = mat.color.clone();
                    mat.color.lerp(targetColor, lightenAmount);
                }

                if (Array.isArray(mat)) {
                    mat.forEach(applyEnhancements);
                    return;
                }

                if (mat.isMeshStandardMaterial) {
                    if (!mat.emissive || !mat.emissive.isColor) {
                        mat.emissive = new THREE.Color(0x000000);
                    } else {
                        mat.emissive = mat.emissive.clone();
                    }
                    mat.emissive.lerp(targetColor, emissiveBoost * 0.5);
                    mat.emissiveIntensity = Math.max(mat.emissiveIntensity || 0, emissiveBoost);
                    mat.envMapIntensity = Math.max(mat.envMapIntensity || 0, 1.0);
                    if (typeof mat.roughness === 'number') {
                        mat.roughness = Math.max(0, mat.roughness - 0.2);
                    }
                }

                mat.needsUpdate = true;
            };

            if (Array.isArray(material)) {
                material.forEach(applyEnhancements);
            } else {
                applyEnhancements(material);
            }
        }

        function createCitizenModel(tunicColor, type = 'citizen') {
            const citizenBody = new THREE.Group();
            const skinMaterial = createEnhancedMaterial(0xad6452, 0.7, 0.1);
            brightenNPCMaterial(skinMaterial, 0.28, 0.3);
            const tunicMaterial = createEnhancedMaterial(tunicColor, 0.8, 0.1);
            brightenNPCMaterial(tunicMaterial, 0.3, 0.32);
            const hairMaterial = createEnhancedMaterial(0x333333, 0.8, 0.1);
            brightenNPCMaterial(hairMaterial, 0.2, 0.25);

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 12), skinMaterial);
            head.position.y = 1.7;
            head.name = "head";
            citizenBody.add(head);

            // Nose
            const noseGeo = new THREE.CylinderGeometry(0.02, 0.05, 0.1, 8);
            const nose = new THREE.Mesh(noseGeo, skinMaterial);
            nose.position.z = 0.25;
            nose.position.y = -0.05;
            head.add(nose);

            // Simple Hair
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 12, 0, Math.PI * 2, 0, Math.PI / 1.8), hairMaterial);
            hair.position.y = 0.05;
            head.add(hair);

            // Eyes
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMaterial);
            eyeL.position.set(-0.1, 0.06, 0.23);
            head.add(eyeL);
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.1;
            head.add(eyeR);

            // Torso
            const torsoGeo = new THREE.CylinderGeometry(0.32, 0.37, 1.1, 12);
            const torso = new THREE.Mesh(torsoGeo, tunicMaterial);
            torso.position.y = 1.05;
            citizenBody.add(torso);

            // Limbs
            const limbGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.6, 8);
            limbGeo.translate(0, -0.3, 0); // Pivot at top

            // Left Arm
            const armL = new THREE.Mesh(limbGeo, skinMaterial);
            armL.position.set(-0.38, 1.48, 0);
            armL.name = "armL";
            citizenBody.add(armL);

            // Right Arm
            const armR = armL.clone();
            armR.position.x = 0.38;
            armR.name = "armR";
            citizenBody.add(armR);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.55, 8);
            legGeo.translate(0, -0.275, 0);

            const legL = new THREE.Mesh(legGeo, skinMaterial);
            legL.position.set(-0.16, 0.55, 0);
            legL.name = "legL";
            citizenBody.add(legL);

            const legR = legL.clone();
            legR.position.x = 0.16;
            legR.name = "legR";
            citizenBody.add(legR);

            // Feet
            const footGeo = new THREE.BoxGeometry(0.17, 0.1, 0.27);
            const sandalMaterial = createEnhancedMaterial(0x5C4033, 0.8, 0.1);
            brightenNPCMaterial(sandalMaterial, 0.25, 0.28);
            const footL = new THREE.Mesh(footGeo, sandalMaterial);
            footL.position.y = -0.27;
            footL.position.z = 0.06;
            legL.add(footL);

            const footR = footL.clone();
            legR.add(footR);

            if (type === 'scribe') {
                const scrollMat = createEnhancedMaterial(0xF5DEB3, 0.7, 0.1);
                brightenNPCMaterial(scrollMat, 0.25, 0.25);
                const scrollGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                const scroll = new THREE.Mesh(scrollGeo, scrollMat);
                scroll.rotation.z = Math.PI / 2;
                scroll.position.y = -0.2;
                armR.add(scroll);
            }

            citizenBody.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const citizenScale = 1.2;
            citizenBody.scale.setScalar(citizenScale);
            citizenBody.updateMatrixWorld(true);

            const citizenBounds = new THREE.Box3().setFromObject(citizenBody);
            const baseYOffset = -citizenBounds.min.y;

            const citizenRoot = new THREE.Group();
            citizenRoot.name = type === 'scribe' ? 'Citizen NPC (Scribe)' : 'Citizen NPC (Procedural)';
            citizenRoot.userData = {
                ...(citizenRoot.userData || {}),
                source: 'procedural_citizen',
                baseYOffset
            };

            citizenRoot.add(citizenBody);

            return citizenRoot;
        }

        function getRandomPointInZone(zone) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * zone.radius;
            return new THREE.Vector3(
                zone.center.x + Math.cos(angle) * radius,
                zone.center.y,
                zone.center.z + Math.sin(angle) * radius
            );
        }

        function chooseNewCitizenDestination(npc) {
            let target;
            let attempts = 0;
            do {
                target = getRandomPointInZone(npc.zone);
                attempts++;
            } while (target.distanceToSquared(npc.model.position) < 4 * CITY_SCALE * CITY_SCALE && attempts < 6);
            target.y = npc.baseY;
            npc.destination = target;
        }

        function createCitizenNPCs() {
            const tunicPalette = [
                0x8b5a2b,
                0x6f4d3a,
                0x3f6b4c,
                0x7f8fa6,
                0x9c755f,
                0x4d5c8b
            ];

            const registerCitizen = (model, zone, spawnPosition) => {
                const baseYOffset = model.userData?.baseYOffset ?? 0;
                model.position.copy(spawnPosition);
                model.position.y += baseYOffset;
                model.rotation.y = Math.random() * Math.PI * 2;

                const limbs = {
                    armL: model.getObjectByName('armL'),
                    armR: model.getObjectByName('armR'),
                    legL: model.getObjectByName('legL'),
                    legR: model.getObjectByName('legR')
                };

                const npc = {
                    model,
                    zone,
                    baseY: spawnPosition.y + baseYOffset,
                    speed: Math.random() * 0.6 + 0.8,
                    state: Math.random() < 0.6 ? 'walking' : 'idle',
                    walkTimer: 0,
                    idleTimer: 0,
                    walkCycle: Math.random() * Math.PI * 2,
                    animationOffset: Math.random() * Math.PI * 2,
                    destination: null,
                    limbs,
                    hasProceduralLimbs: Boolean(limbs.armL || limbs.armR || limbs.legL || limbs.legR)
                };

                chooseNewCitizenDestination(npc);
                if (npc.state === 'walking') {
                    npc.walkTimer = Math.random() * 5 + 3;
                } else {
                    npc.idleTimer = Math.random() * 3 + 2;
                }

                citizens.push(npc);
                scene.add(model);

                return npc;
            };

            const spawnProceduralCitizens = () => {
                citizenZones.forEach((zone) => {
                    for (let i = 0; i < zone.count; i++) {
                        const color = tunicPalette[Math.floor(Math.random() * tunicPalette.length)];
                        const model = createCitizenModel(color);
                        const spawnPosition = getRandomPointInZone(zone);
                        registerCitizen(model, zone, spawnPosition);
                    }
                });
            };

            loadCitizenModel()
                .then((asset) => {
                    const { baseModel, animations, scaleFactor, pivotOffset } = asset;

                    citizenZones.forEach((zone) => {
                        for (let i = 0; i < zone.count; i++) {
                            const color = tunicPalette[Math.floor(Math.random() * tunicPalette.length)];
                            const citizenRoot = new THREE.Group();
                            citizenRoot.name = 'Citizen NPC';
                            citizenRoot.userData = {
                                ...(citizenRoot.userData || {}),
                                tunicColor: color,
                                source: 'npc_athenian.glb',
                                baseYOffset: 0
                            };

                            const clonedModel = clone
                                ? clone(baseModel)
                                : baseModel.clone(true);

                            clonedModel.traverse((child) => {
                                if (!child.isMesh) return;
                                child.castShadow = true;
                                child.receiveShadow = true;
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material = child.material.map((mat) => {
                                            const clonedMaterial = mat?.clone ? mat.clone() : mat;
                                            brightenNPCMaterial(clonedMaterial, 0.3, 0.35);
                                            return clonedMaterial;
                                        });
                                    } else if (child.material.clone) {
                                        child.material = child.material.clone();
                                        brightenNPCMaterial(child.material, 0.3, 0.35);
                                    } else {
                                        brightenNPCMaterial(child.material, 0.3, 0.35);
                                    }
                                }
                            });

                            clonedModel.scale.setScalar(scaleFactor);
                            clonedModel.position.y = pivotOffset;
                            citizenRoot.add(clonedModel);

                            const spawnPosition = getRandomPointInZone(zone);
                            const npc = registerCitizen(citizenRoot, zone, spawnPosition);

                            if (Array.isArray(animations) && animations.length) {
                                const mixer = new THREE.AnimationMixer(clonedModel);
                                animations.forEach((clip) => {
                                    const action = mixer.clipAction(clip);
                                    action.play();
                                });
                                externalAnimationMixers.push(mixer);
                                npc.mixer = mixer;
                            }
                        }
                    });
                })
                .catch((error) => {
                    console.error('Failed to load Athenian citizen model, using fallback citizens.', error);
                    spawnProceduralCitizens();
                });
        }

        function createChickenModel() {
            const chicken = new THREE.Group();
            const bodyMat = createEnhancedMaterial(0xffffff, 0.8, 0.1);
            const beakMat = createEnhancedMaterial(0xffa500, 0.8, 0.1);
            const wattleMat = createEnhancedMaterial(0xff0000, 0.8, 0.1);

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 6), bodyMat);
            body.scale.y = 0.8;
            chicken.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 6), bodyMat);
            head.position.set(0, 0.2, 0.25);
            chicken.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 4), beakMat);
            beak.position.z = 0.15;
            beak.rotation.x = Math.PI / 2;
            head.add(beak);
            
            const wattle = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 4), wattleMat);
            wattle.scale.y = 1.5;
            wattle.position.set(0, -0.05, 0.1);
            head.add(wattle);

            chicken.position.y = 0.3;
            chicken.traverse(child => { if(child.isMesh) child.castShadow = true; });
            return chicken;
        }
        
        function createInteractables() {
            // Player
            player = {};
            
            // Player Physics Body
            const playerShape = new CANNON.Cylinder(0.5, 0.5, 1.8, 8);
            player.body = new CANNON.Body({ mass: 70, shape: playerShape, fixedRotation: true });
            player.body.position.set(scaleValue(0), 0.9, scaleValue(30));
            player.body.angularDamping = 0.9;
            world.addBody(player.body);

            player.movementOverride = null;

            const resolveRunDirection = (value) => {
                if (value instanceof THREE.Vector3) {
                    return value.clone();
                }

                if (Array.isArray(value)) {
                    const [x = 0, y = 0, z = 0] = value;
                    return new THREE.Vector3(
                        Number(x) || 0,
                        Number(y) || 0,
                        Number(z) || 0
                    );
                }

                if (value && typeof value === 'object') {
                    const { x = 0, y = 0, z = 0 } = value;
                    return new THREE.Vector3(
                        Number(x) || 0,
                        Number(y) || 0,
                        Number(z) || 0
                    );
                }

                if (typeof value === 'string') {
                    const normalized = value.trim().toLowerCase();
                    switch (normalized) {
                        case 'forward':
                        case 'north':
                            return new THREE.Vector3(0, 0, 1);
                        case 'back':
                        case 'backward':
                        case 'south':
                            return new THREE.Vector3(0, 0, -1);
                        case 'left':
                        case 'west':
                            return new THREE.Vector3(-1, 0, 0);
                        case 'right':
                        case 'east':
                            return new THREE.Vector3(1, 0, 0);
                        default:
                            break;
                    }
                }

                return null;
            };

            player.run = (options = {}) => {
                if (!player || !player.body) {
                    return false;
                }

                const {
                    direction,
                    world = false,
                    speed,
                    duration,
                    faceDirection = true,
                    cancelOnInput = true
                } = options || {};

                let directionVector = resolveRunDirection(direction);
                if (!directionVector) {
                    directionVector = new THREE.Vector3(0, 0, 1);
                }

                directionVector.y = 0;
                if (directionVector.lengthSq() === 0) {
                    directionVector.set(0, 0, 1);
                }
                directionVector.normalize();

                const numericSpeed = Number(speed);
                const targetSpeed = Number.isFinite(numericSpeed) && numericSpeed > 0
                    ? numericSpeed
                    : playerRunSpeed;

                const numericDuration = Number(duration);
                const runDuration = Number.isFinite(numericDuration) && numericDuration > 0
                    ? numericDuration
                    : null;

                const initialInputState = {
                    KeyW: Boolean(controls.KeyW),
                    KeyS: Boolean(controls.KeyS),
                    KeyA: Boolean(controls.KeyA),
                    KeyD: Boolean(controls.KeyD)
                };

                const hasClock = clock && typeof clock.getElapsedTime === 'function';

                player.movementOverride = {
                    type: 'run',
                    direction: directionVector.clone(),
                    useWorldSpace: Boolean(world),
                    speed: targetSpeed,
                    faceDirection: faceDirection !== false,
                    cancelOnInput: cancelOnInput !== false,
                    startedAt: hasClock ? clock.getElapsedTime() : null,
                    duration: runDuration,
                    initialInput: initialInputState
                };

                if (player.actions && player.playAction) {
                    const actionKeys = Object.keys(player.actions);
                    if (actionKeys.length) {
                        const findActionKey = (needle) => actionKeys.find(name => name === needle)
                            || actionKeys.find(name => name.includes(needle));
                        const runActionName = findActionKey('run');
                        if (runActionName) {
                            player.playAction(runActionName);
                        }
                    }
                }

                return true;
            };

            player.stopRunning = () => {
                if (player?.movementOverride?.type === 'run') {
                    player.movementOverride = null;
                }
            };

            if (typeof window !== 'undefined') {
                window.AthensPlayer = player;
            }

            // Load Animated Player Model
            const playerLoader = new GLTFLoader();
            const CHARACTER_MODEL_URL = './models/character.glb';
            playerLoader.load(CHARACTER_MODEL_URL, (gltf) => {
                const model = gltf.scene;
                if (!model) {
                    console.warn('Character model loaded without a scene.');
                    return;
                }

                player.model = model;

                model.traverse((object) => {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });

                model.scale.set(1.6, 1.6, 1.6);

                if (typeof setScaledPosition === 'function') {
                    setScaledPosition(model, 0, 0, -48);
                } else if (typeof window !== 'undefined' && typeof window.setScaledPosition === 'function') {
                    window.setScaledPosition(model, 0, 0, -48);
                } else {
                    model.position.set(0, 0, -48);
                }

                const deg = (degrees) => degrees * (Math.PI / 180);
                // model.rotation.y = deg(180);

                scene.add(model);

                player.mixer = new THREE.AnimationMixer(model);
                player.actions = {};
                gltf.animations.forEach((clip) => {
                    player.actions[clip.name.toLowerCase()] = player.mixer.clipAction(clip);
                });

                console.log('Character clips:', gltf.animations.map((clip) => clip.name));

                player.playAction = (name) => {
                    if (!name) return;
                    const key = name.toLowerCase();
                    const nextAction = player.actions[key];
                    if (!nextAction || player.currentActionName === key || !player.mixer) return;

                    if (player.currentAction) {
                        nextAction.reset().play();
                        player.currentAction.crossFadeTo(nextAction, 0.2, false);
                    } else {
                        nextAction.reset().fadeIn(0.2).play();
                    }

                    player.currentAction = nextAction;
                    player.currentActionName = key;
                };

                const actionKeys = Object.keys(player.actions);
                if (actionKeys.length > 0) {
                    const startActionName = player.actions['idle'] ? 'idle' : actionKeys[0];
                    player.defaultActionName = startActionName;
                    player.playAction(startActionName);
                } else {
                    console.warn('No animations found in the character model.');
                }

            }, undefined, (error) => {
                console.error('Failed to load character model:', error);
            });

            // Scribes
            const scribeModel1 = createCitizenModel(0x654321, 'scribe');
            const pnyxScribe = { model: scribeModel1, promptElement: document.getElementById('pnyx-scribe-prompt'), name: "Pnyx Scribe", position: scaleLocation({ x: PNYX_POSITION.x, z: PNYX_POSITION.z }), isPlayerNear: false, radius: scaleValue(5) };
            pnyxScribe.model.position.copy(pnyxScribe.position);
            interactables.push(pnyxScribe);
            scene.add(pnyxScribe.model);

            const scribeModel2 = createCitizenModel(0x654321, 'scribe');
            const bouleuterionScribe = { model: scribeModel2, promptElement: document.getElementById('bouleuterion-scribe-prompt'), name: "Bouleuterion Scribe", position: scaleLocation({ x: AGORA_FEATURES.bouleuterion.position.x + 4, z: AGORA_FEATURES.bouleuterion.position.z + 6 }), isPlayerNear: false, radius: scaleValue(5) };
            bouleuterionScribe.model.position.copy(bouleuterionScribe.position);
            interactables.push(bouleuterionScribe);
            scene.add(bouleuterionScribe.model);
            
            const scribeModel3 = createCitizenModel(0x654321, 'scribe');
            const dikasteriaScribe = { model: scribeModel3, promptElement: document.getElementById('dikasteria-scribe-prompt'), name: "Dikasteria Scribe", position: scaleLocation({ x: 0, z: -20 }), isPlayerNear: false, radius: scaleValue(5) };
            dikasteriaScribe.model.position.copy(dikasteriaScribe.position);
            interactables.push(dikasteriaScribe);
            scene.add(dikasteriaScribe.model);

            // Citizens
            createCitizenNPCs();

            // Chickens
            for(let i=0; i<10; i++) {
                const model = createChickenModel();
                const spawnPosition = getRandomWorldVector3(0, CHICKEN_WORLD_PADDING);
                const chicken = {
                    model: model,
                    speed: Math.random() * 0.8 + 0.2,
                    destination: getRandomWorldVector3(0, CHICKEN_WORLD_PADDING),
                    state: 'pecking',
                    timer: Math.random() * 5,
                    sound: null,
                    panner: null
                };
                chicken.model.position.copy(spawnPosition);
                chickens.push(chicken);
                scene.add(chicken.model);
            }
        }
        
        function createInteractiveObjects() {
            for (let i = 0; i < 10; i++) {
                const radius = Math.random() * 0.3 + 0.2;
                const height = Math.random() * 0.8 + 0.5;
                const mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius * 0.7, radius, height, 8),
                    createEnhancedMaterial(0xCD853F, 0.9, 0.1)
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const { x: barrelX, z: barrelZ } = getRandomWorldXZ(BARREL_WORLD_PADDING);
                const body = new CANNON.Body({
                    mass: 2,
                    shape: new CANNON.Cylinder(radius, radius, height, 8),
                    position: new CANNON.Vec3(barrelX, 5, barrelZ)
                });

                world.addBody(body);
                mesh.position.set(barrelX, 5, barrelZ);
                scene.add(mesh);
                physicsObjects.push({ mesh, body });
            }
        }

        // --- GAME LOGIC & ANIMATION ---
        
        const locations = [
            { name: "Temple of Hephaistos", position: scaleLocation({ x: window.AGORA_FEATURES?.templeOfHephaistos?.position?.x || 0, y: 4, z: window.AGORA_FEATURES?.templeOfHephaistos?.position?.z || 0 }), radius: scaleValue(18), title: "üõ†Ô∏è Temple of Hephaistos" },
            { name: "Stoa of Attalos", position: scaleLocation({ x: window.AGORA_FEATURES?.stoaOfAttalos?.position?.x || 0, y: 4, z: window.AGORA_FEATURES?.stoaOfAttalos?.position?.z || 0 }), radius: scaleValue(28), title: "üèõÔ∏è Stoa of Attalos" },
            { name: "Tholos", position: scaleLocation({ x: window.AGORA_FEATURES?.tholos?.position?.x || 0, y: 3, z: window.AGORA_FEATURES?.tholos?.position?.z || 0 }), radius: scaleValue(16), title: "‚öñÔ∏è The Tholos" },
            { name: "Bouleuterion", position: scaleLocation({ x: window.AGORA_FEATURES?.bouleuterion?.position?.x || 0, y: 3.5, z: window.AGORA_FEATURES?.bouleuterion?.position?.z || 0 }), radius: scaleValue(18), title: "üèõÔ∏è The Bouleuterion" },
            { name: "Altar of the Twelve Gods", position: scaleLocation({ x: window.AGORA_FEATURES?.altarOfTwelveGods?.position?.x || 0, y: 2.5, z: window.AGORA_FEATURES?.altarOfTwelveGods?.position?.z || 0 }), radius: scaleValue(14), title: "üî• Altar of the Twelve Gods" },
            { name: "Areopagus Hill", position: scaleLocation({ x: window.AREOPAGUS_POSITION?.x || 0, y: 4, z: window.AREOPAGUS_POSITION?.z || 0 }), radius: scaleValue(18), title: "ü™® Areopagus Hill" },
            { name: "Kerameikos Gate", position: scaleLocation({ x: window.KERAMEIKOS_POSITION?.x || 0, y: 3, z: window.KERAMEIKOS_POSITION?.z || 0 }), radius: scaleValue(24), title: "üö™ Kerameikos & Sacred Gate" },
            { name: "Phaleron Harbor", position: scaleLocation({ x: window.PHALERON_POSITION?.x || 0, y: 2, z: window.PHALERON_POSITION?.z || 0 }), radius: scaleValue(18), title: "‚öì Phaleron Harbor" },
            { name: "Residential Quarter", position: scaleLocation({ x: -50, y: 3, z: 5 }), radius: scaleValue(20), title: "üè° Residential Quarter" },
            { name: "Olive Grove", position: scaleLocation({ x: 35, y: 2, z: 25 }), radius: scaleValue(25), title: "üå≥ Sacred Olive Grove" }
        ];

        function updateProximityInteractions() {
            if (!player || !player.body) return;
            const currentLocationDiv = document.getElementById('current-location');
            if (!currentLocationDiv) return;

            // Location Info
            let playerInLocation = false;
            
            for (const loc of locations) {
                if (player.body.position.distanceTo(loc.position) < loc.radius) {
                    playerInLocation = true;
                     if (currentLocationDiv.innerText !== loc.title) {
                        currentLocationDiv.innerHTML = `<span class="location-badge golden-text pulse">${loc.title}</span>`;
                    }
                    break;
                }
            }
            if (!playerInLocation) {
                if (currentLocationDiv.innerText !== 'üö∂ Exploring the Outskirts') {
                    currentLocationDiv.innerHTML = `<span class="location-badge golden-text">üö∂ Exploring the Outskirts</span>`;
                }
            }
            
            // Interactable Objects
            interactables.forEach(obj => {
                if(obj.promptElement && obj.position && obj.radius) {
                    if (player.body.position.distanceTo(obj.position) < obj.radius) {
                        if (!obj.isPlayerNear) {
                            obj.isPlayerNear = true;
                            obj.promptElement.classList.add('show');
                        }
                    } else {
                        if (obj.isPlayerNear) {
                            obj.isPlayerNear = false;
                            obj.promptElement.classList.remove('show');
                        }
                    }
                }
            });
        }

        function updateEnvironment() {
            const currentName = timeNames[currentTimeOfDay];
            setTimeOfDay(currentName);
            const cycleIdx = debugSkyCycleModes.indexOf(currentName);
            if (cycleIdx !== -1) {
                debugSkyCycleIndex = cycleIdx;
            }
            updateAmbientSoundscape();
        }

        function cycleSkyPreset() {
            const current = window.getSkyPreset?.() || KNOWN_PRESETS[0];
            const currentIndex = KNOWN_PRESETS.indexOf(current);
            const nextIndex = (currentIndex + 1) % KNOWN_PRESETS.length;
            const nextPreset = KNOWN_PRESETS[nextIndex];
            window.setSkyPreset?.(nextPreset);
        }

        if (typeof window !== 'undefined') {
            window.setSkyPreset = (name) => {
                const preset = resolvePreset(name);
                const idx = timeNames.indexOf(preset);
                if (idx !== -1) {
                    currentTimeOfDay = idx;
                    updateEnvironment();
                } else {
                    setTimeOfDay(preset);
                }
                console.log('[Athens] Sky preset set to', preset);
                return preset;
            };
            window.getSkyPreset = () => window.__AthensSkyPreset || null;
        }

        function forceNightMode() {
            const nightIndex = timeNames.indexOf('Starlit Night');
            if (nightIndex !== -1) {
                currentTimeOfDay = nightIndex;
                updateEnvironment();
            }
        }

        function forceDayMode() {
            const dayIndex = timeNames.indexOf('High Noon');
            if (dayIndex !== -1) {
                currentTimeOfDay = dayIndex;
                updateEnvironment();
            }
        }
        
        function updateNPCs(delta) {
            const time = clock.getElapsedTime();

            citizens.forEach(npc => {
                if (!npc.destination) {
                    chooseNewCitizenDestination(npc);
                }

                if (npc.state === 'walking') {
                    npc.walkTimer -= delta;
                    const toTarget = npc.destination.clone().sub(npc.model.position);
                    const distance = toTarget.length();
                    const hasProceduralLimbs =
                        npc.hasProceduralLimbs ?? Boolean(
                            npc.limbs && (npc.limbs.armL || npc.limbs.armR || npc.limbs.legL || npc.limbs.legR)
                        );

                    if (distance < 0.3 || npc.walkTimer <= 0) {
                        npc.state = 'idle';
                        npc.idleTimer = Math.random() * 3 + 2;
                        npc.model.position.y = npc.baseY;
                        if (!hasProceduralLimbs) {
                            npc.model.rotation.x = THREE.MathUtils.lerp(npc.model.rotation.x, 0, 0.3);
                            npc.model.rotation.z = THREE.MathUtils.lerp(npc.model.rotation.z, 0, 0.3);
                        }
                    } else {
                        toTarget.normalize();
                        npc.model.position.addScaledVector(toTarget, npc.speed * delta);
                        npc.model.position.y = npc.baseY;

                        const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                        npc.model.rotation.y = THREE.MathUtils.lerp(npc.model.rotation.y, targetAngle, 0.15);

                        npc.walkCycle += delta * npc.speed * 4;
                        const swing = Math.sin(npc.walkCycle);
                        if (hasProceduralLimbs) {
                            if (npc.limbs.armL) npc.limbs.armL.rotation.x = swing * 0.5;
                            if (npc.limbs.armR) npc.limbs.armR.rotation.x = -swing * 0.5;
                            if (npc.limbs.legL) npc.limbs.legL.rotation.x = -swing * 0.6;
                            if (npc.limbs.legR) npc.limbs.legR.rotation.x = swing * 0.6;
                        } else {
                            const bounce = Math.abs(Math.sin(npc.walkCycle)) * 0.08;
                            npc.model.position.y = npc.baseY + bounce;
                            npc.model.rotation.z = THREE.MathUtils.lerp(npc.model.rotation.z, swing * 0.08, 0.2);
                            npc.model.rotation.x = THREE.MathUtils.lerp(
                                npc.model.rotation.x,
                                Math.cos(npc.walkCycle) * 0.04,
                                0.2
                            );
                        }
                    }
                } else {
                    npc.idleTimer -= delta;
                    const relaxFactor = Math.min(1, delta * 5);
                    const hasProceduralLimbs =
                        npc.hasProceduralLimbs ?? Boolean(
                            npc.limbs && (npc.limbs.armL || npc.limbs.armR || npc.limbs.legL || npc.limbs.legR)
                        );
                    if (hasProceduralLimbs) {
                        if (npc.limbs.armL)
                            npc.limbs.armL.rotation.x = THREE.MathUtils.lerp(
                                npc.limbs.armL.rotation.x,
                                0,
                                relaxFactor
                            );
                        if (npc.limbs.armR)
                            npc.limbs.armR.rotation.x = THREE.MathUtils.lerp(
                                npc.limbs.armR.rotation.x,
                                0,
                                relaxFactor
                            );
                        if (npc.limbs.legL)
                            npc.limbs.legL.rotation.x = THREE.MathUtils.lerp(
                                npc.limbs.legL.rotation.x,
                                0,
                                relaxFactor
                            );
                        if (npc.limbs.legR)
                            npc.limbs.legR.rotation.x = THREE.MathUtils.lerp(
                                npc.limbs.legR.rotation.x,
                                0,
                                relaxFactor
                            );
                    } else {
                        npc.model.rotation.x = THREE.MathUtils.lerp(npc.model.rotation.x, 0, relaxFactor);
                        npc.model.rotation.z = THREE.MathUtils.lerp(npc.model.rotation.z, 0, relaxFactor);
                    }

                    npc.model.position.y = npc.baseY + Math.sin(time * 1.5 + npc.animationOffset) * 0.02;

                    if (npc.idleTimer <= 0) {
                        npc.state = 'walking';
                        chooseNewCitizenDestination(npc);
                        npc.walkTimer = Math.random() * 5 + 3;
                        npc.model.position.y = npc.baseY;
                    }
                }
            });

            chickens.forEach(chicken => {
                chicken.timer -= delta;
                if (chicken.timer <= 0) {
                    if (chicken.state === 'pecking') {
                        chicken.state = 'walking';
                        chicken.destination.copy(getRandomWorldVector3(0, CHICKEN_WORLD_PADDING));
                        chicken.timer = Math.random() * 8 + 4; // walk for 4-12 seconds
                    } else {
                        chicken.state = 'pecking';
                        chicken.timer = Math.random() * 5 + 2; // peck for 2-7 seconds
                    }
                }

                if (chicken.state === 'walking') {
                    const dir = chicken.destination.clone().sub(chicken.model.position).normalize();
                    chicken.model.position.add(dir.multiplyScalar(chicken.speed * delta));
                    chicken.model.lookAt(chicken.destination);
                } else { // pecking
                    chicken.model.children[1].rotation.x = Math.sin(performance.now() * 0.01) * 0.5 + 0.5;
                    if (audioStarted && chicken.sound && canChickenCluck && Math.random() < 0.05) {
                        const now = Tone.now();
                        if (now > lastCluckTime) {
                            chicken.sound.triggerAttackRelease("C5", "8n", now);
                            lastCluckTime = now + 0.1;
                        }
                    }
                }
            });

            const hoplitePatrols = Array.isArray(window?.hoplitePatrols)
                ? window.hoplitePatrols
                : null;
            if (hoplitePatrols?.length) {
                const scratch = HOPLITE_PATROL_SCRATCH;
                const yAxis = HOPLITE_PATROL_Y_AXIS;

                hoplitePatrols.forEach((patrol) => {
                    if (!patrol?.group) {
                        return;
                    }

                    const radiusX = typeof patrol.radiusX === 'number' ? patrol.radiusX : 60;
                    const radiusZ = typeof patrol.radiusZ === 'number' ? patrol.radiusZ : radiusX;
                    const angularSpeed = typeof patrol.angularSpeed === 'number' ? patrol.angularSpeed : 0;
                    const phase = typeof patrol.phase === 'number' ? patrol.phase : 0;
                    const sampleOffset = typeof patrol.sampleOffset === 'number' ? patrol.sampleOffset : 0.05;

                    patrol.angle = (patrol.angle ?? 0) + angularSpeed * delta;
                    const angle = (patrol.angle ?? 0) + phase;

                    scratch.position.set(
                        radiusX * Math.cos(angle),
                        0,
                        radiusZ * Math.sin(angle)
                    );

                    if (patrol.rotationQuaternion instanceof THREE.Quaternion) {
                        scratch.position.applyQuaternion(patrol.rotationQuaternion);
                    } else if (typeof patrol.rotation === 'number') {
                        scratch.quaternion.setFromAxisAngle(yAxis, patrol.rotation);
                        scratch.position.applyQuaternion(scratch.quaternion);
                    }

                    if (patrol.center instanceof THREE.Vector3) {
                        scratch.position.add(patrol.center);
                    }

                    if (typeof patrol.verticalOffset === 'number') {
                        scratch.position.y += patrol.verticalOffset;
                    }

                    patrol.group.position.copy(scratch.position);

                    scratch.forward.set(
                        radiusX * Math.cos(angle + sampleOffset),
                        0,
                        radiusZ * Math.sin(angle + sampleOffset)
                    );

                    if (patrol.rotationQuaternion instanceof THREE.Quaternion) {
                        scratch.forward.applyQuaternion(patrol.rotationQuaternion);
                    } else if (typeof patrol.rotation === 'number') {
                        scratch.quaternion.setFromAxisAngle(yAxis, patrol.rotation);
                        scratch.forward.applyQuaternion(scratch.quaternion);
                    }

                    if (patrol.center instanceof THREE.Vector3) {
                        scratch.forward.add(patrol.center);
                    }

                    if (typeof patrol.verticalOffset === 'number') {
                        scratch.forward.y += patrol.verticalOffset;
                    }

                    scratch.forward.sub(scratch.position).setY(0);

                    if (scratch.forward.lengthSq() > 1e-6) {
                        patrol.group.rotation.y = Math.atan2(scratch.forward.x, scratch.forward.z);
                    }
                });
            }
        }
        
        function updateLabels() {
            interactables.forEach(npc => {
                const head = npc.model.getObjectByName("head") || npc.model;
                if (!head) return;

                const vector = new THREE.Vector3();
                head.getWorldPosition(vector);
                
                let yOffset = 0.5;
                if (npc.name === "Pnyx Scribe" || npc.name === "Bouleuterion Scribe" || npc.name === "Dikasteria Scribe") {
                    yOffset = 2.0;
                }
                if (
                    npc.model.isGroup &&
                    npc.model.children.length > 0 &&
                    npc.model.children[0].geometry &&
                    npc.model.children[0].geometry.type === "CylinderGeometry"
                ) { // Is a scroll
                    yOffset = 0.8;
                }
                vector.y += yOffset; 
                
                vector.project(camera);

                const x = (vector.x * .5 + .5) * renderer.domElement.clientWidth;
                const y = (vector.y * -.5 + .5) * renderer.domElement.clientHeight;
                
                if (npc.promptElement) {
                    npc.promptElement.style.left = `${x}px`;
                    npc.promptElement.style.top = `${y - 30}px`;
                }
            });
        }
        
        function updateSoundPositions(delta) {
            // Update listener to match camera
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            Tone.Listener.set({
                positionX: camera.position.x,
                positionY: camera.position.y,
                positionZ: camera.position.z,
                forwardX: forward.x,
                forwardY: forward.y,
                forwardZ: forward.z,
                upX: camera.up.x,
                upY: camera.up.y,
                upZ: camera.up.z
            });

            // Update sound source positions
            chickens.forEach((chicken) => {
                if (!chicken.panner) {
                    return;
                }
                chicken.panner.positionX.value = chicken.model.position.x;
                chicken.panner.positionY.value = chicken.model.position.y;
                chicken.panner.positionZ.value = chicken.model.position.z;
            });
            
        }

        function animate() {
            requestAnimationFrame(animate);
            canChickenCluck = true;

            const dt = clock.getDelta();
            const delta = dt;
            updatePerformanceStats();
            if (spaceNight) {
                spaceNight.update(dt, camera);
            }
            if (player && player.mixer) player.mixer.update(delta);
            externalAnimationMixers.forEach(m => m.update(delta));
            updateTrees(delta);

            updateFPS();
            if (player && player.body) {
                updateControls(delta);
            }
            updateProximityInteractions();
            updateLabels();
            if (audioStarted) {
                updateSoundPositions(delta);
            }

            if (ambientZoneManager) {
                ambientZoneManager.update(delta, camera.position);
            }

            updatePhotoSkydomeScroll(delta);
            updateNightCycle(delta);

            world.step(1 / 60, delta, 3);
            physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });
            
            if (player && player.body && player.model) {
                player.model.position.copy(player.body.position);
                if (player.modelOffsetY !== undefined) {
                    player.model.position.y += player.modelOffsetY;
                }
                player.model.quaternion.copy(player.body.quaternion);
            }
            
            updatableObjects.forEach(obj => obj.tick(delta));

            updateNPCs(delta);
            updateCamera();
            updateMiniMap();
            if (typeof landmarkLabelUpdater === 'function') {
                landmarkLabelUpdater(camera);
            }

            composer.render();
        }

        // --- CONTROLS ---
        async function createAmbientSounds() {
            if (crowdChatter) {
                return;
            }

            try {
                const Tone = await loadToneLibrary();
                if (!Tone) {
                    throw new Error('Tone.js is unavailable after loading.');
                }

                await Tone.start();

                if (typeof Tone.getContext === 'function') {
                    const rawContext = Tone.getContext().rawContext;
                    if (rawContext && typeof rawContext.resume === 'function' && rawContext.state === 'suspended') {
                        await rawContext.resume();
                    }
                }

                if (!masterBus) {
                    masterBus = new Tone.Volume(-8).toDestination();
                }
                if (!environmentReverb) {
                    environmentReverb = new Tone.Reverb({
                        decay: 3.8,
                        preDelay: 0.4,
                        wet: 0.35
                    }).toDestination();
                }

                Tone.Transport.bpm.value = 66;

                // Marketplace crowd bed
                crowdChatter = new Tone.Noise("pink").start();
                crowdPanner = new Tone.Panner3D({
                    positionX: marketAmbiencePosition.x,
                    positionY: marketAmbiencePosition.y,
                    positionZ: marketAmbiencePosition.z,
                });
                const crowdFilter = new Tone.AutoFilter({
                    frequency: "4m",
                    baseFrequency: 180,
                    octaves: 2.5,
                    depth: 0.6
                }).start();
                const crowdEQ = new Tone.EQ3(-10, 1, -12);
                marketVolume = new Tone.Volume(-20);
                crowdChatter.chain(crowdFilter, crowdEQ, marketVolume, crowdPanner);
                crowdPanner.connect(masterBus);
                crowdPanner.connect(environmentReverb);

                merchantSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.02, decay: 0.3, sustain: 0.15, release: 0.6 }
                });
                const merchantVibrato = new Tone.Vibrato(5, 0.2).start();
                merchantVolume = new Tone.Volume(-26);
                const merchantPanner = new Tone.Panner3D({
                    positionX: marketAmbiencePosition.x + scaleValue(4),
                    positionY: marketAmbiencePosition.y,
                    positionZ: marketAmbiencePosition.z - scaleValue(2),
                });
                merchantSynth.chain(merchantVibrato, merchantVolume, merchantPanner);
                merchantPanner.connect(masterBus);
                merchantPanner.connect(environmentReverb);

                merchantLoop = new Tone.Loop((time) => {
                    const baseNotes = ["C4", "D4", "E4", "G4"];
                    const baseNote = baseNotes[Math.floor(Math.random() * baseNotes.length)];
                    merchantSynth.triggerAttackRelease(baseNote, "8n", time, 0.35);

                    const replyDelay = Tone.Time("8n").toSeconds() * 0.75;
                    const followNote = Tone.Frequency(baseNote).transpose(5).toNote();
                    Tone.Transport.scheduleOnce((callTime) => {
                        merchantSynth.triggerAttackRelease(followNote, "8n", callTime, 0.25);
                    }, time + replyDelay);
                }, "4m").start("+1m");
                merchantLoop.probability = 0.55;

                // Fountain and water movement
                fountainNoise = new Tone.Noise("white").start();
                fountainPanner = new Tone.Panner3D({
                    positionX: fountainPosition.x,
                    positionY: fountainPosition.y,
                    positionZ: fountainPosition.z,
                });
                const fountainFilter = new Tone.Filter({
                    type: "bandpass",
                    frequency: 1200,
                    Q: 1.2
                });
                const fountainAuto = new Tone.AutoFilter({
                    frequency: 0.3,
                    baseFrequency: 900,
                    octaves: 1
                }).start();
                fountainVolume = new Tone.Volume(-28);
                fountainNoise.chain(fountainFilter, fountainAuto, fountainVolume, fountainPanner);
                fountainPanner.connect(masterBus);
                fountainPanner.connect(environmentReverb);

                // Hillside wind and trees
                windNoise = new Tone.Noise("brown").start();
                windPanner = new Tone.Panner3D({
                    positionX: hillsideWindPosition.x,
                    positionY: hillsideWindPosition.y,
                    positionZ: hillsideWindPosition.z,
                });
                const windFilter = new Tone.Filter({
                    type: "lowpass",
                    frequency: 500,
                    Q: 0.8
                });
                const windAuto = new Tone.AutoFilter({
                    frequency: 0.05,
                    baseFrequency: 200,
                    octaves: 1.5,
                    depth: 0.7
                }).start();
                const windLFO = new Tone.LFO({
                    frequency: 0.015,
                    min: 200,
                    max: 600
                }).start();
                windLFO.connect(windFilter.frequency);
                windVolume = new Tone.Volume(-32);
                windNoise.chain(windAuto, windFilter, windVolume, windPanner);
                windPanner.connect(masterBus);
                windPanner.connect(environmentReverb);

                // Temple chanting ambience
                templeChantSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" },
                    envelope: { attack: 1.5, decay: 0.5, sustain: 0.4, release: 4 }
                });
                const templeFilter = new Tone.Filter({
                    type: "lowpass",
                    frequency: 800,
                    Q: 0.7
                });
                templeVolume = new Tone.Volume(-30);
                templeChantPanner = new Tone.Panner3D({
                    positionX: templeChantPosition.x,
                    positionY: templeChantPosition.y,
                    positionZ: templeChantPosition.z,
                });
                templeChantSynth.chain(templeFilter, templeVolume, templeChantPanner);
                templeChantPanner.connect(masterBus);
                templeChantPanner.connect(environmentReverb);

                let chantIndex = 0;
                const chantChords = [
                    ["C4", "G3", "E4"],
                    ["D4", "A3", "F4"],
                    ["E4", "B3", "G4"],
                    ["G3", "D4", "B3"],
                ];
                templeChantLoop = new Tone.Loop((time) => {
                    const chord = chantChords[chantIndex % chantChords.length];
                    chantIndex++;
                    templeChantSynth.triggerAttackRelease(chord, "2m", time, 0.25);
                }, "4m").start("+0.5m");
                templeChantLoop.probability = 0.85;

                // Harbor birds
                seagullSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.05, decay: 0.2, sustain: 0.05, release: 1.5 }
                });
                const seagullVibrato = new Tone.Vibrato(7, 0.4).start();
                seagullPanner = new Tone.Panner3D({
                    positionX: harbourBirdsPosition.x,
                    positionY: harbourBirdsPosition.y,
                    positionZ: harbourBirdsPosition.z,
                });
                seagullVolume = new Tone.Volume(-32);
                seagullSynth.chain(seagullVibrato, seagullVolume, seagullPanner);
                seagullPanner.connect(masterBus);
                seagullPanner.connect(environmentReverb);

                const seagullDelay = Tone.Time("8n").toSeconds();
                seagullLoop = new Tone.Loop((time) => {
                    const baseCalls = ["A5", "B5", "C6", "D6"];
                    const base = baseCalls[Math.floor(Math.random() * baseCalls.length)];
                    seagullSynth.triggerAttackRelease(base, "8n", time, 0.35);

                    const responseNote = Tone.Frequency(base).transpose(-3).toNote();
                    Tone.Transport.scheduleOnce((callTime) => {
                        seagullSynth.triggerAttackRelease(responseNote, "4n", callTime, 0.25);
                    }, time + seagullDelay * (0.5 + Math.random() * 0.5));
                }, "6m").start("+1m");
                seagullLoop.probability = 0.4;

                // Blacksmith forge rhythm
                const blacksmithPanner = new Tone.Panner3D({
                    positionX: blacksmithPosition.x,
                    positionY: blacksmithPosition.y,
                    positionZ: blacksmithPosition.z,
                });
                const blacksmithVolume = new Tone.Volume(-20);
                blacksmithSound = new Tone.MetalSynth({
                    frequency: 150,
                    envelope: { attack: 0.001, decay: 0.35, release: 0.2 },
                    harmonicity: 8.1,
                    modulationIndex: 24,
                    resonance: 4000,
                    octaves: 1.5
                });
                blacksmithSound.chain(blacksmithVolume, blacksmithPanner);
                blacksmithPanner.connect(masterBus);
                blacksmithPanner.connect(environmentReverb);

                blacksmithLoop = new Tone.Loop((time) => {
                    const hitVelocity = 0.7 + Math.random() * 0.2;
                    blacksmithSound.triggerAttackRelease("C3", "16n", time, hitVelocity);
                    const eighth = Tone.Time("8n").toSeconds();

                    Tone.Transport.scheduleOnce((accentTime) => {
                        blacksmithSound.triggerAttackRelease("G3", "32n", accentTime, hitVelocity * 0.7);
                    }, time + eighth * (0.45 + Math.random() * 0.1));

                    Tone.Transport.scheduleOnce((finishingTime) => {
                        blacksmithSound.triggerAttackRelease("C3", "16n", finishingTime, hitVelocity * 0.9);
                    }, time + eighth * (0.95 + Math.random() * 0.1));
                }, "1m").start("+0.5m");
                blacksmithLoop.probability = 0.9;

                // Animal life around the Agora without bundling binary samples
                const createAnimalAmbience = ({ position, initialVolume, createSource, onLoop, interval, startOffset, probability }) => {
                    const { source, chain = [] } = createSource();
                    const volumeNode = new Tone.Volume(initialVolume);
                    const pannerNode = new Tone.Panner3D({
                        positionX: position.x,
                        positionY: position.y,
                        positionZ: position.z,
                    });

                    source.chain(...chain, volumeNode, pannerNode);
                    pannerNode.connect(masterBus);
                    pannerNode.connect(environmentReverb);

                    const loop = new Tone.Loop((time) => onLoop(time, source), interval).start(startOffset);
                    loop.probability = probability;

                    return {
                        source,
                        volume: volumeNode,
                        panner: pannerNode,
                        loop,
                    };
                };

                animalAmbiences = {
                    dog: createAnimalAmbience({
                        position: kennelPosition,
                        initialVolume: -28,
                        interval: "4m",
                        startOffset: "+1.5m",
                        probability: 0.35,
                        createSource: () => {
                            const synth = new Tone.MembraneSynth({
                                pitchDecay: 0.05,
                                octaves: 4,
                                oscillator: { type: "square" },
                                envelope: { attack: 0.001, decay: 0.45, sustain: 0, release: 0.3 },
                            });
                            const filter = new Tone.Filter({
                                type: "bandpass",
                                frequency: 380,
                                Q: 1.5,
                            });
                            return { source: synth, chain: [filter] };
                        },
                        onLoop: (time, synth) => {
                            const barkNote = Math.random() > 0.5 ? "G2" : "A2";
                            const barkVelocity = 0.4 + Math.random() * 0.25;
                            synth.triggerAttackRelease(barkNote, "16n", time, barkVelocity);
                            Tone.Transport.scheduleOnce((secondBarkTime) => {
                                synth.triggerAttackRelease(barkNote, "16n", secondBarkTime, barkVelocity * 0.8);
                            }, time + Tone.Time("16n").toSeconds() * (0.35 + Math.random() * 0.25));
                        },
                    }),
                    cat: createAnimalAmbience({
                        position: catAlleyPosition,
                        initialVolume: -30,
                        interval: "5m",
                        startOffset: "+2.2m",
                        probability: 0.3,
                        createSource: () => {
                            const synth = new Tone.Synth({
                                oscillator: { type: "triangle" },
                                envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.9 },
                            });
                            synth.portamento = 0.15;
                            const filter = new Tone.Filter({
                                type: "bandpass",
                                frequency: 900,
                                Q: 1.2,
                            });
                            const vibrato = new Tone.Vibrato(5, 0.12).start();
                            return { source: synth, chain: [filter, vibrato] };
                        },
                        onLoop: (time, synth) => {
                            const startNote = ["E4", "F4", "G4"][Math.floor(Math.random() * 3)];
                            const peakFrequency = Tone.Frequency(startNote).transpose(3).toFrequency();
                            const releaseDelay = 1.0 + Math.random() * 0.4;

                            synth.triggerAttack(startNote, time, 0.25);

                            Tone.Transport.scheduleOnce((glideTime) => {
                                synth.frequency.rampTo(peakFrequency, 0.4, glideTime);
                            }, time + 0.25);

                            Tone.Transport.scheduleOnce((releaseTime) => {
                                synth.triggerRelease(releaseTime);
                            }, time + releaseDelay);
                        },
                    }),
                    cow: createAnimalAmbience({
                        position: cowPasturePosition,
                        initialVolume: -28,
                        interval: "8m",
                        startOffset: "+2.8m",
                        probability: 0.45,
                        createSource: () => {
                            const synth = new Tone.AMSynth({
                                harmonicity: 0.6,
                                oscillator: { type: "sine" },
                                envelope: { attack: 0.3, decay: 0.6, sustain: 0.8, release: 2.4 },
                                modulation: { type: "triangle" },
                                modulationEnvelope: { attack: 0.2, decay: 0.4, sustain: 0.7, release: 1.6 },
                            });
                            const filter = new Tone.Filter({
                                type: "lowpass",
                                frequency: 280,
                                Q: 0.9,
                            });
                            const vibrato = new Tone.Vibrato(1.5, 0.25).start();
                            return { source: synth, chain: [filter, vibrato] };
                        },
                        onLoop: (time, synth) => {
                            const baseNote = ["C2", "D2", "A1"][Math.floor(Math.random() * 3)];
                            const dropTarget = Tone.Frequency(baseNote).transpose(-3).toFrequency();
                            const sustain = 1.8 + Math.random() * 0.9;

                            synth.triggerAttack(baseNote, time, 0.35);

                            Tone.Transport.scheduleOnce((glideTime) => {
                                synth.frequency.rampTo(dropTarget, 0.9, glideTime);
                            }, time + 0.5);

                            Tone.Transport.scheduleOnce((releaseTime) => {
                                synth.triggerRelease(releaseTime);
                            }, time + sustain);
                        },
                    }),
                };

                if (Tone.Transport.state !== "started") {
                    Tone.Transport.start();
                }

                updateAmbientSoundscape();
            } catch (error) {
                console.error('Failed to create ambient sounds:', error);
                throw error;
            }
        }

        function updateAmbientSoundscape() {
            if (typeof Tone === 'undefined') {
                return;
            }

            const now = Tone.now ? Tone.now() : 0;
            const fadeVolume = (node, value) => {
                if (!node || !node.volume) return;
                if (typeof node.volume.cancelScheduledValues === 'function') {
                    node.volume.cancelScheduledValues(now);
                }
                if (typeof node.volume.rampTo === 'function') {
                    node.volume.rampTo(value, 3);
                } else {
                    node.volume.value = value;
                }
            };

            const setLoopProbability = (loop, value) => {
                if (loop && typeof loop.probability === 'number') {
                    loop.probability = value;
                }
            };

            const animalSoundSettings = {
                0: {
                    dog: { volume: -30, probability: 0.32 },
                    cat: { volume: -34, probability: 0.22 },
                    cow: { volume: -26, probability: 0.55 },
                },
                1: {
                    dog: { volume: -26, probability: 0.4 },
                    cat: { volume: -30, probability: 0.28 },
                    cow: { volume: -22, probability: 0.65 },
                },
                2: {
                    dog: { volume: -27, probability: 0.38 },
                    cat: { volume: -26, probability: 0.4 },
                    cow: { volume: -24, probability: 0.5 },
                },
                3: {
                    dog: { volume: -24, probability: 0.5 },
                    cat: { volume: -22, probability: 0.55 },
                    cow: { volume: -32, probability: 0.18 },
                },
                4: {
                    dog: { volume: -26, probability: 0.42 },
                    cat: { volume: -24, probability: 0.45 },
                    cow: { volume: -26, probability: 0.35 },
                },
            };

            const applyAnimalSettings = (timeIndex) => {
                if (!animalAmbiences) {
                    return;
                }

                const settings = animalSoundSettings[timeIndex];
                if (!settings) {
                    return;
                }

                Object.entries(settings).forEach(([name, config]) => {
                    const animal = animalAmbiences[name];
                    if (!animal) {
                        return;
                    }

                    if (typeof config.volume === 'number') {
                        fadeVolume(animal.volume, config.volume);
                    }

                    if (typeof config.probability === 'number') {
                        setLoopProbability(animal.loop, config.probability);
                    }
                });
            };

            switch (currentTimeOfDay) {
                case 0: // Golden Dawn
                    fadeVolume(marketVolume, -24);
                    fadeVolume(merchantVolume, -32);
                    fadeVolume(fountainVolume, -24);
                    fadeVolume(windVolume, -28);
                    fadeVolume(templeVolume, -26);
                    fadeVolume(seagullVolume, -28);
                    setLoopProbability(merchantLoop, 0.35);
                    setLoopProbability(seagullLoop, 0.45);
                    setLoopProbability(blacksmithLoop, 0.65);
                    applyAnimalSettings(0);
                    break;
                case 1: // Bright Noon
                    fadeVolume(marketVolume, -16);
                    fadeVolume(merchantVolume, -22);
                    fadeVolume(fountainVolume, -20);
                    fadeVolume(windVolume, -30);
                    fadeVolume(templeVolume, -24);
                    fadeVolume(seagullVolume, -24);
                    setLoopProbability(merchantLoop, 0.75);
                    setLoopProbability(seagullLoop, 0.55);
                    setLoopProbability(blacksmithLoop, 0.95);
                    applyAnimalSettings(1);
                    break;
                case 2: // Crimson Sunset
                    fadeVolume(marketVolume, -18);
                    fadeVolume(merchantVolume, -26);
                    fadeVolume(fountainVolume, -21);
                    fadeVolume(windVolume, -26);
                    fadeVolume(templeVolume, -22);
                    fadeVolume(seagullVolume, -30);
                    setLoopProbability(merchantLoop, 0.45);
                    setLoopProbability(seagullLoop, 0.35);
                    setLoopProbability(blacksmithLoop, 0.8);
                    applyAnimalSettings(2);
                    break;
                case 3: // Starlit Night
                    fadeVolume(marketVolume, -34);
                    fadeVolume(merchantVolume, -40);
                    fadeVolume(fountainVolume, -24);
                    fadeVolume(windVolume, -24);
                    fadeVolume(templeVolume, -18);
                    fadeVolume(seagullVolume, -40);
                    setLoopProbability(merchantLoop, 0.15);
                    setLoopProbability(seagullLoop, 0.2);
                    setLoopProbability(blacksmithLoop, 0.35);
                    applyAnimalSettings(3);
                    break;
                case 4: // Blue Hour
                default:
                    fadeVolume(marketVolume, -22);
                    fadeVolume(merchantVolume, -30);
                    fadeVolume(fountainVolume, -22);
                    fadeVolume(windVolume, -25);
                    fadeVolume(templeVolume, -20);
                    fadeVolume(seagullVolume, -32);
                    setLoopProbability(merchantLoop, 0.25);
                    setLoopProbability(seagullLoop, 0.3);
                    setLoopProbability(blacksmithLoop, 0.55);
                    applyAnimalSettings(4);
                    break;
            }
        }

        function initializeChickenAudio() {
            chickens.forEach((chicken) => {
                if (chicken.sound) {
                    return;
                }

                const panner = new Tone.Panner3D();
                const synth = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
                });

                synth.volume.value = -14;
                synth.connect(panner);

                if (masterBus && environmentReverb) {
                    panner.connect(masterBus);
                    panner.connect(environmentReverb);
                } else {
                    panner.toDestination();
                }

                panner.positionX.value = chicken.model.position.x;
                panner.positionY.value = chicken.model.position.y;
                panner.positionZ.value = chicken.model.position.z;
                chicken.sound = synth;
                chicken.panner = panner;
            });
        }

        function addEventListeners() {
            const startButton = document.getElementById('start-button');
            const startOverlay = document.getElementById('start-overlay');
            let startSequenceInProgress = false;

            const hideStartOverlay = () => {
                if (!startOverlay) {
                    return;
                }

                if (!startOverlay.classList.contains('fade-out')) {
                    startOverlay.classList.add('fade-out');
                }

                const finalize = () => {
                    if (startOverlay.style.display !== 'none') {
                        startOverlay.style.display = 'none';
                    }
                };

                const onTransitionEnd = (event) => {
                    if (event?.target === startOverlay) {
                        finalize();
                    }
                };

                startOverlay.addEventListener('transitionend', onTransitionEnd, { once: true });

                window.setTimeout(() => {
                    finalize();
                    startOverlay.removeEventListener('transitionend', onTransitionEnd);
                }, 1200);
            };

            const startExperience = async () => {
                if (startSequenceInProgress) {
                    return;
                }

                startSequenceInProgress = true;

                hideStartOverlay();

                try {
                    await loadToneLibrary();
                } catch (error) {
                    console.warn('Unable to preload Tone.js before starting the experience:', error);
                }

                // Start the main Athens experience
                try {
                    console.log('Starting Athens experience...');
                    await initializeAthens();
                } catch (error) {
                    console.error('Failed to start Athens experience:', error);
                    // Don't return here - still try to initialize audio
                }

                if (audioStarted || audioStartInProgress) {
                    startSequenceInProgress = false;
                    return;
                }

                audioStartInProgress = true;
                try {
                    const tonePromise = (async () => {
                        await createAmbientSounds();
                        initializeChickenAudio();
                    })();
                    const zonePromise = ambientZoneManager?.resume?.() ?? Promise.resolve();

                    const [toneResult, zoneResult] = await Promise.allSettled([tonePromise, zonePromise]);

                    if (zoneResult?.status === 'rejected') {
                        console.warn('Unable to resume ambient zone audio context:', zoneResult.reason);
                    }

                    if (ambientZoneManager) {
                        ambientZoneManager.setEnabled(true);
                        ambientZoneManager.update(0, camera.position);
                    }

                    if (toneResult.status === 'fulfilled') {
                        audioStarted = true;
                        console.log("Audio context started.");
                    } else if (toneResult.status === 'rejected') {
                        console.warn('Unable to start audio context:', toneResult.reason);
                    }
                } catch (error) {
                    console.warn('Unable to start audio systems:', error);
                } finally {
                    audioStartInProgress = false;
                    startSequenceInProgress = false;
                }
            };

            const triggerStartExperience = () => {
                startExperience().catch((error) => {
                    console.error('Unexpected error while starting the experience:', error);
                });
            };

            const isStartOverlayVisible = () => {
                if (!startOverlay) {
                    return false;
                }

                if (startOverlay.style.display === 'none') {
                    return false;
                }

                if (startOverlay.classList?.contains?.('fade-out')) {
                    return false;
                }

                return true;
            };

            if (startButton && startOverlay) {
                startButton.addEventListener('pointerdown', () => {
                    loadToneLibrary().catch(() => {
                        // Preloading can fail if the user releases the pointer early; retry on click.
                    });
                });
                startButton.addEventListener('click', triggerStartExperience);
            } else {
                console.warn('Start overlay elements are missing; skipping overlay binding.');
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                const linesGetter = typeof window !== 'undefined' ? window.getFeatureLines : null;
                if (typeof linesGetter === 'function') {
                    const lines = linesGetter();
                    const canvas = renderer?.domElement;
                    const width = canvas?.width ?? window.innerWidth;
                    const height = canvas?.height ?? window.innerHeight;
                    lines?.setResolution?.(width, height);
                }
            });

            document.addEventListener('keydown', (e) => {
                if (!startSequenceInProgress && isStartOverlayVisible()) {
                    const key = e.key || e.code;
                    const normalizedKey = key === ' ' ? 'Space' : key;
                    if (normalizedKey === 'Enter' || normalizedKey === 'Space' || e.code === 'Space') {
                        if (e.repeat) {
                            e.preventDefault();
                            return;
                        }

                        e.preventDefault();
                        triggerStartExperience();
                        return;
                    }
                }

                if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    e.preventDefault();
                }
                if (e.shiftKey && e.code === 'KeyP') {
                    if (e.repeat) {
                        return;
                    }
                    e.preventDefault();
                    toggleStatsVisibility();
                    return;
                }
                if (e.shiftKey && (e.key === 'S' || e.key === 's')) {
                    if (e.repeat) {
                        return;
                    }
                    e.preventDefault();
                    cycleSkyPreset();
                    return;
                }
                controls[e.code] = true;
                if (e.code === 'KeyD' || e.code === 'KeyN') {
                    toggleKeyTimestamps[e.code] = performance.now();
                }
                if ((e.key || '').toLowerCase() === 'l') {
                    const getter = typeof window !== 'undefined' ? window.getFeatureLines : null;
                    if (e.shiftKey) {
                        let nextFactor = 0;
                        if (typeof window !== 'undefined') {
                            window.__fl_t = (window.__fl_t ?? 0);
                            window.__fl_t = (window.__fl_t + 0.25) % 1;
                            nextFactor = window.__fl_t;
                        }
                        const featureLines = typeof getter === 'function' ? getter() : null;
                        featureLines?.setTimeFactor?.(nextFactor);
                        console.log('FeatureLines timeFactor =', nextFactor);
                        return;
                    }
                    if (typeof getter === 'function') {
                        const featureLines = getter();
                        const root = featureLines?.root;
                        if (root && typeof featureLines.setVisible === 'function') {
                            featureLines.setVisible(!root.visible);
                        }
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                controls[e.code] = false;
                if (e.code === 'KeyN') {
                    if (skipNightHotkeyOnce) {
                        skipNightHotkeyOnce = false;
                    } else {
                        forceNightMode();
                    }
                    delete toggleKeyTimestamps[e.code];
                }
                if (e.code === 'KeyD') {
                    const downTime = toggleKeyTimestamps[e.code];
                    if (!downTime || performance.now() - downTime < 250) {
                        forceDayMode();
                    }
                    delete toggleKeyTimestamps[e.code];
                }
                if(e.code === 'KeyE') {
                    for(const obj of interactables) {
                        if(obj.isPlayerNear && obj.promptElement) {
                            obj.promptElement.querySelector('button').click();
                            break;
                        }
                    }
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                if(e.code === 'KeyT') {
                    currentTimeOfDay = (currentTimeOfDay + 1) % timeNames.length;
                    updateEnvironment();
                }
                if(e.code === 'KeyF') {
                    fogEnabled = !fogEnabled;
                    if (!fogEnabled) {
                        scene.fog = null;
                    }
                    updateEnvironment();
                }
                if(e.code === 'KeyX') {
                    isFlying = !isFlying;
                    if (player && player.body) {
                        player.body.velocity.set(0, 0, 0);
                        if (player.body.force) {
                            player.body.force.set(0, 0, 0);
                        }
                    }
                }
                if(e.code === 'KeyL') {
                    enhancedLighting = !enhancedLighting;
                    // Adjust base intensities if needed
                    updateEnvironment();
                }
                if(e.code === 'KeyM') {
                    soundEnabled = !soundEnabled;
                    const tone = window.Tone;
                    if (tone && typeof tone.getDestination === 'function') {
                        tone.getDestination().mute = !soundEnabled;
                    }
                }
                if(e.code === 'KeyP') {
                    document.getElementById('fps-counter').classList.toggle('show');
                }
            });

            window.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                if (e.key === ';') {
                    districtFillsVisible = !districtFillsVisible;
                    setDistrictFillsVisible(districtFillsVisible);
                    return;
                }
                if (e.key === "'") {
                    districtOutlinesVisible = !districtOutlinesVisible;
                    setDistrictOutlinesVisible(districtOutlinesVisible);
                    return;
                }
                if (e.key === '/') {
                    districtDustBiasEnabled = !districtDustBiasEnabled;
                    if (groundMesh?.userData?.setDistrictDustBiasEnabled) {
                        groundMesh.userData.setDistrictDustBiasEnabled(districtDustBiasEnabled);
                    }
                    return;
                }
                if (e.key === 'k' || e.key === 'K') {
                    e.preventDefault();
                    toggleSkyVisibility();
                    console.info(`Sky visibility ${skyVisible ? 'enabled' : 'disabled'}.`);
                    return;
                }
                const sky = window.__AthensSky__;
                if (e.key === '[' || e.key === ']') {
                    if (!sky) return;
                    const delta = e.key === '[' ? -5 : 5;
                    const currentYawDeg = THREE.MathUtils.radToDeg(sky.mesh.rotation.y);
                    sky.setYaw(currentYawDeg + delta);
                    return;
                }
                if (!sky || !skyVisible) {
                    return;
                }
                if (e.key && e.key.toLowerCase() === 'n' && !e.shiftKey && !e.altKey && !e.metaKey) {
                    e.preventDefault();
                    debugSkyCycleIndex = (debugSkyCycleIndex + 1) % debugSkyCycleModes.length;
                    const targetMode = debugSkyCycleModes[debugSkyCycleIndex];
                    const nightAmount = debugSkyLevels[debugSkyCycleIndex] ?? 0;
                    const idx = timeNames.indexOf(targetMode);
                    if (idx !== -1) {
                        currentTimeOfDay = idx;
                        updateEnvironment();
                    } else {
                        sky.setAmount(nightAmount);
                    }
                    console.log('Night amount:', nightAmount);
                    skipNightHotkeyOnce = true;
                }
            });

            document.getElementById('close-info-scroll').addEventListener('click', () => {
                document.getElementById('info-scroll-overlay').classList.remove('show');
            });
            
            document.querySelectorAll('.prompt .gemini-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const infoType = e.target.dataset.info;
                    if (infoType) {
                        showInfoScroll(infoType);
                    }
                });
            });

            document.getElementById('toggle-hud').addEventListener('click', () => {
                const hud = document.getElementById('hud');
                const button = document.getElementById('toggle-hud');
                hud.classList.toggle('hidden');
                if (hud.classList.contains('hidden')) {
                    button.textContent = 'Show UI';
                } else {
                    button.textContent = 'Hide UI';
                }
            });

            const miniMapToggle = document.getElementById('mini-map-toggle');
            const miniMapWrapper = document.getElementById('mini-map-wrapper');
            if (miniMapToggle && miniMapWrapper) {
                miniMapToggle.addEventListener('click', () => {
                    const isCollapsed = miniMapWrapper.classList.toggle('collapsed');
                    miniMapToggle.textContent = isCollapsed ? 'Show Map' : 'Hide Map';
                    miniMapToggle.setAttribute('aria-expanded', String(!isCollapsed));
                    miniMapToggle.setAttribute('aria-pressed', String(!isCollapsed));
                });
            }
        }
        
        function updateControls(delta) {
            if (!player || !player.body) return;

            // Handle rotation
            if (controls.KeyA) {
                player.body.angularVelocity.y = playerRotationSpeed;
            } else if (controls.KeyD) {
                player.body.angularVelocity.y = -playerRotationSpeed;
            } else {
                 player.body.angularVelocity.y = 0;
            }

            // Handle movement
            let movementOverride = player.movementOverride && player.movementOverride.type === 'run'
                ? player.movementOverride
                : null;

            if (movementOverride && movementOverride.duration != null) {
                const hasClock = clock && typeof clock.getElapsedTime === 'function';
                if (hasClock && movementOverride.startedAt != null) {
                    const elapsed = clock.getElapsedTime() - movementOverride.startedAt;
                    if (elapsed >= movementOverride.duration) {
                        player.movementOverride = null;
                        movementOverride = null;
                    }
                }
            }

            if (movementOverride && movementOverride.cancelOnInput) {
                const initial = movementOverride.initialInput || {};
                const inputChanged =
                    Boolean(controls.KeyW) !== initial.KeyW ||
                    Boolean(controls.KeyS) !== initial.KeyS ||
                    Boolean(controls.KeyA) !== initial.KeyA ||
                    Boolean(controls.KeyD) !== initial.KeyD;

                if (inputChanged) {
                    player.movementOverride = null;
                    movementOverride = null;
                }
            }

            const moveDirection = new THREE.Vector3();
            if (movementOverride) {
                moveDirection.copy(movementOverride.direction);
            } else {
                if (controls.KeyS) moveDirection.z -= 1;
                if (controls.KeyW) moveDirection.z += 1;
            }

            const hasHorizontalInput = moveDirection.lengthSq() > 0;
            const isMovingFromControls = Boolean(controls.KeyS || controls.KeyW);
            const wantsToRun = controls.ShiftLeft || controls.ShiftRight;
            const isMoving = movementOverride ? hasHorizontalInput : isMovingFromControls;
            const shouldUseRunAnimation = movementOverride
                ? hasHorizontalInput
                : Boolean(!isFlying && isMovingFromControls && wantsToRun);
            const currentGroundSpeed = movementOverride
                ? (movementOverride.speed ?? playerRunSpeed)
                : (shouldUseRunAnimation ? playerRunSpeed : playerWalkSpeed);

            if (player) {
                player.isRunning = shouldUseRunAnimation;
            }

            if (player && player.actions && player.playAction) {
                const actionKeys = Object.keys(player.actions);
                if (actionKeys.length) {
                    const findActionKey = (needle) => actionKeys.find(name => name === needle) || actionKeys.find(name => name.includes(needle));
                    const walkActionName = findActionKey('walk');
                    const runActionName = findActionKey('run');
                    const idleActionName = findActionKey('idle');
                    const fallbackActionName = player.defaultActionName || actionKeys[0];
                    const targetActionName = isMoving
                        ? (shouldUseRunAnimation
                            ? (runActionName || walkActionName || fallbackActionName)
                            : (walkActionName || runActionName || fallbackActionName))
                        : (idleActionName || walkActionName || runActionName || fallbackActionName);

                    if (targetActionName) {
                        player.playAction(targetActionName);
                    }
                }
            }

            const playerQuaternion = new THREE.Quaternion(
                player.body.quaternion.x,
                player.body.quaternion.y,
                player.body.quaternion.z,
                player.body.quaternion.w
            );

            if (hasHorizontalInput) {
                moveDirection.normalize();
                if (movementOverride) {
                    if (!movementOverride.useWorldSpace) {
                        moveDirection.applyQuaternion(playerQuaternion);
                    }
                } else {
                    moveDirection.applyQuaternion(playerQuaternion);
                }
            } else {
                moveDirection.set(0, 0, 0);
            }

            if (movementOverride && movementOverride.faceDirection !== false && hasHorizontalInput) {
                const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                RUN_ALIGNMENT_QUATERNION.setFromAxisAngle(RUN_ALIGNMENT_AXIS, targetAngle);
                playerQuaternion.slerp(RUN_ALIGNMENT_QUATERNION, 0.2);
                player.body.quaternion.set(
                    playerQuaternion.x,
                    playerQuaternion.y,
                    playerQuaternion.z,
                    playerQuaternion.w
                );
            }

            if (isFlying) {
                if (player.body.force) {
                    player.body.force.y += -world.gravity.y * player.body.mass;
                }

                let verticalVelocity = 0;
                if (controls.Space) verticalVelocity += flightVerticalSpeed;
                if (controls.ShiftLeft || controls.ShiftRight) verticalVelocity -= flightVerticalSpeed;

                const flightVelocity = new CANNON.Vec3(
                    moveDirection.x * flightSpeed,
                    verticalVelocity,
                    moveDirection.z * flightSpeed
                );

                if (player.body.velocity) {
                    player.body.velocity.copy(flightVelocity);
                }
            } else {
                const currentVelocity = new CANNON.Vec3(
                    moveDirection.x * currentGroundSpeed,
                    player.body.velocity.y,
                    moveDirection.z * currentGroundSpeed
                );

                if (player.body.velocity) {
                    player.body.velocity.copy(currentVelocity);
                }

                if (!movementOverride && !controls.KeyW && !controls.KeyS) {
                    player.body.velocity.x = 0;
                    player.body.velocity.z = 0;
                }
            }

            // Camera orbit
            if (controls.ArrowUp) cameraOffset.y += 2 * delta;
            if (controls.ArrowDown) cameraOffset.y -= 2 * delta;
            if (controls.ArrowLeft) cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), 2 * delta);
            if (controls.ArrowRight) cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), -2 * delta);

            cameraOffset.y = Math.max(1, Math.min(5, cameraOffset.y)); // Clamp camera height

        }
        
        function updateCamera() {
            if (!player || !player.body || !player.model) return;

            const playerPosition = new THREE.Vector3(
                player.body.position.x,
                player.body.position.y,
                player.body.position.z
            );
            
            const cameraTargetPosition = playerPosition.clone().add(cameraOffset);

            camera.position.lerp(cameraTargetPosition, 0.2);

            const lookAtPosition = playerPosition.clone();
            lookAtPosition.y += 1.5;

            camera.lookAt(lookAtPosition);
        }

        function addMiniMapDot(category, worldPos) {
            const mapContainer = document.getElementById('mini-map-container');
            if (!mapContainer || !worldPos) {
                return null;
            }

            const worldWidth = mapBounds.xMax - mapBounds.xMin;
            const worldDepth = mapBounds.zMax - mapBounds.zMin;
            if (worldWidth === 0 || worldDepth === 0) {
                return null;
            }

            const safeCategory = (category ?? 'cultural').toString().toLowerCase();
            const normalizedCategory = ['democracy', 'cultural', 'natural'].includes(safeCategory)
                ? safeCategory
                : 'cultural';

            const icon = document.createElement('div');
            icon.className = `map-icon map-icon-${normalizedCategory}`;

            const mapWidth = 200;
            const mapHeight = 200;
            const percentX = THREE.MathUtils.clamp((worldPos.x - mapBounds.xMin) / worldWidth, 0, 1);
            const percentZ = THREE.MathUtils.clamp((worldPos.z - mapBounds.zMin) / worldDepth, 0, 1);

            icon.style.left = `${percentX * mapWidth}px`;
            icon.style.top = `${percentZ * mapHeight}px`;

            mapContainer.appendChild(icon);
            return icon;
        }

        function createMapIcons() {
            const allLocations = [
                ...locations.map(l => ({...l, type: (l.type || 'cultural')})),
                { name: 'Pnyx', position: scaleLocation({ x: PNYX_POSITION.x, z: PNYX_POSITION.z }), type: 'democracy' },
                { name: 'Dikasteria', position: scaleLocation({ x: 0, z: -15 }), type: 'democracy' },
                { name: 'Bouleuterion', position: scaleLocation({ x: AGORA_FEATURES.bouleuterion.position.x, z: AGORA_FEATURES.bouleuterion.position.z }), type: 'democracy' }
            ];

            allLocations.forEach(loc => {
                if (!loc || !loc.position) {
                    return;
                }

                addMiniMapDot(loc.type, loc.position);
            });
        }

        async function setupLandmarks() {
            try {
                const { loadLandmarks } = await import('./src/landmarks-loader.js');

                const projectorInstance = window?.AthensGeo?.projector;
                const projectorFn = projectorInstance && typeof projectorInstance.project === 'function'
                    ? (lon, lat) => {
                        const { x, y } = projectorInstance.project({ lat, lon });
                        return new THREE.Vector3(scaleValue(x), 0, scaleValue(y));
                    }
                    : null;

                const { groups, update } = await loadLandmarks({
                    scene,
                    geoJsonUrl: './data/athens_places.geojson',
                    projector: projectorFn,
                    onPoint: (feature, pin, worldPos) => {
                        const props = feature.properties || {};
                        const name = props.title || props.name || 'Unnamed';
                        const rawCategory = (props.category || 'cultural').toString().toLowerCase();
                        const category = ['democracy', 'cultural', 'natural'].includes(rawCategory) ? rawCategory : 'cultural';

                        const normalizedName = name.toLowerCase();
                        if (normalizedName === 'parthenon' || normalizedName === 'the parthenon') {
                            locations.push({
                                name: 'The Parthenon',
                                position: worldPos.clone(),
                                radius: scaleValue(30),
                                title: 'üèõÔ∏è The Parthenon',
                                type: category
                            });
                            addMiniMapDot(category, worldPos);
                            return;
                        }

                        locations.push({
                            name,
                            position: worldPos.clone(),
                            radius: scaleValue(12),
                            title: `üìç ${name}`,
                            type: category
                        });

                        addMiniMapDot(category, worldPos);
                    }
                });

                landmarkGroups = groups;
                landmarkLabelUpdater = update;

                if (landmarkGroups?.democracy) landmarkGroups.democracy.visible = true;
                if (landmarkGroups?.cultural) landmarkGroups.cultural.visible = true;
                if (landmarkGroups?.natural) landmarkGroups.natural.visible = true;

                window.AthensLandmarks = { groups, update };
            } catch (error) {
                console.error('Failed to load landmarks:', error);
            }
        }

        function updateMiniMap() {
            if (!player || !player.body || !player.model) return;

            const playerIcon = document.getElementById('map-player');
            const mapWidth = 200;
            const mapHeight = 200;
            const worldWidth = mapBounds.xMax - mapBounds.xMin;
            const worldDepth = mapBounds.zMax - mapBounds.zMin;

            let percentX = (player.body.position.x - mapBounds.xMin) / worldWidth;
            let percentZ = (player.body.position.z - mapBounds.zMin) / worldDepth;
            percentX = THREE.MathUtils.clamp(percentX, 0, 1);
            percentZ = THREE.MathUtils.clamp(percentZ, 0, 1);

            let mapX = percentX * mapWidth;
            let mapY = percentZ * mapHeight;

            playerIcon.style.left = `${mapX}px`;
            playerIcon.style.top = `${mapY}px`;
            
            const euler = new THREE.Euler().setFromQuaternion(player.body.quaternion, 'YXZ');
            playerIcon.style.transform = `translate(-50%, -50%) rotate(${-(euler.y)}rad)`;
        }

        function showInfoScroll(type) {
            const info = infoData[type];
            if (info) {
                document.getElementById('info-title').textContent = info.title;
                document.getElementById('info-text').innerHTML = info.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                document.getElementById('info-scroll-overlay').classList.add('show');
            }
        }

        function notifyInitializerReady(initializer) {
            if (typeof window === 'undefined' || typeof window.dispatchEvent !== 'function') {
                return;
            }

            const detail = { initializer };

            try {
                window.dispatchEvent(new CustomEvent('athens:initializer-ready', { detail }));
                return;
            } catch (error) {
                if (typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                    try {
                        const event = document.createEvent('CustomEvent');
                        event.initCustomEvent('athens:initializer-ready', false, false, detail);
                        window.dispatchEvent(event);
                        return;
                    } catch (innerError) {
                        console.debug('[Athens] Unable to dispatch initializer-ready event (fallback).', innerError);
                    }
                } else {
                    console.debug('[Athens] Unable to dispatch initializer-ready event.', error);
                }
            }
        }

        }
</script>
<script type="module">
  // Step 1: Import the file to run it. This creates the safe 
  // `window.Athens.boot` function that we can use.
  import './src/core/bootstrap.js';

  // Step 2: Prepare your custom options, just like you did.
  const baseOptions = window.__AthensOptions || {};
  const startupOptions = { preset: 'High Noon', ...baseOptions };

  // Step 3: Call the SAFE, public function with your custom options.
  window.Athens.boot(startupOptions);

  // Step 4: Re-add your reboot hotkey.
  // This part of your code was already perfect!
  document.addEventListener('keydown', (event) => {
    if (event.shiftKey && (event.key === 'B' || event.key === 'b')) {
      console.clear();
      console.log('Rebooting Athens‚Ä¶');
      const rebootOptions = window.__AthensOptions || {};
      window.Athens?.boot?.({ preset: 'High Noon', ...rebootOptions });
    }
  });
</script>
<script type="module">
    // SAFETY: turn undefined / single value into an array so .map() never crashes
const asArray = (v) => (Array.isArray(v) ? v : (v == null ? [] : [v]));

        import { loadGeoJson } from './src/geo/geoLoader.js';
        import { LocalEquirectangularProjection } from './src/geo/projection.js';

        const origin = { lat: 37.9715379, lon: 23.7266531 }; // Parthenon
        const rotationDegrees = 0;
        const projector = new LocalEquirectangularProjection({ origin, rotationDegrees });

        loadGeoJson()
            .then((geoJson) => {
                if (!geoJson || !Array.isArray(geoJson.features)) {
                    console.warn('GeoJSON file did not contain any features to transform.');
                    return;
                }

                console.group('Athens GeoJSON ‚Üí local meters');
                geoJson.features
                    .filter((feature) => feature?.geometry?.type === 'Point')
                    .forEach((feature) => {
                        const [lon, lat] = feature.geometry.coordinates;
                        const { x, y } = projector.project({ lat, lon });
                        const name = feature.properties?.title || feature.properties?.name || 'Unnamed feature';
                        console.log(name, { x, y, lat, lon });
                    });
                console.groupEnd();
            })
            .catch((error) => {
                console.error('Failed to load Athens GeoJSON data', error);
            });

        window.AthensGeo = {
            projector,
            setRotation: (degrees) => projector.setRotation(degrees)
        };
       
  // if your file lives at data/athens_places.geojson in the repo, this keeps it safe on GitHub Pages:
</script>
<script type="module">
  import { createLandmarkOverlay, LandmarkOverlay } from './src/map/landmarks.js';

  function waitForWorldBuilt() {
    if (typeof window === 'undefined') {
      return Promise.resolve();
    }
    if (window.athensWorldBuilt && window.scene && window.renderer) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const handler = () => {
        window.removeEventListener('athens-world-built', handler);
        resolve();
      };
      window.addEventListener('athens-world-built', handler, { once: true });
    });
  }

  const overlayCanvas = document.getElementById('landmarks-canvas');

  if (overlayCanvas) {
    try {
      await waitForWorldBuilt();
      const options = {
        geoJsonUrl: './data/athens_places.geojson',
        agoraDataUrl: './data/agora_local.json',
        showAgoraLayer: true,
        markerFill: '#FFD700',
        markerStroke: '#704c00',
        fitPadding: 48
      };

      let overlay = null;
      if (typeof createLandmarkOverlay === 'function') {
        overlay = createLandmarkOverlay(overlayCanvas, options);
        if (overlay && typeof overlay.then === 'function') {
          overlay = await overlay;
        }
      }

      if (!overlay) {
        const overlayNamespace = typeof window !== 'undefined' ? window.AthensMap : undefined;
        const OverlayClass = LandmarkOverlay || overlayNamespace?.LandmarkOverlay;
        if (OverlayClass) {
          overlay = new OverlayClass(overlayCanvas, options);
        }
      }

      if (overlay && typeof overlay.initialize === 'function') {
        const initResult = overlay.initialize();
        if (initResult && typeof initResult.then === 'function') {
          await initResult;
        }
      }

      if (overlay && typeof window !== 'undefined') {
        window.AthensLandmarkOverlay = overlay;
      }
    } catch (error) {
      console.error('Landmark overlay failed to initialize:', error);
    }
  } else {
    console.warn('landmarks-canvas not found; overlay disabled.');
  }
</script>
<script type="module">
        import THREE from './src/three.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { clone } from 'three/examples/jsm/utils/SkeletonUtils.js';
        import { retargetBuildingMaterials } from './src/scene/materials.js';
        import { resolveAssetUrl } from './src/utils/asset-paths.js';

        const waitForWorld = () => {
            if (window.athensWorldBuilt && window.scene && window.renderer) {
                return Promise.resolve();
            }
            return new Promise((resolve) => {
                const handler = () => {
                    if (window.scene && window.renderer) {
                        window.removeEventListener('athens-world-built', handler);
                        resolve();
                    }
                };
                window.addEventListener('athens-world-built', handler);
            });
        };

        const applyMeshEnhancements = (root, renderer) => {
            const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy
                ? renderer.capabilities.getMaxAnisotropy()
                : null;

            root.traverse((child) => {
                if (!child.isMesh) return;

                child.castShadow = true;
                child.receiveShadow = true;

                const materials = Array.isArray(child.material) ? child.material : [child.material];
                materials.forEach((material) => {
                    if (!material) return;
                    ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'aoMap', 'emissiveMap'].forEach((key) => {
                        const texture = material[key];
                        if (texture && maxAnisotropy) {
                            texture.anisotropy = Math.max(texture.anisotropy || 0, maxAnisotropy);
                            texture.needsUpdate = true;
                        }
                    });
                });
            });
        };

        const placeObject = (object, x, y, z) => {
            if (typeof window.setScaledPosition === 'function') {
                window.setScaledPosition(object, x, y, z);
            } else {
                object.position.set(x, y, z);
            }
        };

        const getBuildingMaterialSet = () =>
            typeof window !== 'undefined' ? window.buildingMaterialSet || null : null;

        const resolveParthenonAnchor = (scene) => {
            const fallbackCenter = (() => {
                const defaultCenter = new THREE.Vector3(120, 0, -90);
                if (typeof window.setScaledPosition === 'function') {
                    const dummy = new THREE.Object3D();
                    window.setScaledPosition(dummy, defaultCenter.x, defaultCenter.y, defaultCenter.z);
                    return dummy.position.clone();
                }
                return defaultCenter;
            })();

            const fallbackRotation = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 1, 0),
                THREE.MathUtils.degToRad(15)
            );

            const fallback = {
                center: fallbackCenter,
                rotationQuaternion: fallbackRotation,
                radiusX: 90,
                radiusZ: 60,
                groundY: fallbackCenter.y
            };

            if (!scene) {
                return fallback;
            }

            let parthenonNode = null;
            scene.traverse((object) => {
                if (parthenonNode) {
                    return;
                }
                const label = (object.userData?.monument || object.name || '').toString().toLowerCase();
                if (label.includes('parthenon')) {
                    parthenonNode = object;
                }
            });

            if (!parthenonNode) {
                return fallback;
            }

            if (typeof parthenonNode.updateWorldMatrix === 'function') {
                parthenonNode.updateWorldMatrix(true, true);
            }

            const center = new THREE.Vector3();
            parthenonNode.getWorldPosition(center);

            const rotationQuaternion = new THREE.Quaternion();
            parthenonNode.getWorldQuaternion(rotationQuaternion);

            const bounds = new THREE.Box3().setFromObject(parthenonNode);
            if (!bounds.isEmpty()) {
                const size = new THREE.Vector3();
                bounds.getSize(size);
                const radiusX = Math.max(size.x * 0.5 + 12, 45);
                const radiusZ = Math.max(size.z * 0.5 + 12, 35);
                center.y = bounds.min.y;
                return {
                    center,
                    rotationQuaternion,
                    radiusX,
                    radiusZ,
                    groundY: bounds.min.y
                };
            }

            return {
                center,
                rotationQuaternion,
                radiusX: fallback.radiusX,
                radiusZ: fallback.radiusZ,
                groundY: center.y
            };
        };

        const createParthenonPatrols = ({
            scene,
            renderer,
            baseModel,
            animations,
            mixers,
            startIndex = 0
        }) => {
            const patrols = [];
            window.hoplitePatrols = patrols;

            if (!scene || !baseModel) {
                return [];
            }

            const anchor = resolveParthenonAnchor(scene);
            const worldCenter = anchor.center.clone();
            if (Number.isFinite(anchor.groundY)) {
                worldCenter.y = anchor.groundY;
            }

            const orientation = anchor.rotationQuaternion instanceof THREE.Quaternion
                ? anchor.rotationQuaternion.clone()
                : new THREE.Quaternion();

            const radiusX = Math.max(Math.abs(anchor.radiusX) || 0, 45);
            const radiusZ = Math.max(Math.abs(anchor.radiusZ) || 0, 35);
            const phases = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
            const speeds = [0.22, 0.18, 0.2];
            const sampleOffset = 0.05;
            const groups = [];

            phases.forEach((phase, index) => {
                const hopliteGroup = new THREE.Group();
                const hoplite = clone
                    ? clone(baseModel)
                    : baseModel.clone(true);

                hoplite.scale.set(1.2, 1.2, 1.2);
                hopliteGroup.add(hoplite);

                hopliteGroup.name = `Parthenon Patrol ${index + 1}`;
                hopliteGroup.userData = {
                    ...(hopliteGroup.userData || {}),
                    hopliteRole: 'Parthenon Patrol',
                    hopliteIndex: startIndex + index,
                    isParthenonPatrol: true
                };

                applyMeshEnhancements(hopliteGroup, renderer);
                scene.add(hopliteGroup);
                groups.push(hopliteGroup);

                if (Array.isArray(animations) && animations.length) {
                    const mixer = new THREE.AnimationMixer(hoplite);
                    animations.forEach((clip) => {
                        mixer.clipAction(clip).play();
                    });
                    mixers.push(mixer);
                }

                const patrol = {
                    group: hopliteGroup,
                    center: worldCenter.clone(),
                    radiusX,
                    radiusZ,
                    rotationQuaternion: orientation.clone(),
                    verticalOffset: 0.3,
                    angularSpeed: speeds[index % speeds.length],
                    phase,
                    angle: 0,
                    sampleOffset
                };

                const initialAngle = phase;
                const position = new THREE.Vector3(
                    radiusX * Math.cos(initialAngle),
                    0,
                    radiusZ * Math.sin(initialAngle)
                );
                if (patrol.rotationQuaternion instanceof THREE.Quaternion) {
                    position.applyQuaternion(patrol.rotationQuaternion);
                }
                position.add(patrol.center);
                if (typeof patrol.verticalOffset === 'number') {
                    position.y += patrol.verticalOffset;
                }
                hopliteGroup.position.copy(position);

                const forward = new THREE.Vector3(
                    radiusX * Math.cos(initialAngle + sampleOffset),
                    0,
                    radiusZ * Math.sin(initialAngle + sampleOffset)
                );
                if (patrol.rotationQuaternion instanceof THREE.Quaternion) {
                    forward.applyQuaternion(patrol.rotationQuaternion);
                }
                forward.add(patrol.center);
                if (typeof patrol.verticalOffset === 'number') {
                    forward.y += patrol.verticalOffset;
                }
                forward.sub(position).setY(0);
                if (forward.lengthSq() > 1e-6) {
                    hopliteGroup.rotation.y = Math.atan2(forward.x, forward.z);
                }

                patrols.push(patrol);
            });

            return groups;
        };

        const hoplitePlacements = [
            {
                name: 'Agora Hoplite',
                position: { x: -1090.575, y: 0, z: 950.573 },
                rotation: Math.PI / 3
            },
            {
                name: 'Acropolis Hoplite',
                position: { x: 115.092, y: 0, z: -85.479 },
                rotation: -Math.PI / 2
            },
            {
                name: 'Pnyx Hoplite',
                position: { x: -1643.722, y: 0, z: 623.381 },
                rotation: (3 * Math.PI) / 4
            },
            {
                name: 'Areopagus Hoplite',
                position: { x: 2161.233, y: 0, z: -1655.909 },
                rotation: Math.PI / 8
            },
            {
                name: 'Kerameikos Hoplite',
                position: { x: 1398.34, y: 0, z: -708.156 },
                rotation: -Math.PI / 4
            }
        ];

        await waitForWorld();

        const { scene, renderer } = window;
        if (!scene || !renderer) {
            console.error('THREE.js scene was not initialized before loading models.');
            throw new Error('Scene not ready');
        }

        const gltfLoader = new GLTFLoader();
        const BUILDING_MODEL_PATH =
            typeof window !== 'undefined' && window.BUILDING_MODEL_PATH
                ? window.BUILDING_MODEL_PATH
                : resolveAssetUrl('assets/models/buildings/');

        const loadModelWithFallback = (paths, onSuccess, onFailure) => {
            if (!Array.isArray(paths) || paths.length === 0) {
                console.warn('No model paths provided for loading.');
                return;
            }

            let attemptIndex = 0;

            const tryLoad = () => {
                const currentPath = paths[attemptIndex];
                gltfLoader.load(
                    currentPath,
                    (gltf) => {
                        if (typeof onSuccess === 'function') {
                            onSuccess(gltf, currentPath);
                        }
                    },
                    undefined,
                    (error) => {
                        attemptIndex += 1;
                        if (attemptIndex < paths.length) {
                            const nextPath = paths[attemptIndex];
                            console.info(
                                `Model not available at ${currentPath}. Trying fallback: ${nextPath}.`,
                                error
                            );
                            tryLoad();
                        } else {
                            console.error(
                                `Model failed to load after attempting: ${paths.join(', ')}.`,
                                error
                            );
                            if (typeof onFailure === 'function') {
                                onFailure(error, currentPath);
                            }
                        }
                    }
                );
            };

            tryLoad();
        };

        const loadTemple = () => {
            loadModelWithFallback(
                [`${BUILDING_MODEL_PATH}temple_doric_medium.glb`],
                (gltf) => {
                    const templeGroup = new THREE.Group();
                    const temple = gltf.scene || new THREE.Group();
                    temple.scale.set(3, 3, 3);
                    templeGroup.add(temple);
                    const buildingMaterialSet = getBuildingMaterialSet();
                    if (typeof retargetBuildingMaterials === 'function') {
                        retargetBuildingMaterials(templeGroup, buildingMaterialSet || undefined);
                    }
                    applyMeshEnhancements(templeGroup, renderer);
                    placeObject(templeGroup, 90, 0, 35);
                    scene.add(templeGroup);
                },
                (error) => {
                    console.error('Error loading Greek temple model:', error);
                }
            );
        };

        const loadHopliteGuards = () => {
            window.hoplitePatrols = [];
            loadModelWithFallback(
                [
                    './models/hoplite_npc.glb',
                    './models/npc_athenian.glb',
                    './models/Adventurer.glb',
                    './models/character.glb'
                ],
                (gltf, modelPath) => {
                    const baseModel = gltf.scene || new THREE.Group();
                    const mixers = window.externalAnimationMixers || (window.externalAnimationMixers = []);
                    const hopliteGroups = [];

                    hoplitePlacements.forEach((placement, index) => {
                        const hopliteGroup = new THREE.Group();
                        const hoplite = clone
                            ? clone(baseModel)
                            : baseModel.clone(true);

                        hoplite.scale.set(1.2, 1.2, 1.2);
                        hopliteGroup.add(hoplite);

                        if (typeof placement.rotation === 'number') {
                            hopliteGroup.rotation.y = placement.rotation;
                        }

                        hopliteGroup.name = placement.name || `Hoplite Guard ${index + 1}`;
                        hopliteGroup.userData = {
                            ...hopliteGroup.userData,
                            hopliteRole: placement.name,
                            hopliteIndex: index
                        };

                        applyMeshEnhancements(hopliteGroup, renderer);

                        const { x, y = 0, z } = placement.position;
                        placeObject(hopliteGroup, x, y, z);
                        scene.add(hopliteGroup);
                        hopliteGroups.push(hopliteGroup);

                        if (Array.isArray(gltf.animations) && gltf.animations.length) {
                            const mixer = new THREE.AnimationMixer(hoplite);
                            gltf.animations.forEach((clip) => {
                                mixer.clipAction(clip).play();
                            });
                            mixers.push(mixer);
                        }
                    });

                    const patrolGroups = createParthenonPatrols({
                        scene,
                        renderer,
                        baseModel,
                        animations: gltf.animations,
                        mixers,
                        startIndex: hoplitePlacements.length
                    });
                    if (Array.isArray(patrolGroups) && patrolGroups.length) {
                        hopliteGroups.push(...patrolGroups);
                    }

                    window.hopliteNPCs = hopliteGroups;

                    const patrolCount = Array.isArray(window.hoplitePatrols)
                        ? window.hoplitePatrols.length
                        : 0;
                    const totalCount = hopliteGroups.length;
                    const patrolNote = patrolCount
                        ? ` (including ${patrolCount} Parthenon patrol${patrolCount === 1 ? '' : 's'})`
                        : '';
                    console.info(
                        `Hoplite NPC model loaded from ${modelPath} and deployed at ${totalCount} locations${patrolNote}.`
                    );
                },
                (error) => {
                    console.error('Hoplite NPC model failed to load after all fallback attempts.', error);
                }
            );
        };

        loadTemple();
        loadHopliteGuards();
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const serviceWorkerUrl = new URL('service-worker.js', window.location.href);
                const scopeUrl = new URL('./', window.location.href);

                navigator.serviceWorker
                    .register(serviceWorkerUrl.pathname.startsWith('/') ? serviceWorkerUrl.pathname : serviceWorkerUrl.toString(), {
                        scope: scopeUrl.pathname.startsWith('/') ? scopeUrl.pathname : scopeUrl.toString()
                    })
                    .catch((error) => {
                        console.warn('Service worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
