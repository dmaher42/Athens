<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Athens - Visual Masterpiece</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <!-- Physics and Post-processing libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js",
            "three/examples/jsm/objects/Sky.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/objects/Sky.js"
        }
    }
    </script>
    <script type="module">
        import { Sky } from 'three/examples/jsm/objects/Sky.js';

        // Fallback to ensure THREE is available globally when CDN fails
        async function ensureThreeJS() {
            if (typeof window.THREE !== 'undefined') {
                console.log('THREE.js loaded from CDN');
                return window.THREE;
            }

            try {
                console.log('Attempting to load THREE.js via ES modules...');
                const THREE = await import('three');
                window.THREE = THREE;
                console.log('THREE.js loaded via ES modules as fallback');
                return THREE;
            } catch (error) {
                console.warn('Failed to load THREE.js via modules:', error);
                return null;
            }
        }

        // Ensure THREE is available before the main script runs
        window.Sky = Sky;
        window.threeJSReady = ensureThreeJS();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(5px);
            transition: opacity 1s ease;
        }

        .overlay-button {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
            border: 2px solid rgba(255, 215, 0, 1);
            color: #ffffff;
            font-family: 'Cinzel', serif;
            padding: 15px 30px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);
            margin-top: 20px;
        }
        .overlay-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7), 0 0 60px rgba(255, 215, 0, 0.5);
        }
        
        #fps-counter {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 100;
            border: 1px solid rgba(0, 255, 0, 0.3);
            display: none; /* Hidden by default */
        }
         #fps-counter.show {
            display: block;
        }
        
        canvas {
            display: block;
            border-radius: 0;
        }
        
        .golden-text {
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            font-family: 'Cinzel', serif;
        }
        
        .elegant-text {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 300;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        .control-key {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-weight: 600;
            color: #FFD700;
        }
        
        .gemini-button {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            font-family: 'Cinzel', serif;
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            width: 100%;
        }

        .gemini-button:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 215, 0, 0.2));
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        .gemini-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .prompt {
            position: absolute;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            width: 220px;
            text-align: center;
            transform: translate(-50%, -100%);
        }
        .prompt.show {
            opacity: 1;
            pointer-events: all;
        }

        .info-scroll-overlay, .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .info-scroll-overlay.show, .modal-overlay.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .info-content, .modal-content {
            background: #fdf6e3;
            color: #584b3e;
            padding: 40px 60px;
            border-radius: 5px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Cormorant Garamond', serif;
            font-size: 20px;
            line-height: 1.7;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.2);
            border: 10px solid #c9b78e;
            position: relative;
        }
        .close-info {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #8b795e;
        }
        
        .modal-content textarea {
            width: 100%;
            height: 80px;
            margin-top: 15px;
            background: #ece5d8;
            border: 1px solid #c9b78e;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 18px;
        }
         .modal-content .gemini-response {
            margin-top: 15px;
            padding: 15px;
            background: #ece5d8;
            border-radius: 5px;
            border-left: 3px solid #c9b78e;
            font-style: italic;
            min-height: 50px;
        }


        #hud {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 50%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            color: white;
            transition: transform 0.4s ease-in-out;
            font-size: 14px;
        }

        #hud.hidden {
            transform: translateY(100%);
        }

        #hud h3 {
            margin: 0;
        }

        #hud-left, #hud-center, #hud-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #hud-center {
            font-family: 'Helvetica', Arial, sans-serif;
            font-size: 13px;
            opacity: 0.8;
        }

        #hud-right {
            text-align: right;
        }

        #toggle-hud {
            position: absolute;
            bottom: calc(100% - 1px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 18px;
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        #toggle-hud:hover {
            background: rgba(0,0,0,0.8);
        }

        #mini-map-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #FFD700;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            z-index: 101;
        }
        #map-player {
            position: absolute;
            width: 10px;
            height: 10px;
            background: yellow;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
         #map-player::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -100%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid yellow;
        }
        .map-icon {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .map-icon-democracy { background-color: #4dabf7; }
        .map-icon-cultural { background-color: #FFD700; }
        .map-icon-natural { background-color: #28a745; }
    </style>
</head>
<body>
    <div id="start-overlay">
        <button id="start-button" class="overlay-button">Enter Ancient Athens</button>
    </div>
    
    <div id="fps-counter">FPS: <span id="fps-value">60</span></div>
    
    <div id="hud">
        <div id="hud-left">
            <div id="mini-map-container">
                 <div id="map-player"></div>
            </div>
            <h3 style="margin: 0; font-size: 20px; margin-left: 220px;" class="golden-text">⚱️ Ancient Athens</h3>
            <div id="current-location"></div>
        </div>
        <div id="hud-center" class="elegant-text">
            <span class="control-key">WASD</span> Move/Rotate |
            <span class="control-key">Arrows</span> Orbit Camera |
            <span class="control-key">E</span> Interact |
            <span class="control-key">X</span> Toggle Flight |
            <span class="control-key">Space</span>/<span class="control-key">Shift</span> Fly Up/Down |
            <span class="control-key">M</span> Sound |
            <span class="control-key">P</span> FPS
        </div>
        <div id="hud-right" class="elegant-text">
            <div class="golden-text" style="font-weight: 600;">🌅 Time:</div>
            <span id="current-time">Golden Dawn</span>
        </div>
        <button id="toggle-hud">Hide UI</button>
    </div>

    <!-- Character Interaction UI -->
    <div id="pnyx-scribe-prompt" class="prompt">
        <button class="gemini-button" data-info="pnyx">📜 Learn about the Pnyx</button>
    </div>
     <div id="bouleuterion-scribe-prompt" class="prompt">
        <button class="gemini-button" data-info="bouleuterion">📜 Learn about the Bouleuterion</button>
    </div>
     <div id="dikasteria-scribe-prompt" class="prompt">
        <button class="gemini-button" data-info="dikasteria">📜 Learn about the Dikasteria</button>
    </div>
    <div id="info-scroll-overlay" class="info-scroll-overlay">
        <div class="info-content">
            <button id="close-info-scroll" class="close-info">&times;</button>
            <h4 id="info-title" class="golden-text" style="text-align: center; margin-bottom: 20px;"></h4>
            <p id="info-text"></p>
        </div>
        
    </div>
    <canvas id="landmarks-canvas"
        style="position:fixed; right:16px; top:16px; width:420px; height:420px; z-index:150;
               border:1px solid #FFD700; border-radius:10px; background:rgba(0,0,0,.18);">
</canvas>


    <script>
        console.log("🏛️ Initializing Enhanced Ancient Athens Experience...");

        // --- Space Night module: Milky Way skybox + dust + nebulas -----------------
        let milkyWayTex = null;
        let spaceGroup = null;
        let savedDayBackground = null;

        function loadMilkyWay(renderer) {
            if (milkyWayTex) return milkyWayTex;
            const urls = [
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_px.jpg',
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_nx.jpg',
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_py.jpg',
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_ny.jpg',
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_pz.jpg',
                'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/cube/MilkyWay/dark-s_nz.jpg'
            ];
            const loader = new THREE.CubeTextureLoader();
            milkyWayTex = loader.load(urls, (tex) => {
                if ('colorSpace' in tex && 'SRGBColorSpace' in THREE) tex.colorSpace = THREE.SRGBColorSpace;
            });
            return milkyWayTex;
        }

        function makeSpaceDust(count = 15000, spread = { x: 40000, y: 10000, z: 40000 }) {
            const geo = new THREE.BufferGeometry();
            const pts = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                pts[i * 3 + 0] = (Math.random() - 0.5) * spread.x;
                pts[i * 3 + 1] = (Math.random() - 0.5) * spread.y;
                pts[i * 3 + 2] = (Math.random() - 0.5) * spread.z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xaaaaaa, size: 1.4, transparent: true, opacity: 0.55,
                depthWrite: false, blending: THREE.AdditiveBlending
            });
            const dust = new THREE.Points(geo, mat);
            dust.frustumCulled = false;
            return dust;
        }

        function makeNebulas(textureLoader, howMany = 10) {
            const group = new THREE.Group();
            const baseMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/cloud.png', (t) => {
                if ('colorSpace' in t && 'SRGBColorSpace' in THREE) t.colorSpace = THREE.SRGBColorSpace;
            });
            for (let i = 0; i < howMany; i++) {
                const mat = new THREE.SpriteMaterial({
                    map: baseMap, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
                    opacity: 0.22, color: new THREE.Color().setHSL(Math.random(), 0.5, 0.7)
                });
                const s = Math.random() * 2000 + 1500;
                const spr = new THREE.Sprite(mat);
                spr.scale.set(s, s, 1);
                spr.position.set(
                    (Math.random() - 0.5) * 25000,
                    (Math.random() - 0.5) * 5000,
                    (Math.random() - 0.5) * 25000 - 1000
                );
                spr.material.rotation = Math.random() * Math.PI;
                spr.frustumCulled = false;
                group.add(spr);
            }
            return group;
        }

        function initSpaceNight({ scene, renderer, textureLoader, camera }) {
            if (camera && camera.far < 50000) {
                camera.far = 50000;
                camera.updateProjectionMatrix();
            }

            savedDayBackground = scene.background || null;

            spaceGroup = new THREE.Group();
            spaceGroup.name = 'SpaceNightFX';
            const dust = makeSpaceDust();
            const nebulas = makeNebulas(textureLoader);
            spaceGroup.add(dust, nebulas);

            spaceGroup.traverse(o => {
                if (o.material) {
                    o.material.fog = false;
                    o.renderOrder = -100;
                }
            });

            spaceGroup.visible = false;
            scene.add(spaceGroup);

            loadMilkyWay(renderer);

            return {
                update(dt, camera) {
                    if (!spaceGroup) return;
                    spaceGroup.children.forEach((o, i) => {
                        if (o.isPoints) o.rotation.y += dt * 0.002;
                        if (o.isSprite) o.material.rotation += (i % 2 ? 1 : -1) * dt * 0.05;
                    });
                    if (camera) {
                        spaceGroup.position.lerp(camera.position, 0.05);
                    }
                },
                setAmount(nightAmount) {
                    if (!spaceGroup) return;
                    if (nightAmount > 0.6) {
                        scene.background = milkyWayTex || savedDayBackground;
                        spaceGroup.visible = true;
                        spaceGroup.traverse(o => { if (o.material?.opacity !== undefined) o.material.opacity = THREE.MathUtils.lerp(0.0, 1.0, nightAmount); });
                    } else {
                        spaceGroup.visible = nightAmount > 0.0;
                        spaceGroup.traverse(o => { if (o.material?.opacity !== undefined) o.material.opacity = nightAmount; });
                        scene.background = savedDayBackground;
                    }
                }
            };
        }

        // Wait for THREE.js to be available before proceeding
        async function initializeAthens() {
            if (window.threeJSReady) {
                await window.threeJSReady;
            }
            
            if (typeof THREE === 'undefined') {
                console.error('THREE.js is not available. Please ensure external resources can be loaded.');
                document.body.innerHTML = '<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;font-family:Arial,sans-serif;color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:10px;"><h2>🏛️ Ancient Athens</h2><p>External libraries are required to run this experience.<br>Please allow external resources or use a different environment.</p><p><small>THREE.js library could not be loaded.</small></p></div>';
                return;
            }

            console.log('THREE.js is ready, initializing Athens...');
            main();
        }

        function main() {
        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, composer, ambientLight, directionalLight, hemisphereLight, player;
        let world;
        let controls = { W: false, A: false, S: false, D: false, E: false, ShiftLeft: false, ShiftRight: false, Space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
        const toggleKeyTimestamps = {};
        const playerSpeed = 8.0;
        const playerRotationSpeed = 3.0;
        const flightSpeed = 10.0;
        const flightVerticalSpeed = 8.0;
        const CITY_SCALE = 2;
        const scaleValue = (value) => value * CITY_SCALE;
        const scaleLocation = ({ x, y = 0, z }) => new THREE.Vector3(scaleValue(x), y, scaleValue(z));
        const scaleXZ = (x, z) => ({ x: scaleValue(x), z: scaleValue(z) });
        const scaledVector3 = (x, y, z) => scaleLocation({ x, y, z });
        const setScaledPosition = (object, x, y, z) => {
            object.position.set(scaleValue(x), y, scaleValue(z));
        };
        const GEO_TO_SCENE_MATRIX = Object.freeze({
            a: 0.1990872551715,
            b: -0.05643461237683576,
            c: -0.1365997066329714,
            d: 0.05987080329678062,
            tx: 94.87890378320046,
            tz: -70.43723980152546
        });

        const PROJECTED_GEO_POINTS = Object.freeze({
            acropolis: { x: 97.80053937706748, y: -75.48139950406926 },
            agora: { x: -3216.492436155211, y: 9847.555926499888 },
            pnyx: { x: -15502.191082680132, y: -23548.291311453097 },
            areopagus: { x: 8191.656307060039, y: -7963.562600419857 },
            kerameikos: { x: 9946.756113702198, y: 12073.945742354728 },
            phaleron: { x: -1788.1200260881237, y: -3775.8251193131027 },
            peiraeus: { x: -7198.027872715054, y: -3785.5099150114647 }
        });

        const applyGeoToScene = ({ x, y }) => ({
            x: GEO_TO_SCENE_MATRIX.a * x + GEO_TO_SCENE_MATRIX.b * y + GEO_TO_SCENE_MATRIX.tx,
            z: GEO_TO_SCENE_MATRIX.c * x + GEO_TO_SCENE_MATRIX.d * y + GEO_TO_SCENE_MATRIX.tz
        });

        const applyGeoOffsetToScene = ({ x, y }) => ({
            x: GEO_TO_SCENE_MATRIX.a * x + GEO_TO_SCENE_MATRIX.b * y,
            z: GEO_TO_SCENE_MATRIX.c * x + GEO_TO_SCENE_MATRIX.d * y
        });

        const AGORA_ANCHOR_SCENE = applyGeoToScene(PROJECTED_GEO_POINTS.agora);
        const ACROPOLIS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.acropolis);
        const PNYX_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.pnyx);
        const AREOPAGUS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.areopagus);
        const KERAMEIKOS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.kerameikos);
        const PHALERON_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.phaleron);
        const PEIRAEUS_POSITION = applyGeoToScene(PROJECTED_GEO_POINTS.peiraeus);

        const transformAgoraOffset = (offset) => {
            const delta = applyGeoOffsetToScene(offset);
            return {
                x: AGORA_ANCHOR_SCENE.x + delta.x,
                z: AGORA_ANCHOR_SCENE.z + delta.z
            };
        };

        const AGORA_FEATURES = {
            templeOfHephaistos: {
                position: transformAgoraOffset({ x: -78, y: 72 }),
                rotation: -17 * Math.PI / 180
            },
            stoaOfAttalos: {
                position: transformAgoraOffset({ x: 64, y: 6 }),
                rotation: 5 * Math.PI / 180
            },
            tholos: {
                position: transformAgoraOffset({ x: -32, y: -38 }),
                rotation: 0
            },
            bouleuterion: {
                position: transformAgoraOffset({ x: -55, y: -24 }),
                rotation: -12 * Math.PI / 180
            },
            altarOfTwelveGods: {
                position: transformAgoraOffset({ x: 6, y: 52 }),
                rotation: 4 * Math.PI / 180
            }
        };

        const LONG_WALL_DIRECTION = Math.atan2(
            PEIRAEUS_POSITION.x - KERAMEIKOS_POSITION.x,
            PEIRAEUS_POSITION.z - KERAMEIKOS_POSITION.z
        );

        // --- LOAD THE GREEK TEMPLE GLB ---
        function loadGreekTemple() {
          const loader = new THREE.GLTFLoader();
          const url = './models/greek_temple.glb'; // path is relative to index.html
          console.log('Loading GLB:', url);

          loader.load(
            url,
            (gltf) => {
              const model = gltf.scene || gltf.scenes?.[0];
              if (!model) { console.warn('GLB loaded but no scene found'); return; }

              // Make sure it’s visible, lit, and casts/receives shadows
              model.traverse((obj) => {
                if (obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; }
              });

              // Tweak these if it’s tiny/huge or off-camera
              model.scale.set(10, 10, 10);
              setScaledPosition(model, 15, 0, -55); // near the Acropolis you built
              model.rotation.y = 5;

              scene.add(model);
              console.log('Temple GLB added to scene ✔️');
            },
            undefined,
            (err) => {
              console.error('❌ Failed to load GLB', err);
            }
          );
        }

        window.athensWorldBuilt = false;
        const externalAnimationMixers = [];
        window.externalAnimationMixers = externalAnimationMixers;


        const scaleBounds = ({ xMin, xMax, zMin, zMax }) => ({
            xMin: scaleValue(xMin),
            xMax: scaleValue(xMax),
            zMin: scaleValue(zMin),
            zMax: scaleValue(zMax)
        });
        let isFlying = false;
        const clock = new THREE.Clock();

        let cameraOffset = new THREE.Vector3(0, 3, 7);

        let audioStarted = false;
        const chickens = [];
        const citizens = [];
        const citizenZones = [
            { name: 'agora', center: scaleLocation(AGORA_ANCHOR_SCENE), radius: scaleValue(12), count: 6 },
            { name: 'pnyx', center: scaleLocation(PNYX_POSITION), radius: scaleValue(8), count: 3 },
            { name: 'stoa', center: scaleLocation(AGORA_FEATURES.stoaOfAttalos.position), radius: scaleValue(10), count: 4 },
            { name: 'residential', center: scaleLocation({ x: -40, z: 8 }), radius: scaleValue(9), count: 4 }
        ];
        const interactables = [];
        const updatableObjects = [];
        const pointLights = [];
        const physicsObjects = [];
        let sky;
        let sun;
        const starMaterials = [];
        let starLayerInner;
        let starLayerOuter;
        let milkyWayMesh;
        let skyUniforms;
        let bloomPass;
        let fogEnabled = true;
        let spaceNight = null;
        let canChickenCluck = true;
        let lastCluckTime = 0;
        
        let fps = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        
        let soundEnabled = true;
        let crowdChatter, crowdPanner, marketVolume, merchantSynth, merchantVolume, merchantLoop;
        let blacksmithSound, blacksmithLoop;
        let fountainNoise, fountainPanner, fountainVolume;
        let windNoise, windPanner, windVolume;
        let seagullSynth, seagullPanner, seagullVolume, seagullLoop;
        let templeChantSynth, templeChantPanner, templeVolume, templeChantLoop;
        let animalAmbiences = null;
        let masterBus, environmentReverb;
        let landmarkLabelUpdater = null;
        let landmarkGroups = null;
        const blacksmithPosition = scaleLocation({ x: -12, y: 1, z: 10 });
        const marketAmbiencePosition = scaleLocation({ x: 12, y: 1.5, z: -8 });
        const fountainPosition = scaleLocation({ x: 24, y: 1, z: 14 });
        const hillsideWindPosition = scaleLocation({ x: -26, y: 8, z: -12 });
        const templeChantPosition = scaleLocation({ x: AGORA_FEATURES.templeOfHephaistos.position.x, y: 6, z: AGORA_FEATURES.templeOfHephaistos.position.z });
        const harbourBirdsPosition = scaleLocation({ x: PHALERON_POSITION.x, y: 10, z: PHALERON_POSITION.z });
        const kennelPosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x - 24, y: 1.2, z: AGORA_ANCHOR_SCENE.z + 18 });
        const catAlleyPosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x + 14, y: 1.2, z: AGORA_ANCHOR_SCENE.z + 6 });
        const cowPasturePosition = scaleLocation({ x: AGORA_ANCHOR_SCENE.x - 42, y: 1.5, z: AGORA_ANCHOR_SCENE.z - 26 });
        
        let enhancedLighting = true;
        const timeNames = ["Golden Dawn", "Blue Hour", "High Noon", "Golden Dusk", "Starlit Night"];
        let currentTimeOfDay = timeNames.indexOf("Starlit Night");
        if (currentTimeOfDay === -1) {
            currentTimeOfDay = 0;
        }

        // Declare texture and material variables globally
        let stoneTexture, marbleTexture, redTileTexture, groundTexture, pavedRoadTexture;
        let stoneMaterial, marbleMaterial, goldMaterial, redTileMaterial, groundMaterial, columnMaterial, waterMaterial, pavedRoadMaterial;
        
        const baseMapBounds = { xMin: -80, xMax: 80, zMin: -80, zMax: 80 };
        const mapBounds = scaleBounds(baseMapBounds);
        const getRandomWorldXZ = (padding = 0) => ({
            x: THREE.MathUtils.randFloat(mapBounds.xMin + padding, mapBounds.xMax - padding),
            z: THREE.MathUtils.randFloat(mapBounds.zMin + padding, mapBounds.zMax - padding)
        });
        const getRandomWorldVector3 = (y = 0, padding = 0) => {
            const { x, z } = getRandomWorldXZ(padding);
            return new THREE.Vector3(x, y, z);
        };
        const CHICKEN_WORLD_PADDING = scaleValue(10);
        const BARREL_WORLD_PADDING = scaleValue(20);
        
        const infoData = {
            pnyx: {
                title: "🏛️ The Pnyx",
                text: "This is the Pnyx Hill. Here, all citizens would gather in the Assembly to debate and vote directly on the laws of Athens. This is a powerful example of **Direct Democracy**, where the people themselves, not representatives, make the rules. Remember, only adult male citizens could vote here. Women, slaves, and foreign-born residents (Metics) had no say at all."
            },
            bouleuterion: {
                title: "🏛️ The Bouleuterion",
                text: "This was the Council House, where 500 citizens, chosen by lottery for a one-year term, met to prepare the laws that would be voted on at the Pnyx. This shows the importance of **Citizen Participation** in day-to-day governance."
            },
            dikasteria: {
                title: "⚖️ The Dikasteria",
                text: "These were the Law Courts of Athens. Juries of 201 to 501 citizens, also chosen by lottery, would hear trials and deliver verdicts. Having large juries of ordinary people ensured that justice was in the hands of the citizens, a key part of the **Rule of Law**."
            }
        };


        // --- INITIALIZATION ---
        async function init() {
            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Scene and Camera
            scene = new THREE.Scene();
            window.scene = scene;
            const farClip = 60000;
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, farClip);
            camera.far = Math.max(camera.far, 60000);
            camera.updateProjectionMatrix();
            window.camera = camera;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.physicallyCorrectLights = true;
            if ('outputColorSpace' in renderer && 'SRGBColorSpace' in THREE) {
                renderer.outputColorSpace = THREE.SRGBColorSpace;
            }
            if ('outputEncoding' in renderer) {
                renderer.outputEncoding = THREE.sRGBEncoding;
            }
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            window.renderer = renderer;

            const textureLoader = new THREE.TextureLoader();
            spaceNight = initSpaceNight({
                scene,
                renderer,
                textureLoader,
                camera
            });

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Reduced intensity
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Reduced intensity
            directionalLight.position.set(scaleValue(50), 80, scaleValue(50));
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3); // Reduced intensity
            scene.add(hemisphereLight);

            scene.fog = null;

            // Sky, stars, and post-processing
            initSkyAndStars();
            setupPostFX();

            // Initialize textures and materials now that renderer exists
            stoneTexture = generateTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = '#808080';
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 5000; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const radius = Math.random() * 1.5;
                    const brightness = Math.random() * 0.2 - 0.1;
                    const gray = 128 + brightness * 100;
                    ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${Math.random() * 0.5 + 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            marbleTexture = generateTexture(512, 512, (ctx, w, h) => {
                ctx.fillStyle = '#F0F0F0';
                ctx.fillRect(0, 0, w, h);
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.strokeStyle = `rgba(128, 128, 128, 0.3)`;
                for(let i=0; i<10; i++) {
                     ctx.beginPath();
                     ctx.moveTo(Math.random() * w, Math.random() * h);
                     ctx.bezierCurveTo(Math.random() * w, Math.random() * h, Math.random() * w, Math.random() * h, Math.random() * w, Math.random() * h);
                     ctx.stroke();
                }
            });
            redTileTexture = generateTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 2;
                for(let i = 0; i < w; i += 32) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(w, i);
                    ctx.stroke();
                }
            });
            groundTexture = generateTexture(512, 512, (ctx, w, h) => {
                ctx.fillStyle = '#C2B280'; // Base sandy color
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const radius = Math.random() * 2;
                    const brightness = Math.random() * 0.2 - 0.1;
                    const alpha = Math.random() * 0.5 + 0.5;
                    const gray = 194 + brightness * 100;
                    ctx.fillStyle = `rgba(${gray + 20}, ${gray}, ${gray - 40}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
             pavedRoadTexture = generateTexture(256, 256, (ctx, w, h) => {
                ctx.fillStyle = '#A9A9A9';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                for(let i=0; i < 1000; i++){
                    let x = Math.random() * w;
                    let y = Math.random() * h;
                    let size = Math.random() * 20 + 5;
                    ctx.strokeRect(x,y,size,size);
                }
            });

            stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
            marbleTexture.wrapS = marbleTexture.wrapT = THREE.RepeatWrapping; 
            redTileTexture.wrapS = redTileTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping; 
            pavedRoadTexture.wrapS = pavedRoadTexture.wrapT = THREE.RepeatWrapping;
            
            stoneMaterial = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.85, metalness: 0.05 });
            marbleMaterial = new THREE.MeshStandardMaterial({ map: marbleTexture, roughness: 0.4, metalness: 0.1 });
            goldMaterial = createEnhancedMaterial(0xFFD700, 0.2, 0.9);
            redTileMaterial = new THREE.MeshStandardMaterial({ map: redTileTexture, roughness: 0.7, metalness: 0.0 });
            groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.95, metalness: 0.0 });
            columnMaterial = new THREE.MeshStandardMaterial({ map: marbleTexture, roughness: 0.5, metalness: 0.15 });
            waterMaterial = createEnhancedMaterial(0x5f9ea0, 0.2, 0.1);
            waterMaterial.transparent = true;
            waterMaterial.opacity = 0.7;
            pavedRoadMaterial = new THREE.MeshStandardMaterial({ map: pavedRoadTexture, roughness: 0.8, metalness: 0.1 });


            // Build Scene
            buildWorld();
            createInteractables();
            createInteractiveObjects();
            createMapIcons();
            // Load the temple model (GLB)
            loadGreekTemple();

            try {
                const { buildFromGeoJSON } = await import('./src/buildings-from-geojson.js');
                const projectorInstance = window?.AthensGeo?.projector;
                const projector = projectorInstance && typeof projectorInstance.project === 'function'
                    ? (lon, lat) => {
                        const { x, y } = projectorInstance.project({ lat, lon });
                        return new THREE.Vector3(scaleValue(x), 0, scaleValue(y));
                    }
                    : null;
                await buildFromGeoJSON({
                    scene,
                    geoJsonUrl: './data/athens_places.geojson',
                    projector
                });
            } catch (error) {
                console.error('Failed to build procedural monuments:', error);
            }

            await setupLandmarks();



            // Event Listeners
            addEventListeners();
            
            // Set initial environment state and start animation
            updateEnvironment();
            animate();
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps-value').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // --- TEXTURES AND MATERIALS ---
        const createEnhancedMaterial = (color, roughness = 0.8, metalness = 0.1) => {
            return new THREE.MeshStandardMaterial({ 
                color, 
                roughness, 
                metalness,
                envMapIntensity: 0.5
            });
        };
        
        function generateTexture(width, height, drawFunction) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            drawFunction(context, width, height);
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        // --- WORLD BUILDING ---
        function buildWorld() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(scaleValue(400), scaleValue(400));
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            if (ground.material.map) {
                ground.material.map.repeat.set(16 * CITY_SCALE, 16 * CITY_SCALE);
            }
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const groundPhysMat = new CANNON.Material("groundMaterial");
            const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMat });
            groundBody.addShape(new CANNON.Plane());
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(groundBody);
            
            if(player && player.body) {
                const playerPhysMat = new CANNON.Material("playerMaterial");
                player.body.material = playerPhysMat;
                const groundPlayerContactMaterial = new CANNON.ContactMaterial(
                    groundPhysMat,
                    playerPhysMat,
                    { friction: 0.1, restitution: 0.3 }
                );
                world.addContactMaterial(groundPlayerContactMaterial);
            }


            // Structures
            // createParthenon();
            createAgoraComplex();
            createAreopagusHill();
            createKerameikosDistrict();
            createLongWallsCorridors();
            createLongWallPosts();
            createPhaleronHarbor();
            createHouses();
            createTrees();
            createFountain();
            createCityFortifications();
            createMarketStalls();
            createDemocracyMonuments();
            createPavedRoads();
            window.athensWorldBuilt = true;
            window.dispatchEvent(new Event('athens-world-built'));
        }

        function createEnhancedColumn(height = 8, material = columnMaterial) {
            const group = new THREE.Group();
            const baseHeight = 0.5;
            const capitalHeight = 0.5;

            const columnGeometry = new THREE.CylinderGeometry(0.8 * CITY_SCALE, 1 * CITY_SCALE, height, 16);
            const column = new THREE.Mesh(columnGeometry, material);
            column.castShadow = true;
            if (column.material.map) {
                column.material.map.repeat.set(CITY_SCALE, 2);
            }
            column.position.y = baseHeight + height / 2;
            group.add(column);

            const capitalGeometry = new THREE.CylinderGeometry(1.2 * CITY_SCALE, 0.9 * CITY_SCALE, capitalHeight, 16);
            const capital = new THREE.Mesh(capitalGeometry, goldMaterial);
            capital.position.y = baseHeight + height + capitalHeight / 2;
            capital.castShadow = true;
            group.add(capital);

            const baseGeometry = new THREE.CylinderGeometry(1.1 * CITY_SCALE, 1.3 * CITY_SCALE, baseHeight, 16);
            const base = new THREE.Mesh(baseGeometry, material);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            group.add(base);

            return group;
        }

        function createEnhancedBuilding(x, z, width, depth, height, material = stoneMaterial, options = {}) {
            const { includeDetails = true } = options;
            const group = new THREE.Group();
            const scaledWidth = scaleValue(width);
            const scaledDepth = scaleValue(depth);
            const scaledX = scaleValue(x);
            const scaledZ = scaleValue(z);
            const buildingGeometry = new THREE.BoxGeometry(scaledWidth, height, scaledDepth);
            const building = new THREE.Mesh(buildingGeometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            if (building.material.map) {
                building.material.map.repeat.set(scaledWidth / 4, height / 4);
            }
            group.add(building);

            if (includeDetails) {
                // Add doors and windows
                const detailMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
                if (width > depth) { // Horizontal building
                    const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.5), detailMaterial);
                    door.position.set(0, -height/2 + 1.25, scaledDepth/2 + 0.01);
                    group.add(door);
                } else { // Vertical building
                    const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.5), detailMaterial);
                    door.position.set(scaledWidth/2 + 0.01, -height/2 + 1.25, 0);
                    door.rotation.y = Math.PI / 2;
                    group.add(door);
                }

                if (Math.random() > 0.5) {
                    const decorGeometry = new THREE.BoxGeometry(scaledWidth * 1.1, 0.5, scaledDepth * 1.1);
                    const decoration = new THREE.Mesh(decorGeometry, goldMaterial);
                    decoration.position.y = height / 2 + 0.25;
                    decoration.castShadow = true;
                    group.add(decoration);
                }
            }
            group.position.set(scaledX, height/2, scaledZ);
            return group;
        }
        
        function createParthenon() {
            const acropolis = new THREE.Group();

            const hillMaterialBase = groundMaterial.clone();
            let hillTexture = null;
            if (groundMaterial.map) {
                hillTexture = groundMaterial.map.clone();
                hillTexture.wrapS = hillTexture.wrapT = THREE.RepeatWrapping;
                hillTexture.repeat.set(6 * CITY_SCALE, 3 * CITY_SCALE);
                hillTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                hillTexture.needsUpdate = true;
                hillMaterialBase.map = hillTexture;
            }
            hillMaterialBase.color = new THREE.Color(0xBCA67C);
            hillMaterialBase.roughness = Math.min(0.98, hillMaterialBase.roughness + 0.03);

            const hillLayers = [
                { top: scaleValue(70), bottom: scaleValue(85), height: 3 },
                { top: scaleValue(55), bottom: scaleValue(70), height: 3 },
                { top: scaleValue(42), bottom: scaleValue(55), height: 2.5 },
                { top: scaleValue(34), bottom: scaleValue(42), height: 2 }
            ];

            let plateauHeight = 0;
            hillLayers.forEach((layer, index) => {
                const layerMaterial = hillMaterialBase.clone();
                if (hillTexture) {
                    layerMaterial.map = hillTexture.clone();
                    layerMaterial.map.repeat.set((6 + index) * CITY_SCALE, 3 + index * 0.5);
                    layerMaterial.map.needsUpdate = true;
                }
                const terrace = new THREE.Mesh(
                    new THREE.CylinderGeometry(layer.top, layer.bottom, layer.height, 64, 1, false),
                    layerMaterial
                );
                terrace.position.y = plateauHeight + layer.height / 2;
                terrace.castShadow = true;
                terrace.receiveShadow = true;
                acropolis.add(terrace);
                plateauHeight += layer.height;
            });

            const rockMaterial = stoneMaterial.clone();
            rockMaterial.color = new THREE.Color(0x9f8f78);
            [
                { position: scaledVector3(-26, 1.8, 28), scale: 1.3 },
                { position: scaledVector3(22, 2.6, 24), scale: 1.1 },
                { position: scaledVector3(-18, 4.2, -8), scale: 1.0 },
                { position: scaledVector3(16, 3.6, -14), scale: 1.2 }
            ].forEach(detail => {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(3 * detail.scale * CITY_SCALE, 0), rockMaterial);
                rock.position.copy(detail.position);
                rock.scale.setScalar(detail.scale);
                rock.castShadow = true;
                rock.receiveShadow = true;
                acropolis.add(rock);
            });

            const pathMaterial = pavedRoadMaterial.clone();
            if (pathMaterial.map) {
                pathMaterial.map = pathMaterial.map.clone();
                pathMaterial.map.wrapS = pathMaterial.map.wrapT = THREE.RepeatWrapping;
                pathMaterial.map.repeat.set(2 * CITY_SCALE, 12 * CITY_SCALE);
                pathMaterial.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                pathMaterial.map.needsUpdate = true;
            }
            pathMaterial.color = new THREE.Color(0xD2C3A4);

            const rampDepthBase = 60;
            const rampDepth = scaleValue(rampDepthBase);
            const rampAngle = Math.asin(Math.min(1, plateauHeight / rampDepth));
            const rampCenterZBase = -7.5 + rampDepthBase / 2;
            const rampCenterZ = scaleValue(rampCenterZBase);
            const rampHeight = plateauHeight / 2;

            const ramp = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(8), 0.4, rampDepth), pathMaterial);
            ramp.position.set(scaleValue(0), rampHeight, rampCenterZ);
            ramp.rotation.x = -rampAngle;
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            acropolis.add(ramp);

            const rampWallsMaterial = stoneMaterial.clone();
            rampWallsMaterial.color = new THREE.Color(0xE0D0B8);
            const rampWallGeometry = new THREE.BoxGeometry(scaleValue(0.6), 1.2, rampDepth);
            [-1, 1].forEach(side => {
                const wall = new THREE.Mesh(rampWallGeometry, rampWallsMaterial);
                wall.position.set(scaleValue(side * 4.4), rampHeight + 0.6, rampCenterZ);
                wall.rotation.x = -rampAngle;
                wall.castShadow = true;
                wall.receiveShadow = true;
                acropolis.add(wall);
            });

            const lowerPlaza = new THREE.Mesh(new THREE.CylinderGeometry(scaleValue(15), scaleValue(19), 0.5, 48), pathMaterial);
            lowerPlaza.position.set(scaleValue(0), 0.25, scaleValue(rampCenterZBase + rampDepthBase / 2 + 4));
            lowerPlaza.castShadow = true;
            lowerPlaza.receiveShadow = true;
            acropolis.add(lowerPlaza);

            const upperLanding = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(16), 0.4, scaleValue(10)), pathMaterial);
            upperLanding.position.set(scaleValue(0), plateauHeight - 0.2, scaleValue(-12));
            upperLanding.castShadow = true;
            upperLanding.receiveShadow = true;
            acropolis.add(upperLanding);

            const parthenon = new THREE.Group();
            const steps = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const stepGeometry = new THREE.BoxGeometry(scaleValue(35 - i), 0.5, scaleValue(18 - i));
                const step = new THREE.Mesh(stepGeometry, marbleMaterial);
                if(step.material.map) {
                    step.material.map.repeat.set(8 * CITY_SCALE, 1 * CITY_SCALE);
                }
                step.position.y = i * 0.5;
                step.castShadow = true;
                step.receiveShadow = true;
                steps.add(step);
            }
            parthenon.add(steps);
            const parthenonBase = createEnhancedBuilding(0, 0, 30, 15, 4, marbleMaterial);
            if(parthenonBase.children[0].material.map) {
                parthenonBase.children[0].material.map.repeat.set(8 * CITY_SCALE, 2 * CITY_SCALE);
            }
            parthenonBase.position.y = 3.5;
            parthenon.add(parthenonBase);
            for (let i = 0; i < 8; i++) {
                const frontColumn = createEnhancedColumn(12);
                setScaledPosition(frontColumn, -13 + i * 4, -0.5, -7.5);
                parthenon.add(frontColumn);

                const backColumn = createEnhancedColumn(12);
                setScaledPosition(backColumn, -13 + i * 4, -0.5, 7.5);
                parthenon.add(backColumn);
            }
            for (let i = 0; i < 4; i++) {
                const leftColumn = createEnhancedColumn(12);
                setScaledPosition(leftColumn, -15, -0.5, -5.5 + i * 3.5);
                parthenon.add(leftColumn);

                const rightColumn = createEnhancedColumn(12);
                setScaledPosition(rightColumn, 15, -0.5, -5.5 + i * 3.5);
                parthenon.add(rightColumn);
            }
            const roofGroup = new THREE.Group();
            const roofLength = scaleValue(32);
            const roofDepth = scaleValue(18);
            const roofHeight = 4.5;
            const halfLength = roofLength / 2;
            const halfDepth = roofDepth / 2;
            const pedimentDepth = scaleValue(0.8);
            const slopeRun = Math.sqrt(halfDepth * halfDepth + roofHeight * roofHeight);

            const roofTileTexture = redTileMaterial.map.clone();
            roofTileTexture.wrapS = roofTileTexture.wrapT = THREE.RepeatWrapping;
            roofTileTexture.repeat.set(roofLength / 4, slopeRun / 2);
            roofTileTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            roofTileTexture.needsUpdate = true;

            const roofTileMaterial = redTileMaterial.clone();
            roofTileMaterial.map = roofTileTexture;
            roofTileMaterial.roughness = Math.max(0.45, roofTileMaterial.roughness - 0.15);
            roofTileMaterial.metalness = 0.05;

            const createSlopeGeometry = (sign = 1) => {
                const geometry = new THREE.BufferGeometry();
                const positions = sign > 0
                    ? new Float32Array([
                        -halfLength, 0, halfDepth,
                         halfLength, 0, halfDepth,
                         halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                        -halfLength, roofHeight, 0,
                        -halfLength, 0, halfDepth
                    ])
                    : new Float32Array([
                        -halfLength, 0, -halfDepth,
                        -halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                         halfLength, roofHeight, 0,
                         halfLength, 0, -halfDepth,
                        -halfLength, 0, -halfDepth
                    ]);
                const uvs = sign > 0
                    ? new Float32Array([
                        0, 0,
                        1, 0,
                        1, 1,
                        1, 1,
                        0, 1,
                        0, 0
                    ])
                    : new Float32Array([
                        0, 0,
                        0, 1,
                        1, 1,
                        1, 1,
                        1, 0,
                        0, 0
                    ]);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.computeVertexNormals();
                return geometry;
            };

            const southSlope = new THREE.Mesh(createSlopeGeometry(1), roofTileMaterial);
            southSlope.castShadow = true;
            southSlope.receiveShadow = true;
            roofGroup.add(southSlope);

            const northSlopeMaterial = roofTileMaterial.clone();
            northSlopeMaterial.map = roofTileTexture.clone();
            northSlopeMaterial.map.wrapS = northSlopeMaterial.map.wrapT = THREE.RepeatWrapping;
            northSlopeMaterial.map.repeat.copy(roofTileTexture.repeat);
            northSlopeMaterial.map.anisotropy = roofTileTexture.anisotropy;
            northSlopeMaterial.map.needsUpdate = true;
            const northSlope = new THREE.Mesh(createSlopeGeometry(-1), northSlopeMaterial);
            northSlope.castShadow = true;
            northSlope.receiveShadow = true;
            roofGroup.add(northSlope);

            const roofDeckTexture = marbleMaterial.map.clone();
            roofDeckTexture.wrapS = roofDeckTexture.wrapT = THREE.RepeatWrapping;
            roofDeckTexture.repeat.set(roofLength / 6, roofDepth / 4);
            roofDeckTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            roofDeckTexture.needsUpdate = true;
            const roofDeckMaterial = marbleMaterial.clone();
            roofDeckMaterial.map = roofDeckTexture;
            const roofDeck = new THREE.Mesh(new THREE.BoxGeometry(roofLength, 0.5, roofDepth), roofDeckMaterial);
            roofDeck.position.y = -0.25;
            roofDeck.castShadow = true;
            roofDeck.receiveShadow = true;
            roofGroup.add(roofDeck);

            const pedimentTexture = marbleMaterial.map.clone();
            pedimentTexture.wrapS = pedimentTexture.wrapT = THREE.RepeatWrapping;
            pedimentTexture.repeat.set(roofLength / 6, roofHeight / 2);
            pedimentTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            pedimentTexture.needsUpdate = true;
            const pedimentMaterial = marbleMaterial.clone();
            pedimentMaterial.map = pedimentTexture;
            pedimentMaterial.roughness = Math.max(0.35, pedimentMaterial.roughness - 0.05);

            const buildPedimentGeometry = () => {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const uvs = [];
                const addTriangle = (a, b, c, uva, uvb, uvc) => {
                    positions.push(a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2]);
                    uvs.push(uva[0], uva[1], uvb[0], uvb[1], uvc[0], uvc[1]);
                };

                const f0 = [-halfLength, 0, pedimentDepth / 2];
                const f1 = [halfLength, 0, pedimentDepth / 2];
                const f2 = [0, roofHeight, pedimentDepth / 2];
                const b0 = [-halfLength, 0, -pedimentDepth / 2];
                const b1 = [halfLength, 0, -pedimentDepth / 2];
                const b2 = [0, roofHeight, -pedimentDepth / 2];

                addTriangle(f0, f1, f2, [0, 0], [1, 0], [0.5, 1]);
                addTriangle(b0, b2, b1, [0, 0], [0.5, 1], [1, 0]);
                addTriangle(f0, f1, b1, [0, 0], [1, 0], [1, 1]);
                addTriangle(f0, b1, b0, [0, 0], [1, 1], [0, 1]);
                addTriangle(f0, b2, b0, [0, 0], [1, 1], [1, 0]);
                addTriangle(f0, f2, b2, [0, 0], [1, 0], [1, 1]);
                addTriangle(f1, b1, b2, [0, 0], [0, 1], [1, 1]);
                addTriangle(f1, b2, f2, [0, 0], [1, 1], [1, 0]);

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions), 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uvs), 2));
                geometry.computeVertexNormals();
                return geometry;
            };

            const pedimentGeometry = buildPedimentGeometry();
            const reliefMaterial = createEnhancedMaterial(0xD5C7A8, 0.6, 0.1);
            reliefMaterial.side = THREE.FrontSide;

            const createPediment = (isFront = true) => {
                const group = new THREE.Group();
                const pedimentMesh = new THREE.Mesh(pedimentGeometry, pedimentMaterial);
                pedimentMesh.castShadow = true;
                pedimentMesh.receiveShadow = true;
                group.add(pedimentMesh);

                const reliefInset = scaleValue(2.5);
                const reliefShape = new THREE.Shape();
                reliefShape.moveTo(-halfLength + reliefInset, 0.6);
                reliefShape.lineTo(halfLength - reliefInset, 0.6);
                reliefShape.lineTo(0, roofHeight - 0.8);
                reliefShape.closePath();
                const reliefGeometry = new THREE.ShapeGeometry(reliefShape);
                const relief = new THREE.Mesh(reliefGeometry, reliefMaterial);
                relief.position.z = pedimentDepth / 2 + 0.02;
                relief.castShadow = true;
                group.add(relief);

                if (!isFront) {
                    group.rotation.y = Math.PI;
                }
                group.position.z = isFront ? halfDepth - pedimentDepth / 2 : -halfDepth + pedimentDepth / 2;
                return group;
            };

            const frontPediment = createPediment(true);
            const backPediment = createPediment(false);
            roofGroup.add(frontPediment);
            roofGroup.add(backPediment);

            const ridgeMaterial = pedimentMaterial.clone();
            ridgeMaterial.map = pedimentTexture.clone();
            ridgeMaterial.map.wrapS = ridgeMaterial.map.wrapT = THREE.RepeatWrapping;
            ridgeMaterial.map.repeat.set(roofLength / 6, 1);
            ridgeMaterial.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
            ridgeMaterial.map.needsUpdate = true;
            const ridge = new THREE.Mesh(new THREE.BoxGeometry(roofLength + scaleValue(0.2), 0.3, scaleValue(0.6)), ridgeMaterial);
            ridge.position.y = roofHeight - 0.1;
            ridge.castShadow = true;
            ridge.receiveShadow = true;
            roofGroup.add(ridge);

            roofGroup.position.y = 12.55;
            parthenon.add(roofGroup);
            const athenaGeometry = new THREE.CylinderGeometry(0.5 * CITY_SCALE, 0.8 * CITY_SCALE, 8);
            const athena = new THREE.Mesh(athenaGeometry, goldMaterial);
            athena.position.set(0, 10, 0);
            athena.castShadow = true;
            parthenon.add(athena);

            parthenon.position.y = plateauHeight;
            acropolis.add(parthenon);

          setScaledPosition(acropolis, 120, 0, -90);
            scene.add(acropolis);
        }
        
        function createPedimentMesh(width, height, depth, material) {
            const shape = new THREE.Shape();
            shape.moveTo(-width / 2, 0);
            shape.lineTo(0, height);
            shape.lineTo(width / 2, 0);
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled: false });
            geometry.translate(0, 0, -depth / 2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createTempleOfHephaistosStructure() {
            const group = new THREE.Group();
            const stylobateHeight = 1.2;
            const stylobateMaterial = marbleMaterial.clone();
            stylobateMaterial.roughness = Math.max(0.45, stylobateMaterial.roughness - 0.05);
            const stylobate = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(28), stylobateHeight, scaleValue(13)), stylobateMaterial);
            stylobate.position.y = stylobateHeight / 2;
            stylobate.castShadow = true;
            stylobate.receiveShadow = true;
            group.add(stylobate);

            const cellaHeight = 6.2;
            const cellaMaterial = marbleMaterial.clone();
            cellaMaterial.color = cellaMaterial.color.clone().offsetHSL(-0.02, -0.02, 0.03);
            const cella = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(18), cellaHeight, scaleValue(7)), cellaMaterial);
            cella.position.y = stylobateHeight + cellaHeight / 2;
            cella.castShadow = true;
            cella.receiveShadow = true;
            group.add(cella);

            const columnHeight = 6.5;
            const columnsPerLongSide = 13;
            const columnsPerShortSide = 6;
            const halfLength = scaleValue(28) / 2;
            const halfWidth = scaleValue(13) / 2;
            const marginX = scaleValue(2.4);
            const marginZ = scaleValue(1.8);
            const spacingLong = (2 * (halfLength - marginX)) / (columnsPerLongSide - 1);
            const spacingShort = (2 * (halfWidth - marginZ)) / (columnsPerShortSide - 1);

            for (let i = 0; i < columnsPerLongSide; i++) {
                const xPos = -halfLength + marginX + i * spacingLong;
                const northColumn = createEnhancedColumn(columnHeight);
                northColumn.position.set(xPos, stylobateHeight, halfWidth - marginZ);
                group.add(northColumn);

                const southColumn = createEnhancedColumn(columnHeight);
                southColumn.position.set(xPos, stylobateHeight, -halfWidth + marginZ);
                group.add(southColumn);
            }

            for (let i = 1; i < columnsPerShortSide - 1; i++) {
                const zPos = -halfWidth + marginZ + i * spacingShort;
                const westColumn = createEnhancedColumn(columnHeight);
                westColumn.position.set(-halfLength + marginX, stylobateHeight, zPos);
                group.add(westColumn);

                const eastColumn = createEnhancedColumn(columnHeight);
                eastColumn.position.set(halfLength - marginX, stylobateHeight, zPos);
                group.add(eastColumn);
            }

            const roofHeight = 1.6;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(12 * CITY_SCALE, 4 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(26), roofHeight, scaleValue(11)), roofMaterial);
            roof.position.y = stylobateHeight + columnHeight + roofHeight / 2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            const pedimentMaterial = marbleMaterial.clone();
            pedimentMaterial.roughness = Math.max(0.4, pedimentMaterial.roughness - 0.05);
            const pedimentDepth = scaleValue(1.4);
            const pedimentHeight = 2.4;
            const pedimentWidth = scaleValue(11);

            const frontPediment = createPedimentMesh(pedimentWidth, pedimentHeight, pedimentDepth, pedimentMaterial);
            frontPediment.position.set(0, roof.position.y + roofHeight / 2 - 0.2, halfWidth - pedimentDepth / 2);
            group.add(frontPediment);

            const backPediment = createPedimentMesh(pedimentWidth, pedimentHeight, pedimentDepth, pedimentMaterial);
            backPediment.position.set(0, roof.position.y + roofHeight / 2 - 0.2, -halfWidth + pedimentDepth / 2);
            backPediment.rotation.y = Math.PI;
            group.add(backPediment);

            const statueMaterial = goldMaterial.clone();
            statueMaterial.emissive = new THREE.Color(0x6f5b2e);
            const statue = new THREE.Mesh(new THREE.CylinderGeometry(0.22 * CITY_SCALE, 0.3 * CITY_SCALE, 2, 12), statueMaterial);
            statue.position.set(0, stylobateHeight + 1, halfWidth + 0.5 * CITY_SCALE);
            statue.castShadow = true;
            group.add(statue);

            return group;
        }

        function createStoaOfAttalosStructure() {
            const group = new THREE.Group();
            const baseHeight = 0.8;
            const length = 62;
            const depth = 18;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(0, -0.05, 0.05);
            const base = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(length), baseHeight, scaleValue(depth)), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const walkwayMaterial = pavedRoadMaterial.clone();
            const walkway = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(length * 1.05), scaleValue(depth * 0.6)), walkwayMaterial);
            walkway.rotation.x = -Math.PI / 2;
            walkway.position.set(0, 0.05, scaleValue(depth / 2));
            walkway.receiveShadow = true;
            group.add(walkway);

            const columnsLower = 14;
            const halfLength = scaleValue(length) / 2;
            const frontOffset = scaleValue(depth / 2 - 1.8);
            const innerOffset = scaleValue(depth / 2 - 5);
            const margin = scaleValue(2);
            const spacing = (2 * (halfLength - margin)) / (columnsLower - 1);

            for (let i = 0; i < columnsLower; i++) {
                const xPos = -halfLength + margin + i * spacing;
                const frontColumn = createEnhancedColumn(7.2);
                frontColumn.position.set(xPos, baseHeight, frontOffset);
                group.add(frontColumn);

                const innerColumn = createEnhancedColumn(6.8);
                innerColumn.position.set(xPos, baseHeight, innerOffset);
                group.add(innerColumn);
            }

            const upperLevelHeight = 4.2;
            const upperOffset = scaleValue(depth / 2 - 4.2);
            for (let i = 0; i < columnsLower; i++) {
                const xPos = -halfLength + margin + i * spacing;
                const upperColumn = createEnhancedColumn(upperLevelHeight);
                upperColumn.scale.setScalar(0.7);
                upperColumn.position.set(xPos, baseHeight + 7.4, upperOffset);
                group.add(upperColumn);
            }

            const roofHeight = 1.4;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(20 * CITY_SCALE, 6 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(length + 2), roofHeight, scaleValue(depth + 2)), roofMaterial);
            roof.position.y = baseHeight + 7.2 + upperLevelHeight + roofHeight / 2 + 0.6;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            return group;
        }

        function createTholosStructure() {
            const group = new THREE.Group();
            const podiumHeight = 0.6;
            const podiumRadius = scaleValue(8);
            const podium = new THREE.Mesh(new THREE.CylinderGeometry(podiumRadius, podiumRadius, podiumHeight, 32), marbleMaterial.clone());
            podium.position.y = podiumHeight / 2;
            podium.castShadow = true;
            podium.receiveShadow = true;
            group.add(podium);

            const columnCount = 12;
            const columnHeight = 5.2;
            const radius = scaleValue(6.2);
            for (let i = 0; i < columnCount; i++) {
                const angle = (i / columnCount) * Math.PI * 2;
                const column = createEnhancedColumn(columnHeight);
                column.position.set(Math.cos(angle) * radius, podiumHeight, Math.sin(angle) * radius);
                group.add(column);
            }

            const drum = new THREE.Mesh(new THREE.CylinderGeometry(scaleValue(4), scaleValue(4), 3, 24), marbleMaterial.clone());
            drum.position.y = podiumHeight + columnHeight / 2;
            drum.castShadow = true;
            drum.receiveShadow = true;
            group.add(drum);

            const roofMaterial = redTileMaterial.clone();
            const roof = new THREE.Mesh(new THREE.ConeGeometry(scaleValue(6.5), 2.5, 24), roofMaterial);
            roof.position.y = podiumHeight + columnHeight + 1.2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            return group;
        }

        function createBouleuterionStructure() {
            const group = new THREE.Group();
            const baseHeight = 0.6;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(0.02, -0.05, -0.05);
            const base = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(24), baseHeight, scaleValue(20)), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const hallHeight = 6.8;
            const hallMaterial = marbleMaterial.clone();
            hallMaterial.color = hallMaterial.color.clone().offsetHSL(-0.02, -0.05, 0.02);
            const hall = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(18), hallHeight, scaleValue(14)), hallMaterial);
            hall.position.y = baseHeight + hallHeight / 2;
            hall.castShadow = true;
            hall.receiveShadow = true;
            group.add(hall);

            const roofHeight = 1.4;
            const roofMaterial = redTileMaterial.clone();
            if (roofMaterial.map) {
                roofMaterial.map = roofMaterial.map.clone();
                roofMaterial.map.repeat.set(12 * CITY_SCALE, 6 * CITY_SCALE);
                roofMaterial.map.needsUpdate = true;
            }
            const roof = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(20), roofHeight, scaleValue(16)), roofMaterial);
            roof.position.y = baseHeight + hallHeight + roofHeight / 2;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            const portico = new THREE.Group();
            const columnCount = 4;
            const spacing = scaleValue(12) / (columnCount - 1);
            for (let i = 0; i < columnCount; i++) {
                const column = createEnhancedColumn(5.8);
                column.position.set(-scaleValue(6) + i * spacing, baseHeight, scaleValue(9));
                portico.add(column);
            }
            const architrave = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 0.8, scaleValue(4.5)), marbleMaterial.clone());
            architrave.position.set(0, baseHeight + 5.8, scaleValue(9));
            architrave.castShadow = true;
            architrave.receiveShadow = true;
            portico.add(architrave);

            group.add(portico);

            return group;
        }

        function createAltarOfTwelveGodsStructure() {
            const group = new THREE.Group();
            const tiers = [
                { width: 14, depth: 8, height: 0.4 },
                { width: 11.5, depth: 5.5, height: 0.4 },
                { width: 8, depth: 3, height: 0.6 }
            ];
            let elevation = 0;
            tiers.forEach((tier, index) => {
                const material = marbleMaterial.clone();
                material.roughness = Math.max(0.35, material.roughness - 0.05 * (index + 1));
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(tier.width), tier.height, scaleValue(tier.depth)), material);
                elevation += tier.height / 2;
                mesh.position.y = elevation;
                elevation += tier.height / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            });

            const bowlMaterial = goldMaterial.clone();
            const fireBowl = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * CITY_SCALE, 0.8 * CITY_SCALE, 0.7, 16), bowlMaterial);
            fireBowl.position.y = elevation + 0.35;
            fireBowl.castShadow = true;
            group.add(fireBowl);

            return group;
        }

        function createAgoraComplex() {
            const plazaMaterial = groundMaterial.clone();
            plazaMaterial.color = plazaMaterial.color.clone().offsetHSL(0.05, 0.08, 0.08);
            plazaMaterial.roughness = Math.min(1, plazaMaterial.roughness + 0.1);
            const plaza = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(90), scaleValue(70)), plazaMaterial);
            plaza.rotation.x = -Math.PI / 2;
            plaza.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.02, scaleValue(AGORA_ANCHOR_SCENE.z));
            plaza.receiveShadow = true;
            scene.add(plaza);

            const processional = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(70), scaleValue(8)), pavedRoadMaterial.clone());
            processional.rotation.x = -Math.PI / 2;
            processional.position.set(scaleValue(AGORA_ANCHOR_SCENE.x), 0.03, scaleValue(AGORA_ANCHOR_SCENE.z));
            processional.receiveShadow = true;
            scene.add(processional);

            const temple = createTempleOfHephaistosStructure();
            temple.rotation.y = AGORA_FEATURES.templeOfHephaistos.rotation;
            setScaledPosition(temple, AGORA_FEATURES.templeOfHephaistos.position.x, 0, AGORA_FEATURES.templeOfHephaistos.position.z);
            scene.add(temple);

            const stoa = createStoaOfAttalosStructure();
            stoa.rotation.y = AGORA_FEATURES.stoaOfAttalos.rotation;
            setScaledPosition(stoa, AGORA_FEATURES.stoaOfAttalos.position.x, 0, AGORA_FEATURES.stoaOfAttalos.position.z);
            scene.add(stoa);

            const tholos = createTholosStructure();
            setScaledPosition(tholos, AGORA_FEATURES.tholos.position.x, 0, AGORA_FEATURES.tholos.position.z);
            scene.add(tholos);

            const bouleuterion = createBouleuterionStructure();
            bouleuterion.rotation.y = AGORA_FEATURES.bouleuterion.rotation;
            setScaledPosition(bouleuterion, AGORA_FEATURES.bouleuterion.position.x, 0, AGORA_FEATURES.bouleuterion.position.z);
            scene.add(bouleuterion);

            const altar = createAltarOfTwelveGodsStructure();
            altar.rotation.y = AGORA_FEATURES.altarOfTwelveGods.rotation;
            setScaledPosition(altar, AGORA_FEATURES.altarOfTwelveGods.position.x, 0, AGORA_FEATURES.altarOfTwelveGods.position.z);
            scene.add(altar);

            const groveConfigs = [
                { x: AGORA_FEATURES.templeOfHephaistos.position.x - 8, z: AGORA_FEATURES.templeOfHephaistos.position.z + 12, scale: 1.2 },
                { x: AGORA_FEATURES.templeOfHephaistos.position.x - 12, z: AGORA_FEATURES.templeOfHephaistos.position.z - 8, scale: 1.0 },
                { x: AGORA_FEATURES.stoaOfAttalos.position.x + 10, z: AGORA_FEATURES.stoaOfAttalos.position.z - 12, scale: 0.9 }
            ];
            groveConfigs.forEach((config) => {
                const tree = createEnhancedTree(0, 0, config.scale);
                tree.position.set(scaleValue(config.x), 0, scaleValue(config.z));
                scene.add(tree);
            });
        }

        function createAreopagusHill() {
            const hillGroup = new THREE.Group();
            const baseRadius = scaleValue(20);
            const baseHeight = 3.2;
            const baseMaterial = stoneMaterial.clone();
            baseMaterial.color = baseMaterial.color.clone().offsetHSL(-0.05, -0.05, -0.05);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(baseRadius * 0.9, baseRadius, baseHeight, 24), baseMaterial);
            base.position.y = baseHeight / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            hillGroup.add(base);

            const midLayer = new THREE.Mesh(new THREE.CylinderGeometry(baseRadius * 0.7, baseRadius * 0.9, 2.6, 20), baseMaterial);
            midLayer.position.y = baseHeight + 1.3;
            midLayer.castShadow = true;
            midLayer.receiveShadow = true;
            hillGroup.add(midLayer);

            for (let i = 0; i < 6; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2.2 * CITY_SCALE + Math.random() * CITY_SCALE), baseMaterial.clone());
                const angle = Math.random() * Math.PI * 2;
                const radius = baseRadius * 0.6 + Math.random() * baseRadius * 0.3;
                rock.position.set(Math.cos(angle) * radius, baseHeight + 1 + Math.random() * 2, Math.sin(angle) * radius);
                rock.castShadow = true;
                rock.receiveShadow = true;
                hillGroup.add(rock);
            }

            const stairMaterial = pavedRoadMaterial.clone();
            const stairs = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(6), 0.4, scaleValue(18)), stairMaterial);
            stairs.position.set(0, baseHeight + 0.2, -scaleValue(7));
            stairs.rotation.x = Math.PI / 18;
            stairs.receiveShadow = true;
            hillGroup.add(stairs);

            const altarMaterial = marbleMaterial.clone();
            const altar = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(5), 1, scaleValue(3)), altarMaterial);
            altar.position.set(0, baseHeight + 3.8, scaleValue(2));
            altar.castShadow = true;
            altar.receiveShadow = true;
            hillGroup.add(altar);

            const olive = createEnhancedTree(0, 0, 0.9);
            olive.position.set(scaleValue(3), baseHeight + 1, scaleValue(6));
            hillGroup.add(olive);

            hillGroup.position.set(scaleValue(AREOPAGUS_POSITION.x), 0, scaleValue(AREOPAGUS_POSITION.z));
            scene.add(hillGroup);
        }

        function createKerameikosDistrict() {
            const kerameikosGroup = new THREE.Group();
            const groundMaterialVariant = groundMaterial.clone();
            groundMaterialVariant.color = groundMaterialVariant.color.clone().offsetHSL(-0.05, 0.02, 0.04);
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(60), scaleValue(50)), groundMaterialVariant);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.02;
            ground.receiveShadow = true;
            kerameikosGroup.add(ground);

            const gateFloor = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(18), scaleValue(28)), pavedRoadMaterial.clone());
            gateFloor.rotation.x = -Math.PI / 2;
            gateFloor.position.set(0, 0.03, -scaleValue(12));
            gateFloor.receiveShadow = true;
            kerameikosGroup.add(gateFloor);

            const towerMaterial = stoneMaterial.clone();
            towerMaterial.color = towerMaterial.color.clone().offsetHSL(0, -0.05, -0.1);
            const towerGeometry = new THREE.BoxGeometry(scaleValue(10), 10, scaleValue(10));
            const westTower = new THREE.Mesh(towerGeometry, towerMaterial);
            westTower.position.set(-scaleValue(8), 5, 0);
            westTower.castShadow = true;
            westTower.receiveShadow = true;
            kerameikosGroup.add(westTower);

            const eastTower = westTower.clone();
            eastTower.position.x = scaleValue(8);
            kerameikosGroup.add(eastTower);

            const gateMaterial = marbleMaterial.clone();
            gateMaterial.color = gateMaterial.color.clone().offsetHSL(-0.05, -0.05, 0.05);
            const gate = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 6, scaleValue(4)), gateMaterial);
            gate.position.set(0, 3.2, 0);
            gate.castShadow = true;
            gate.receiveShadow = true;
            kerameikosGroup.add(gate);

            const lintel = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 1.2, scaleValue(8)), gateMaterial);
            lintel.position.set(0, 5.8, -scaleValue(2));
            lintel.castShadow = true;
            lintel.receiveShadow = true;
            kerameikosGroup.add(lintel);

            const steleMaterial = marbleMaterial.clone();
            for (let i = 0; i < 7; i++) {
                const height = 2.4 + Math.random() * 1.2;
                const stele = new THREE.Mesh(new THREE.CylinderGeometry(0.45 * CITY_SCALE, 0.55 * CITY_SCALE, height, 8), steleMaterial);
                const angle = (i / 7) * Math.PI + Math.PI / 4;
                const radius = scaleValue(18 + Math.random() * 6);
                stele.position.set(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
                stele.castShadow = true;
                stele.receiveShadow = true;
                kerameikosGroup.add(stele);
            }

            const olive = createEnhancedTree(0, 0, 0.85);
            olive.position.set(-scaleValue(16), 0, scaleValue(10));
            kerameikosGroup.add(olive);

            kerameikosGroup.rotation.y = LONG_WALL_DIRECTION;
            kerameikosGroup.position.set(scaleValue(KERAMEIKOS_POSITION.x), 0, scaleValue(KERAMEIKOS_POSITION.z));
            scene.add(kerameikosGroup);
        }

        function createLongWallsCorridors() {
            const createCorridor = (endPosition, { width = 10, height = 4.5, thickness = 1.4, maxLength = 160 } = {}) => {
                const start = KERAMEIKOS_POSITION;
                const dx = endPosition.x - start.x;
                const dz = endPosition.z - start.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                if (length < 1e-3) {
                    return;
                }
                const clampRatio = Math.min(1, maxLength / length);
                const target = {
                    x: start.x + dx * clampRatio,
                    z: start.z + dz * clampRatio
                };
                const actualLength = length * clampRatio;
                const angle = Math.atan2(target.x - start.x, target.z - start.z);
                const corridorGroup = new THREE.Group();
                const scaledLength = scaleValue(actualLength);

                const walkway = new THREE.Mesh(new THREE.PlaneGeometry(scaledLength, scaleValue(width)), pavedRoadMaterial.clone());
                walkway.rotation.x = -Math.PI / 2;
                walkway.position.y = 0.06;
                walkway.receiveShadow = true;
                corridorGroup.add(walkway);

                const wallMaterial = stoneMaterial.clone();
                wallMaterial.color = wallMaterial.color.clone().offsetHSL(-0.05, -0.05, -0.05);
                const wallGeometry = new THREE.BoxGeometry(scaleValue(thickness), height, scaledLength);
                const wallOffset = scaleValue(width / 2 - thickness / 2);

                const wallLeft = new THREE.Mesh(wallGeometry, wallMaterial);
                wallLeft.position.set(wallOffset, height / 2, 0);
                wallLeft.castShadow = true;
                wallLeft.receiveShadow = true;
                corridorGroup.add(wallLeft);

                const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
                wallRight.position.set(-wallOffset, height / 2, 0);
                wallRight.castShadow = true;
                wallRight.receiveShadow = true;
                corridorGroup.add(wallRight);

                const parapetMaterial = wallMaterial.clone();
                const parapetGeometry = new THREE.BoxGeometry(scaleValue(thickness) * 0.8, 0.6, scaledLength);
                const parapetLeft = new THREE.Mesh(parapetGeometry, parapetMaterial);
                parapetLeft.position.set(wallOffset, height + 0.3, 0);
                corridorGroup.add(parapetLeft);
                const parapetRight = parapetLeft.clone();
                parapetRight.position.x = -wallOffset;
                corridorGroup.add(parapetRight);

                corridorGroup.rotation.y = angle;
                const midX = (start.x + target.x) / 2;
                const midZ = (start.z + target.z) / 2;
                corridorGroup.position.set(scaleValue(midX), 0, scaleValue(midZ));
                scene.add(corridorGroup);
            };

            createCorridor(PEIRAEUS_POSITION, { maxLength: 170, width: 12 });
            createCorridor(PHALERON_POSITION, { maxLength: 140, width: 10 });
        }

        function createLongWallPosts() {
            const start = KERAMEIKOS_POSITION;
            const spacing = 24;
            const postHeight = 3.4;
            const postGeometry = new THREE.CylinderGeometry(0.6 * CITY_SCALE, 0.8 * CITY_SCALE, postHeight, 6);
            const capGeometry = new THREE.ConeGeometry(0.9 * CITY_SCALE, 1.2, 4);
            const braceGeometry = new THREE.BoxGeometry(scaleValue(2.6), 0.45, scaleValue(0.9));
            const postMaterial = stoneMaterial.clone();
            postMaterial.color = postMaterial.color.clone().offsetHSL(-0.08, -0.06, -0.06);
            const capMaterial = postMaterial.clone();
            capMaterial.color = capMaterial.color.clone().offsetHSL(0.12, 0.12, 0.22);
            const braceMaterial = postMaterial.clone();
            braceMaterial.color = braceMaterial.color.clone().offsetHSL(-0.05, -0.04, -0.12);
            const baseRoadMaterial = pavedRoadMaterial.clone();
            baseRoadMaterial.color = baseRoadMaterial.color.clone().offsetHSL(-0.12, -0.15, 0.12);
            baseRoadMaterial.transparent = true;
            baseRoadMaterial.opacity = 0.25;
            baseRoadMaterial.side = THREE.DoubleSide;

            const corridors = [
                { end: PEIRAEUS_POSITION, orientation: LONG_WALL_DIRECTION },
                { end: PHALERON_POSITION, orientation: Math.atan2(PHALERON_POSITION.x - start.x, PHALERON_POSITION.z - start.z) }
            ];

            corridors.forEach(({ end, orientation }) => {
                const dx = end.x - start.x;
                const dz = end.z - start.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (!Number.isFinite(distance) || distance <= spacing) {
                    return;
                }
                const steps = Math.floor(distance / spacing);
                if (steps < 2) {
                    return;
                }
                const angle = orientation ?? Math.atan2(dx, dz);
                const midX = (start.x + end.x) / 2;
                const midZ = (start.z + end.z) / 2;

                const decalGroup = new THREE.Group();
                const corridorMaterial = baseRoadMaterial.clone();
                const decal = new THREE.Mesh(new THREE.PlaneGeometry(scaleValue(distance), scaleValue(4.2)), corridorMaterial);
                decal.rotation.x = -Math.PI / 2;
                decal.receiveShadow = true;
                decalGroup.add(decal);
                decalGroup.rotation.y = angle;
                decalGroup.position.set(scaleValue(midX), 0.035, scaleValue(midZ));
                scene.add(decalGroup);

                for (let i = 1; i < steps; i += 1) {
                    const ratio = (i * spacing) / distance;
                    const px = start.x + dx * ratio;
                    const pz = start.z + dz * ratio;

                    const postGroup = new THREE.Group();

                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.y = postHeight / 2;
                    post.castShadow = true;
                    post.receiveShadow = true;
                    postGroup.add(post);

                    const cap = new THREE.Mesh(capGeometry, capMaterial);
                    cap.position.y = postHeight;
                    cap.castShadow = true;
                    cap.receiveShadow = true;
                    postGroup.add(cap);

                    const brace = new THREE.Mesh(braceGeometry, braceMaterial);
                    brace.position.y = postHeight * 0.65;
                    brace.castShadow = true;
                    brace.receiveShadow = true;
                    postGroup.add(brace);

                    postGroup.position.set(scaleValue(px), 0, scaleValue(pz));
                    postGroup.rotation.y = angle;
                    scene.add(postGroup);
                }
            });
        }

        function createPhaleronHarbor() {
            const harborGroup = new THREE.Group();
            const water = waterMaterial.clone();
            const basin = new THREE.Mesh(new THREE.CircleGeometry(scaleValue(14), 40), water);
            basin.rotation.x = -Math.PI / 2;
            basin.position.y = 0.04;
            basin.receiveShadow = true;
            harborGroup.add(basin);

            const quayMaterial = stoneMaterial.clone();
            const quay = new THREE.Mesh(new THREE.RingGeometry(scaleValue(10), scaleValue(14), 40), quayMaterial);
            quay.rotation.x = -Math.PI / 2;
            quay.position.y = 0.03;
            quay.receiveShadow = true;
            harborGroup.add(quay);

            const pierMaterial = createEnhancedMaterial(0x8b5a2b, 0.9, 0.1);
            const pier = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(12), 0.6, scaleValue(3.5)), pierMaterial);
            pier.position.set(0, 0.3, -scaleValue(7));
            pier.castShadow = true;
            pier.receiveShadow = true;
            harborGroup.add(pier);

            const boatMaterial = createEnhancedMaterial(0x4a5e7a, 0.7, 0.1);
            const boatHull = new THREE.Mesh(new THREE.ConeGeometry(0.9 * CITY_SCALE, 2.5, 5), boatMaterial);
            boatHull.rotation.z = Math.PI;
            boatHull.position.set(scaleValue(4), 0.8, 0);
            boatHull.castShadow = true;
            harborGroup.add(boatHull);

            harborGroup.position.set(scaleValue(PHALERON_POSITION.x), 0, scaleValue(PHALERON_POSITION.z));
            scene.add(harborGroup);
        }

        function createHouses() {
            const houseConfigs = [ {x: -50, z: 0, w: 8, d: 6, style: 'wealthy'}, {x: -50, z: 15, w: 6, d: 8, style: 'middle'}, {x: 50, z: 0, w: 7, d: 7, style: 'wealthy'}, {x: 50, z: -20, w: 9, d: 6, style: 'artisan'}, {x: 30, z: 50, w: 6, d: 6, style: 'middle'}, {x: -30, z: 50, w: 8, d: 7, style: 'wealthy'} ];
            houseConfigs.forEach(config => {
                const material = config.style === 'wealthy' ? marbleMaterial : stoneMaterial;
                const house = createEnhancedBuilding(config.x, config.z, config.w, config.d, 6, material);
                const roofMaterial = config.style === 'wealthy' ? goldMaterial : redTileMaterial;
                const houseRoof = createEnhancedBuilding(config.x, config.z, config.w + 1, config.d + 1, 1, roofMaterial, { includeDetails: false });
                if(houseRoof.children[0].material.map) {
                    houseRoof.children[0].material.map.repeat.set((config.w/2) * CITY_SCALE, (config.d/2) * CITY_SCALE);
                }
                houseRoof.position.y = 7.5;
                scene.add(house);
                scene.add(houseRoof);
            });
        }
        
        function createEnhancedTree(x, z, scale = 1) {
            const tree = new THREE.Group();
            const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale * CITY_SCALE, 0.5 * scale * CITY_SCALE, 5 * scale, 8);
            const trunkMaterial = createEnhancedMaterial(0x8B4513, 1.0, 0.0);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5 * scale;
            trunk.castShadow = true;
            tree.add(trunk);
            for (let i = 0; i < 3; i++) {
                const leavesGeometry = new THREE.SphereGeometry((2.5 - i * 0.3) * scale * CITY_SCALE, 8, 6);
                const leavesMaterial = createEnhancedMaterial(0x228B22, 0.8, 0.0);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = (5 + i * 0.5) * scale;
                leaves.castShadow = true;
                tree.add(leaves);
            }
            setScaledPosition(tree, x, 0, z);
            return tree;
        }

        function createTrees() {
            const treePositions = [ {x: 25, z: 25, scale: 1.2}, {x: -25, z: 25, scale: 0.9}, {x: 35, z: -15, scale: 1.1}, {x: -35, z: 10, scale: 1.0}, {x: 45, z: 35, scale: 0.8}, {x: -40, z: -10, scale: 1.3} ];
            treePositions.forEach(pos => { scene.add(createEnhancedTree(pos.x, pos.z, pos.scale)); });
        }
        
        function initSkyAndStars() {
            const SkyClass = window.Sky;
            if (!SkyClass) {
                console.warn('Sky class is unavailable; skipping sky dome and starfield.');
                return;
            }

            starMaterials.length = 0;

            if (sky) {
                scene.remove(sky);
            }
            if (starLayerInner) {
                scene.remove(starLayerInner);
            }
            if (starLayerOuter) {
                scene.remove(starLayerOuter);
            }
            if (milkyWayMesh) {
                scene.remove(milkyWayMesh);
            }

            sky = new SkyClass();
            sky.scale.setScalar(450000);
            scene.add(sky);

            skyUniforms = sky.material.uniforms;
            skyUniforms.turbidity.value = 2.0;
            skyUniforms.rayleigh.value = 1.2;
            skyUniforms.mieCoefficient.value = 0.003;
            skyUniforms.mieDirectionalG.value = 0.8;

            sun = new THREE.Vector3();
            setSun(-10, 120);

            starLayerInner = makeStars(5000, 2500, 0.8);
            starLayerOuter = makeStars(8000, 4200, 1.2);
            scene.add(starLayerInner, starLayerOuter);

            const mwGeo = new THREE.RingGeometry(3000, 3050, 128, 1, 0, Math.PI * 1.4);
            const mwMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false, depthTest: false });
            milkyWayMesh = new THREE.Mesh(mwGeo, mwMat);
            milkyWayMesh.rotation.set(Math.PI / 4, 0, Math.PI / 8);
            milkyWayMesh.position.y = 50;
            scene.add(milkyWayMesh);

            renderer.setClearColor(0x03050a, 1.0);
            if (scene.fog) {
                scene.fog.color.set(0x03050a);
            }
        }

        function makeStars(count, radius, size = 1.0) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = radius * (0.985 + 0.015 * Math.random());
                positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.cos(phi);
                positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ size, sizeAttenuation: true, transparent: true, opacity: 0.0, depthWrite: false });
            starMaterials.push(mat);
            const pts = new THREE.Points(geo, mat);
            pts.frustumCulled = false;
            return pts;
        }

        function setupPostFX() {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 0.25;
            bloomPass.radius = 0.2;
            composer.addPass(bloomPass);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function setSun(elevationDeg, azimuthDeg) {
            if (!sun) {
                sun = new THREE.Vector3();
            }

            const phi = THREE.MathUtils.degToRad(90 - elevationDeg);
            const theta = THREE.MathUtils.degToRad(azimuthDeg);
            sun.setFromSphericalCoords(1, phi, theta);

            if (sky && sky.material && sky.material.uniforms && sky.material.uniforms.sunPosition) {
                sky.material.uniforms.sunPosition.value.copy(sun);
            }

            if (directionalLight) {
                const lightDistance = 3200;
                directionalLight.position.copy(sun).multiplyScalar(lightDistance);
                directionalLight.target.position.set(0, 0, 0);
                directionalLight.target.updateMatrixWorld();
            }
        }

        function setTimeOfDay(name) {
            const timeInfo = document.getElementById('current-time');
            if (timeInfo) {
                timeInfo.textContent = name;
            }

            const settings = {
                elevation: 45,
                azimuth: 180,
                ambientIntensity: 0.28,
                ambientColor: 0xffffff,
                directionalIntensity: 0.85,
                directionalColor: 0xffffff,
                hemisphereIntensity: 0.35,
                hemiSkyColor: 0x87ceeb,
                hemiGroundColor: 0x8b4513,
                exposure: 1.0,
                bloomStrength: 0.22,
                fogColor: 0xcfe8ff,
                starOpacity: 0.0,
                skyTurbidity: 4.0,
                skyRayleigh: 1.4,
                skyMie: 0.002,
                skyMieDirectional: 0.8
            };

            switch (name) {
                case 'Golden Dawn':
                    settings.elevation = 6;
                    settings.azimuth = 95;
                    settings.ambientIntensity = 0.26;
                    settings.ambientColor = 0xffe5b0;
                    settings.directionalIntensity = 0.65;
                    settings.directionalColor = 0xffdfa3;
                    settings.hemisphereIntensity = 0.32;
                    settings.hemiSkyColor = 0xffc371;
                    settings.hemiGroundColor = 0x8b4513;
                    settings.exposure = 0.94;
                    settings.bloomStrength = 0.28;
                    settings.fogColor = 0xffd9b0;
                    settings.skyTurbidity = 8.0;
                    settings.skyRayleigh = 2.2;
                    settings.skyMie = 0.0065;
                    break;
                case 'Blue Hour':
                    settings.elevation = -3;
                    settings.azimuth = 110;
                    settings.ambientIntensity = 0.18;
                    settings.ambientColor = 0x9fb5d1;
                    settings.directionalIntensity = 0.18;
                    settings.directionalColor = 0x7ba4d9;
                    settings.hemisphereIntensity = 0.26;
                    settings.hemiSkyColor = 0x3f5a7a;
                    settings.hemiGroundColor = 0x1c2432;
                    settings.exposure = 0.82;
                    settings.bloomStrength = 0.4;
                    settings.fogColor = 0x4a5c78;
                    settings.starOpacity = 0.25;
                    settings.skyTurbidity = 2.5;
                    settings.skyRayleigh = 3.4;
                    settings.skyMie = 0.0015;
                    break;
                case 'High Noon':
                    settings.elevation = 72;
                    settings.azimuth = 180;
                    settings.ambientIntensity = 0.36;
                    settings.ambientColor = 0xfef7eb;
                    settings.directionalIntensity = 1.05;
                    settings.directionalColor = 0xffffff;
                    settings.hemisphereIntensity = 0.55;
                    settings.hemiSkyColor = 0x8fc7ff;
                    settings.hemiGroundColor = 0xc5a572;
                    settings.exposure = 1.0;
                    settings.bloomStrength = 0.18;
                    settings.fogColor = 0xcfe8ff;
                    settings.skyTurbidity = 3.5;
                    settings.skyRayleigh = 1.3;
                    settings.skyMie = 0.002;
                    break;
                case 'Golden Dusk':
                    settings.elevation = 4;
                    settings.azimuth = 265;
                    settings.ambientIntensity = 0.24;
                    settings.ambientColor = 0xffcba5;
                    settings.directionalIntensity = 0.6;
                    settings.directionalColor = 0xffa85a;
                    settings.hemisphereIntensity = 0.3;
                    settings.hemiSkyColor = 0xff8c3f;
                    settings.hemiGroundColor = 0x5a3928;
                    settings.exposure = 0.9;
                    settings.bloomStrength = 0.3;
                    settings.fogColor = 0xffc7a1;
                    settings.skyTurbidity = 9.0;
                    settings.skyRayleigh = 2.0;
                    settings.skyMie = 0.0065;
                    break;
                case 'Starlit Night':
                default:
                    settings.elevation = -10;
                    settings.azimuth = 220;
                    settings.ambientIntensity = 0.1;
                    settings.ambientColor = 0x1a2335;
                    settings.directionalIntensity = 0.08;
                    settings.directionalColor = 0x1c2845;
                    settings.hemisphereIntensity = 0.15;
                    settings.hemiSkyColor = 0x0a1330;
                    settings.hemiGroundColor = 0x020205;
                    settings.exposure = 0.85;
                    settings.bloomStrength = 0.55;
                    settings.fogColor = 0x0a101b;
                    settings.starOpacity = 1.0;
                    settings.skyTurbidity = 1.2;
                    settings.skyRayleigh = 1.1;
                    settings.skyMie = 0.0008;
                    break;
            }

            setSun(settings.elevation, settings.azimuth);

            if (ambientLight) {
                ambientLight.color.setHex(settings.ambientColor);
                ambientLight.intensity = settings.ambientIntensity;
            }
            if (directionalLight) {
                directionalLight.color.setHex(settings.directionalColor);
                directionalLight.intensity = settings.directionalIntensity;
            }
            if (hemisphereLight) {
                hemisphereLight.color.setHex(settings.hemiSkyColor);
                hemisphereLight.groundColor.setHex(settings.hemiGroundColor);
                hemisphereLight.intensity = settings.hemisphereIntensity;
            }

            if (skyUniforms) {
                skyUniforms.turbidity.value = settings.skyTurbidity;
                skyUniforms.rayleigh.value = settings.skyRayleigh;
                skyUniforms.mieCoefficient.value = settings.skyMie;
                skyUniforms.mieDirectionalG.value = settings.skyMieDirectional;
            } else if (scene.background) {
                scene.background.setHex(settings.fogColor);
            }

            const showCityLights = settings.starOpacity > 0.2;
            pointLights.forEach(light => {
                light.visible = showCityLights;
            });

            if (composer && bloomPass) {
                bloomPass.strength = settings.bloomStrength;
            }

            if (renderer) {
                renderer.toneMappingExposure = settings.exposure;
                const fogCol = new THREE.Color(settings.fogColor);
                if (fogEnabled) {
                    if (!scene.fog) {
                        scene.fog = new THREE.Fog(fogCol, 600, 6000);
                    } else {
                        scene.fog.color.copy(fogCol);
                        scene.fog.near = 600;
                        scene.fog.far = 6000;
                    }
                } else {
                    scene.fog = null;
                }
            }

            let night = 0;
            if (name === 'Starlit Night') night = 1;
            else if (name === 'Blue Hour') night = 0.35;
            if (spaceNight) {
                spaceNight.setAmount(night);
            }
        }

        function updateNightCycle(dt = 0.016) {
            if (!renderer || !sky || !sky.material || !sky.material.uniforms) {
                return;
            }

            const sunPosition = sky.material.uniforms.sunPosition.value;
            const isNight = sunPosition.y < 0.0;

            const starTarget = isNight ? 0.9 : 0.0;
            const mwTarget = isNight ? 0.35 : 0.0;

            starMaterials.forEach((material) => {
                material.opacity += (starTarget - material.opacity) * 0.02;
            });

            if (milkyWayMesh && milkyWayMesh.material) {
                milkyWayMesh.material.opacity += (mwTarget - milkyWayMesh.material.opacity) * 0.02;
            }

            if (starLayerInner) {
                starLayerInner.rotation.y += dt * 0.0007;
                starLayerInner.rotation.x += dt * 0.0002;
            }
            if (starLayerOuter) {
                starLayerOuter.rotation.y -= dt * 0.0004;
                starLayerOuter.rotation.z += dt * 0.00015;
            }

            const clearNight = 0x03050a;
            const clearDay = 0x87a6ff;
            renderer.setClearColor(isNight ? clearNight : clearDay, 1);
            if (scene.fog) {
                const dayColor = new THREE.Color(clearDay);
                const nightColor = new THREE.Color(clearNight);
                scene.fog.color.lerpColors(dayColor, nightColor, isNight ? 1 : 0);
            }
        }

        function createFountain() {
            const fountainGroup = new THREE.Group();

            // Base
            const baseGeo = new THREE.CylinderGeometry(4 * CITY_SCALE, 4 * CITY_SCALE, 0.5, 32);
            const base = new THREE.Mesh(baseGeo, stoneMaterial);
            base.receiveShadow = true;
            fountainGroup.add(base);

            // Water in base
            const waterBaseGeo = new THREE.CylinderGeometry(3.8 * CITY_SCALE, 3.8 * CITY_SCALE, 0.4, 32);
            const waterBase = new THREE.Mesh(waterBaseGeo, waterMaterial);
            waterBase.position.y = 0.2;
            fountainGroup.add(waterBase);

            // Pillar
            const pillarGeo = new THREE.CylinderGeometry(0.5 * CITY_SCALE, 0.5 * CITY_SCALE, 3, 16);
            const pillar = new THREE.Mesh(pillarGeo, marbleMaterial);
            pillar.position.y = 1.75;
            pillar.castShadow = true;
            fountainGroup.add(pillar);

            // Top Basin
            const topBasinGeo = new THREE.CylinderGeometry(1.5 * CITY_SCALE, 1.5 * CITY_SCALE, 0.3, 24);
            const topBasin = new THREE.Mesh(topBasinGeo, stoneMaterial);
            topBasin.position.y = 3.25;
            topBasin.castShadow = true;
            fountainGroup.add(topBasin);

            // Water in top basin
            const waterTopGeo = new THREE.CylinderGeometry(1.4 * CITY_SCALE, 1.4 * CITY_SCALE, 0.2, 24);
            const waterTop = new THREE.Mesh(waterTopGeo, waterMaterial);
            waterTop.position.y = 3.2;
            fountainGroup.add(waterTop);

            fountainGroup.position.set(0, 0.25, 0);
            scene.add(fountainGroup);

            // Particle System for water spray
            const particleCount = 200;
            const particlesGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3 + 0] = 0; // x
                positions[i3 + 1] = 3.5; // y
                positions[i3 + 2] = 0; // z

                particleVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 1.5,
                    Math.random() * 3 + 2,
                    (Math.random() - 0.5) * 1.5
                ));
            }

            particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xadd8e6,
                size: 0.1,
                transparent: true,
                opacity: 0.7
            });

            const fountainSpray = new THREE.Points(particlesGeo, particleMaterial);
            fountainSpray.position.copy(fountainGroup.position);
            scene.add(fountainSpray);

            const fountainSprayObject = {
                particles: fountainSpray,
                velocities: particleVelocities,
                tick: function(delta) {
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 0; i < this.velocities.length; i++) {
                        const i3 = i * 3;
                        
                        this.velocities[i].y -= 9.8 * delta * 0.5;

                        positions[i3 + 0] += this.velocities[i].x * delta;
                        positions[i3 + 1] += this.velocities[i].y * delta;
                        positions[i3 + 2] += this.velocities[i].z * delta;

                        // Reset particle if it falls below the top basin
                        if (positions[i3 + 1] < 3.3 ) {
                            positions[i3 + 0] = 0;
                            positions[i3 + 1] = 3.5;
                            positions[i3 + 2] = 0;
                            this.velocities[i].set(
                                (Math.random() - 0.5) * 1.5,
                                Math.random() * 3 + 2,
                                (Math.random() - 0.5) * 1.5
                            );
                        }
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
            };
            updatableObjects.push(fountainSprayObject);
        }
        
        function createCityWall(x, z, width, height, depth, rotationY) {
            const scaledWidth = scaleValue(width);
            const scaledDepth = scaleValue(depth);
            const scaledX = scaleValue(x);
            const scaledZ = scaleValue(z);

            const baseHeight = height * 0.68;
            const walkwayHeight = Math.max(height * 0.12, 0.6);
            const merlonHeight = height - baseHeight - walkwayHeight;

            const foundationDepth = scaledDepth * 1.15;
            const walkwayDepth = scaledDepth * 0.75;
            const merlonDepth = scaledDepth * 0.35;
            const buttressDepth = foundationDepth * 1.05;

            const wallGroup = new THREE.Group();
            wallGroup.position.set(scaledX, 0, scaledZ);
            wallGroup.rotation.y = rotationY;

            const foundationMaterial = stoneMaterial.clone();
            foundationMaterial.color.offsetHSL(0, 0, -0.08);
            foundationMaterial.roughness = Math.min(1, foundationMaterial.roughness + 0.05);

            const walkwayMaterial = stoneMaterial.clone();
            walkwayMaterial.color.offsetHSL(0, 0, 0.05);
            walkwayMaterial.roughness = Math.max(0, walkwayMaterial.roughness - 0.1);

            const merlonMaterial = stoneMaterial.clone();
            merlonMaterial.color.offsetHSL(0, 0, -0.02);
            merlonMaterial.roughness = Math.min(1, merlonMaterial.roughness + 0.1);

            const foundation = new THREE.Mesh(
                new THREE.BoxGeometry(scaledWidth, baseHeight, foundationDepth),
                foundationMaterial
            );
            foundation.position.y = baseHeight / 2;
            foundation.castShadow = true;
            foundation.receiveShadow = true;
            wallGroup.add(foundation);

            const stringCourseHeight = Math.min(walkwayHeight * 0.8, 0.6);
            if (stringCourseHeight > 0.1) {
                const courseMaterial = stoneMaterial.clone();
                courseMaterial.color.offsetHSL(0, 0, -0.15);
                courseMaterial.roughness = Math.min(1, courseMaterial.roughness + 0.1);
                const stringCourse = new THREE.Mesh(
                    new THREE.BoxGeometry(scaledWidth * 0.98, stringCourseHeight, foundationDepth * 1.05),
                    courseMaterial
                );
                stringCourse.position.y = baseHeight * 0.55;
                stringCourse.castShadow = true;
                stringCourse.receiveShadow = true;
                wallGroup.add(stringCourse);
            }

            const walkwayBlock = new THREE.Mesh(
                new THREE.BoxGeometry(scaledWidth * 0.94, walkwayHeight, walkwayDepth),
                walkwayMaterial
            );
            walkwayBlock.position.y = baseHeight + walkwayHeight / 2;
            walkwayBlock.castShadow = true;
            walkwayBlock.receiveShadow = true;
            wallGroup.add(walkwayBlock);

            const walkwaySurfaceMaterial = new THREE.MeshStandardMaterial({
                color: 0x8f8b7a,
                roughness: 0.8,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            const walkwayFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(scaledWidth * 0.92, walkwayDepth),
                walkwaySurfaceMaterial
            );
            walkwayFloor.rotation.x = -Math.PI / 2;
            walkwayFloor.position.y = baseHeight + walkwayHeight + 0.01;
            walkwayFloor.receiveShadow = true;
            wallGroup.add(walkwayFloor);

            const buttressCount = Math.max(0, Math.floor(width / 14));
            if (buttressCount > 0) {
                const buttressMaterial = stoneMaterial.clone();
                buttressMaterial.color.offsetHSL(0, 0, -0.12);
                buttressMaterial.roughness = Math.min(1, buttressMaterial.roughness + 0.12);
                const buttressGeometry = new THREE.BoxGeometry(scaleValue(2.5), baseHeight * 1.1, buttressDepth);
                const buttressY = (baseHeight * 1.1) / 2;
                const spacing = scaledWidth / (buttressCount + 1);
                for (let i = 0; i < buttressCount; i++) {
                    const buttress = new THREE.Mesh(buttressGeometry, buttressMaterial);
                    buttress.position.set(-scaledWidth / 2 + spacing * (i + 1), buttressY, 0);
                    buttress.castShadow = true;
                    buttress.receiveShadow = true;
                    wallGroup.add(buttress);
                }
            }

            let merlonCount = Math.max(4, Math.floor(width / 6));
            merlonCount = Math.min(merlonCount, 48);
            const merlonSpacing = scaledWidth / merlonCount;
            const merlonWidth = merlonSpacing * 0.55;
            const merlonGeometry = new THREE.BoxGeometry(merlonWidth, merlonHeight, merlonDepth);
            const merlonY = baseHeight + walkwayHeight + merlonHeight / 2;
            const zOffset = walkwayDepth / 2 - merlonDepth / 2;
            for (let i = 0; i < merlonCount; i++) {
                const centerX = -scaledWidth / 2 + merlonSpacing * (i + 0.5);
                const frontMerlon = new THREE.Mesh(merlonGeometry, merlonMaterial);
                frontMerlon.position.set(centerX, merlonY, zOffset);
                frontMerlon.castShadow = true;
                frontMerlon.receiveShadow = true;
                wallGroup.add(frontMerlon);

                const backMerlon = new THREE.Mesh(merlonGeometry, merlonMaterial);
                backMerlon.position.set(centerX, merlonY, -zOffset);
                backMerlon.castShadow = true;
                backMerlon.receiveShadow = true;
                wallGroup.add(backMerlon);
            }

            scene.add(wallGroup);

            const collisionDepth = Math.max(foundationDepth, merlonDepth, buttressDepth);
            const collisionHeight = baseHeight + walkwayHeight + merlonHeight;
            const wallBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(scaledWidth / 2, collisionHeight / 2, collisionDepth / 2)),
                position: new CANNON.Vec3(scaledX, collisionHeight / 2, scaledZ)
            });
            wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
            world.addBody(wallBody);
        }

        function createCityFortifications() {
            const wallSize = 80;
            const wallHeight = 10;
            const wallDepth = 4;

            // Walls
            createCityWall(-wallSize / 2 - 10, -wallSize, wallSize - 20, wallHeight, wallDepth, 0);
            createCityWall(wallSize / 2 + 10, -wallSize, wallSize - 20, wallHeight, wallDepth, 0);
            createCityWall(0, wallSize, wallSize * 2, wallHeight, wallDepth, 0);
            createCityWall(wallSize, 0, wallSize * 2, wallHeight, wallDepth, Math.PI / 2);
            createCityWall(-wallSize, 0, wallSize * 2, wallHeight, wallDepth, Math.PI / 2);

            // Gatehouse
            const towerWidth = 8;
            const towerHeight = 15;
            const gateGap = 10;

            const tower1 = createEnhancedBuilding(-gateGap, -wallSize, towerWidth, towerWidth, towerHeight, stoneMaterial, { includeDetails: false });
            scene.add(tower1);
            const tower1Body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(scaleValue(towerWidth) / 2, towerHeight/2, scaleValue(towerWidth) / 2)) });
            tower1Body.position.copy(tower1.position);
            world.addBody(tower1Body);

            const tower2 = createEnhancedBuilding(gateGap, -wallSize, towerWidth, towerWidth, towerHeight, stoneMaterial, { includeDetails: false });
            scene.add(tower2);
            const tower2Body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(scaleValue(towerWidth) / 2, towerHeight/2, scaleValue(towerWidth) / 2)) });
            tower2Body.position.copy(tower2.position);
            world.addBody(tower2Body);

            const arch = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(gateGap * 2), 4, scaleValue(towerWidth)), stoneMaterial);
            setScaledPosition(arch, 0, towerHeight - 2, -wallSize);
            scene.add(arch);
            const archBody = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(scaleValue(gateGap), 2, scaleValue(towerWidth) / 2)) });
            archBody.position.copy(arch.position);
            world.addBody(archBody);

        }
        
        function createMarketStalls() {
            const woodMaterial = createEnhancedMaterial(0x8B4513, 0.9, 0.1);
            
            function createMarketStall(x, z, color) {
                const stallGroup = new THREE.Group();

                // Posts
                const postGeo = new THREE.CylinderGeometry(0.1 * CITY_SCALE, 0.1 * CITY_SCALE, 2, 8);
                const postPositions = [
                    {x: -1.4, z: -0.9}, {x: 1.4, z: -0.9},
                    {x: -1.4, z: 0.9}, {x: 1.4, z: 0.9}
                ];
                postPositions.forEach(pos => {
                    const post = new THREE.Mesh(postGeo, woodMaterial);
                    const { x: postX, z: postZ } = scaleXZ(pos.x, pos.z);
                    post.position.set(postX, 1, postZ);
                    post.castShadow = true;
                    stallGroup.add(post);
                });

                // Tabletop
                const tableGeo = new THREE.BoxGeometry(scaleValue(3), 0.2, scaleValue(2));
                const table = new THREE.Mesh(tableGeo, woodMaterial);
                table.position.y = 1;
                table.castShadow = true;
                table.receiveShadow = true;
                stallGroup.add(table);

                // Canopy
                const canopyMat = createEnhancedMaterial(color, 0.8, 0.1);
                const canopyGeo = new THREE.PlaneGeometry(scaleValue(3.2), scaleValue(2.2));
                const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                canopy.position.y = 2.1;
                canopy.rotation.x = -Math.PI / 12;
                canopy.castShadow = true;
                stallGroup.add(canopy);

                // Goods
                for (let i = 0; i < 5; i++) {
                    const potGeo = new THREE.CylinderGeometry((Math.random() * 0.2 + 0.1) * CITY_SCALE, (Math.random() * 0.2 + 0.1) * CITY_SCALE, Math.random() * 0.4 + 0.2, 8);
                    const pot = new THREE.Mesh(potGeo, createEnhancedMaterial(0xCD853F, 0.8, 0.2));
                    const randomXZ = scaleXZ(Math.random() * 2 - 1, Math.random() * 1.5 - 0.75);
                    pot.position.set(randomXZ.x, 1.2 + pot.geometry.parameters.height / 2, randomXZ.z);
                    pot.castShadow = true;
                    stallGroup.add(pot);
                }

                setScaledPosition(stallGroup, x, 0, z);
                scene.add(stallGroup);
            }

            createMarketStall(-10, 5, 0xc23b22);
            createMarketStall(-15, 5, 0x006994);
            createMarketStall(10, 5, 0x50c878);
        }
        
        function createDemocracyMonuments() {
             const pnyx = new THREE.Group();
             for(let i=0; i<3; i++){
                const step = new THREE.Mesh(
                    new THREE.CylinderGeometry(scaleValue(15 - i*2), scaleValue(15 - i*2), 0.5, 64, 1, false, 0, Math.PI),
                    stoneMaterial
                );
                step.position.y = (i * 0.5) + 0.25;
                pnyx.add(step);
             }
             const bema = new THREE.Mesh(new THREE.BoxGeometry(scaleValue(2),0.5,scaleValue(2)), marbleMaterial);
             bema.position.y = 1.75;
             bema.position.z = scaleValue(-12);
             pnyx.add(bema);
             setScaledPosition(pnyx, PNYX_POSITION.x, 0, PNYX_POSITION.z);
             pnyx.rotation.y = -Math.PI / 2;
             scene.add(pnyx);

             const dikasteria = createEnhancedBuilding(0, -15, 8, 12, 6, marbleMaterial);
             const colonnade = new THREE.Group();
             for(let i=0; i<5; i++){
                 const column = createEnhancedColumn(6);
                 setScaledPosition(column, 0, 0, i * 2.5);
                 colonnade.add(column);
             }
             colonnade.position.set(scaleValue(4.5), -3, scaleValue(-5));
             dikasteria.add(colonnade);
             scene.add(dikasteria);
        }
        
        function createPavedRoads() {
            const panathenaicWayMaterial = pavedRoadMaterial.clone();
            if (pavedRoadMaterial.map) {
                panathenaicWayMaterial.map = pavedRoadMaterial.map.clone();
            }
            const panathenaicWay = new THREE.Mesh(
                new THREE.PlaneGeometry(scaleValue(8), scaleValue(120)),
                panathenaicWayMaterial
            );
            panathenaicWay.rotation.x = -Math.PI / 2;
            panathenaicWay.position.set(scaleValue(0), 0.01, scaleValue(-20));
            if (panathenaicWayMaterial.map) {
                panathenaicWayMaterial.map.repeat.set(2 * CITY_SCALE, 30 * CITY_SCALE);
                panathenaicWayMaterial.map.needsUpdate = true;
            }
            panathenaicWay.receiveShadow = true;
            scene.add(panathenaicWay);

            const stoaWayMaterial = pavedRoadMaterial.clone();
            if (pavedRoadMaterial.map) {
                stoaWayMaterial.map = pavedRoadMaterial.map.clone();
            }
            const stoaWay = new THREE.Mesh(
                new THREE.PlaneGeometry(scaleValue(60), scaleValue(6)),
                stoaWayMaterial
            );
            stoaWay.rotation.x = -Math.PI / 2;
            stoaWay.position.set(scaleValue(40), 0.01, scaleValue(8));
            if (stoaWayMaterial.map) {
                stoaWayMaterial.map.repeat.set(15 * CITY_SCALE, 2 * CITY_SCALE);
                stoaWayMaterial.map.needsUpdate = true;
            }
            stoaWay.receiveShadow = true;
            scene.add(stoaWay);
        }

        // --- NPC AND INTERACTIVE OBJECTS ---
        
        function createCitizenModel(tunicColor, type = 'citizen') {
            const citizenGroup = new THREE.Group();
            const skinMaterial = createEnhancedMaterial(0xad6452, 0.8, 0.1);
            const tunicMaterial = createEnhancedMaterial(tunicColor, 0.9, 0.1);
            const hairMaterial = createEnhancedMaterial(0x333333, 0.9, 0.1);

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 12), skinMaterial);
            head.position.y = 1.6;
            head.name = "head";
            citizenGroup.add(head);
            
            // Nose
            const noseGeo = new THREE.CylinderGeometry(0.02, 0.05, 0.1, 8);
            const nose = new THREE.Mesh(noseGeo, skinMaterial);
            nose.position.z = 0.25;
            nose.position.y = -0.05;
            head.add(nose);


            // Simple Hair
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 12, 0, Math.PI * 2, 0, Math.PI / 1.8), hairMaterial);
            hair.position.y = 0.05;
            head.add(hair);

            // Eyes
            const eyeMaterial = new THREE.MeshBasicMaterial({color: 0x111111});
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMaterial);
            eyeL.position.set(-0.1, 0.05, 0.23);
            head.add(eyeL);
            const eyeR = eyeL.clone();
            eyeR.position.x = 0.1;
            head.add(eyeR);

            // Torso
            const torsoGeo = new THREE.CylinderGeometry(0.3, 0.35, 1.0, 12);
            const torso = new THREE.Mesh(torsoGeo, tunicMaterial);
            torso.position.y = 1.0;
            citizenGroup.add(torso);
            
            // Limbs
            const limbGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.55, 8);
            limbGeo.translate(0, -0.275, 0); // Pivot at top

            // Left Arm
            const armL = new THREE.Mesh(limbGeo, skinMaterial);
            armL.position.set(-0.35, 1.45, 0);
            armL.name = "armL";
            citizenGroup.add(armL);

            // Right Arm
            const armR = armL.clone();
            armR.position.x = 0.35;
            armR.name = "armR";
            citizenGroup.add(armR);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.5, 8);
            legGeo.translate(0, -0.25, 0);

            const legL = new THREE.Mesh(legGeo, skinMaterial);
            legL.position.set(-0.15, 0.5, 0);
            legL.name = "legL";
            citizenGroup.add(legL);

            const legR = legL.clone();
            legR.position.x = 0.15;
            legR.name = "legR";
            citizenGroup.add(legR);
            
            // Feet
            const footGeo = new THREE.BoxGeometry(0.15, 0.1, 0.25);
            const footL = new THREE.Mesh(footGeo, createEnhancedMaterial(0x5C4033, 0.9, 0.1));
            footL.position.y = -0.25;
            footL.position.z = 0.05;
            legL.add(footL);

            const footR = footL.clone();
            legR.add(footR);

            if(type === 'scribe'){
                const scrollMat = createEnhancedMaterial(0xF5DEB3, 0.7, 0.1);
                const scrollGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
                const scroll = new THREE.Mesh(scrollGeo, scrollMat);
                scroll.rotation.z = Math.PI / 2;
                scroll.position.y = -0.2;
                armR.add(scroll);
            }
            
            citizenGroup.traverse(child => {
                if(child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return citizenGroup;
        }

        function getRandomPointInZone(zone) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * zone.radius;
            return new THREE.Vector3(
                zone.center.x + Math.cos(angle) * radius,
                zone.center.y,
                zone.center.z + Math.sin(angle) * radius
            );
        }

        function chooseNewCitizenDestination(npc) {
            let target;
            let attempts = 0;
            do {
                target = getRandomPointInZone(npc.zone);
                attempts++;
            } while (target.distanceToSquared(npc.model.position) < 4 * CITY_SCALE * CITY_SCALE && attempts < 6);
            target.y = npc.baseY;
            npc.destination = target;
        }

        function createCitizenNPCs() {
            const tunicPalette = [
                0x8b5a2b,
                0x6f4d3a,
                0x3f6b4c,
                0x7f8fa6,
                0x9c755f,
                0x4d5c8b
            ];

            citizenZones.forEach(zone => {
                for (let i = 0; i < zone.count; i++) {
                    const color = tunicPalette[Math.floor(Math.random() * tunicPalette.length)];
                    const model = createCitizenModel(color);
                    const spawnPosition = getRandomPointInZone(zone);

                    model.position.copy(spawnPosition);
                    model.rotation.y = Math.random() * Math.PI * 2;

                    const npc = {
                        model,
                        zone,
                        baseY: spawnPosition.y,
                        speed: Math.random() * 0.6 + 0.8,
                        state: Math.random() < 0.6 ? 'walking' : 'idle',
                        walkTimer: 0,
                        idleTimer: 0,
                        walkCycle: Math.random() * Math.PI * 2,
                        animationOffset: Math.random() * Math.PI * 2,
                        destination: null,
                        limbs: {
                            armL: model.getObjectByName('armL'),
                            armR: model.getObjectByName('armR'),
                            legL: model.getObjectByName('legL'),
                            legR: model.getObjectByName('legR')
                        }
                    };

                    chooseNewCitizenDestination(npc);
                    if (npc.state === 'walking') {
                        npc.walkTimer = Math.random() * 5 + 3;
                    } else {
                        npc.idleTimer = Math.random() * 3 + 2;
                    }

                    citizens.push(npc);
                    scene.add(model);
                }
            });
        }

        function createChickenModel() {
            const chicken = new THREE.Group();
            const bodyMat = createEnhancedMaterial(0xffffff, 0.8, 0.1);
            const beakMat = createEnhancedMaterial(0xffa500, 0.8, 0.1);
            const wattleMat = createEnhancedMaterial(0xff0000, 0.8, 0.1);

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 6), bodyMat);
            body.scale.y = 0.8;
            chicken.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 6), bodyMat);
            head.position.set(0, 0.2, 0.25);
            chicken.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 4), beakMat);
            beak.position.z = 0.15;
            beak.rotation.x = Math.PI / 2;
            head.add(beak);
            
            const wattle = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 4), wattleMat);
            wattle.scale.y = 1.5;
            wattle.position.set(0, -0.05, 0.1);
            head.add(wattle);

            chicken.position.y = 0.3;
            chicken.traverse(child => { if(child.isMesh) child.castShadow = true; });
            return chicken;
        }
        
        function createInteractables() {
            // Player
            player = {};
            
            // Player Physics Body
            const playerShape = new CANNON.Cylinder(0.5, 0.5, 1.8, 8);
            player.body = new CANNON.Body({ mass: 70, shape: playerShape, fixedRotation: true });
            player.body.position.set(scaleValue(0), 0.9, scaleValue(30));
            player.body.angularDamping = 0.9;
            world.addBody(player.body);
            
            // Load Animated Player Model
            const playerLoader = new THREE.GLTFLoader();
            const CHARACTER_MODEL_URL = './models/character.glb';
            playerLoader.load(CHARACTER_MODEL_URL, (gltf) => {
                const model = gltf.scene;
                if (!model) {
                    console.warn('Character model loaded without a scene.');
                    return;
                }

                player.model = model;

                model.traverse((object) => {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });

                model.scale.set(1.6, 1.6, 1.6);

                if (typeof setScaledPosition === 'function') {
                    setScaledPosition(model, 0, 0, -48);
                } else if (typeof window !== 'undefined' && typeof window.setScaledPosition === 'function') {
                    window.setScaledPosition(model, 0, 0, -48);
                } else {
                    model.position.set(0, 0, -48);
                }

                const deg = (degrees) => degrees * (Math.PI / 180);
                // model.rotation.y = deg(180);

                scene.add(model);

                player.mixer = new THREE.AnimationMixer(model);
                player.actions = {};
                gltf.animations.forEach((clip) => {
                    player.actions[clip.name.toLowerCase()] = player.mixer.clipAction(clip);
                });

                console.log('Character clips:', gltf.animations.map((clip) => clip.name));

                player.playAction = (name) => {
                    if (!name) return;
                    const key = name.toLowerCase();
                    const nextAction = player.actions[key];
                    if (!nextAction || player.currentActionName === key || !player.mixer) return;

                    if (player.currentAction) {
                        nextAction.reset().play();
                        player.currentAction.crossFadeTo(nextAction, 0.2, false);
                    } else {
                        nextAction.reset().fadeIn(0.2).play();
                    }

                    player.currentAction = nextAction;
                    player.currentActionName = key;
                };

                const actionKeys = Object.keys(player.actions);
                if (actionKeys.length > 0) {
                    const startActionName = player.actions['idle'] ? 'idle' : actionKeys[0];
                    player.defaultActionName = startActionName;
                    player.playAction(startActionName);
                } else {
                    console.warn('No animations found in the character model.');
                }

            }, undefined, (error) => {
                console.error('Failed to load character model:', error);
            });

            // Scribes
            const scribeModel1 = createCitizenModel(0x654321, 'scribe');
            const pnyxScribe = { model: scribeModel1, promptElement: document.getElementById('pnyx-scribe-prompt'), name: "Pnyx Scribe", position: scaleLocation({ x: PNYX_POSITION.x, z: PNYX_POSITION.z }), isPlayerNear: false, radius: scaleValue(5) };
            pnyxScribe.model.position.copy(pnyxScribe.position);
            interactables.push(pnyxScribe);
            scene.add(pnyxScribe.model);

            const scribeModel2 = createCitizenModel(0x654321, 'scribe');
            const bouleuterionScribe = { model: scribeModel2, promptElement: document.getElementById('bouleuterion-scribe-prompt'), name: "Bouleuterion Scribe", position: scaleLocation({ x: AGORA_FEATURES.bouleuterion.position.x + 4, z: AGORA_FEATURES.bouleuterion.position.z + 6 }), isPlayerNear: false, radius: scaleValue(5) };
            bouleuterionScribe.model.position.copy(bouleuterionScribe.position);
            interactables.push(bouleuterionScribe);
            scene.add(bouleuterionScribe.model);
            
            const scribeModel3 = createCitizenModel(0x654321, 'scribe');
            const dikasteriaScribe = { model: scribeModel3, promptElement: document.getElementById('dikasteria-scribe-prompt'), name: "Dikasteria Scribe", position: scaleLocation({ x: 0, z: -20 }), isPlayerNear: false, radius: scaleValue(5) };
            dikasteriaScribe.model.position.copy(dikasteriaScribe.position);
            interactables.push(dikasteriaScribe);
            scene.add(dikasteriaScribe.model);

            // Citizens
            createCitizenNPCs();

            // Chickens
            for(let i=0; i<10; i++) {
                const model = createChickenModel();
                const spawnPosition = getRandomWorldVector3(0, CHICKEN_WORLD_PADDING);
                const chicken = {
                    model: model,
                    speed: Math.random() * 0.8 + 0.2,
                    destination: getRandomWorldVector3(0, CHICKEN_WORLD_PADDING),
                    state: 'pecking',
                    timer: Math.random() * 5,
                    sound: null,
                    panner: null
                };
                chicken.model.position.copy(spawnPosition);
                chickens.push(chicken);
                scene.add(chicken.model);
            }
        }
        
        function createInteractiveObjects() {
            for (let i = 0; i < 10; i++) {
                const radius = Math.random() * 0.3 + 0.2;
                const height = Math.random() * 0.8 + 0.5;
                const mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius * 0.7, radius, height, 8),
                    createEnhancedMaterial(0xCD853F, 0.9, 0.1)
                );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const { x: barrelX, z: barrelZ } = getRandomWorldXZ(BARREL_WORLD_PADDING);
                const body = new CANNON.Body({
                    mass: 2,
                    shape: new CANNON.Cylinder(radius, radius, height, 8),
                    position: new CANNON.Vec3(barrelX, 5, barrelZ)
                });

                world.addBody(body);
                mesh.position.set(barrelX, 5, barrelZ);
                scene.add(mesh);
                physicsObjects.push({ mesh, body });
            }
        }

        // --- GAME LOGIC & ANIMATION ---
        
        const locations = [
            { name: "The Parthenon", position: scaleLocation({ x: ACROPOLIS_POSITION.x, y: 10, z: ACROPOLIS_POSITION.z }), radius: scaleValue(30), title: "🏛️ The Parthenon" },
            { name: "Temple of Hephaistos", position: scaleLocation({ x: AGORA_FEATURES.templeOfHephaistos.position.x, y: 4, z: AGORA_FEATURES.templeOfHephaistos.position.z }), radius: scaleValue(18), title: "🛠️ Temple of Hephaistos" },
            { name: "Stoa of Attalos", position: scaleLocation({ x: AGORA_FEATURES.stoaOfAttalos.position.x, y: 4, z: AGORA_FEATURES.stoaOfAttalos.position.z }), radius: scaleValue(28), title: "🏛️ Stoa of Attalos" },
            { name: "Tholos", position: scaleLocation({ x: AGORA_FEATURES.tholos.position.x, y: 3, z: AGORA_FEATURES.tholos.position.z }), radius: scaleValue(16), title: "⚖️ The Tholos" },
            { name: "Bouleuterion", position: scaleLocation({ x: AGORA_FEATURES.bouleuterion.position.x, y: 3.5, z: AGORA_FEATURES.bouleuterion.position.z }), radius: scaleValue(18), title: "🏛️ The Bouleuterion" },
            { name: "Altar of the Twelve Gods", position: scaleLocation({ x: AGORA_FEATURES.altarOfTwelveGods.position.x, y: 2.5, z: AGORA_FEATURES.altarOfTwelveGods.position.z }), radius: scaleValue(14), title: "🔥 Altar of the Twelve Gods" },
            { name: "Areopagus Hill", position: scaleLocation({ x: AREOPAGUS_POSITION.x, y: 4, z: AREOPAGUS_POSITION.z }), radius: scaleValue(18), title: "🪨 Areopagus Hill" },
            { name: "Kerameikos Gate", position: scaleLocation({ x: KERAMEIKOS_POSITION.x, y: 3, z: KERAMEIKOS_POSITION.z }), radius: scaleValue(24), title: "🚪 Kerameikos & Sacred Gate" },
            { name: "Phaleron Harbor", position: scaleLocation({ x: PHALERON_POSITION.x, y: 2, z: PHALERON_POSITION.z }), radius: scaleValue(18), title: "⚓ Phaleron Harbor" },
            { name: "Residential Quarter", position: scaleLocation({ x: -50, y: 3, z: 5 }), radius: scaleValue(20), title: "🏡 Residential Quarter" },
            { name: "Olive Grove", position: scaleLocation({ x: 35, y: 2, z: 25 }), radius: scaleValue(25), title: "🌳 Sacred Olive Grove" }
        ];

        function updateProximityInteractions() {
            if (!player || !player.body) return;
            const currentLocationDiv = document.getElementById('current-location');
            if (!currentLocationDiv) return;

            // Location Info
            let playerInLocation = false;
            
            for (const loc of locations) {
                if (player.body.position.distanceTo(loc.position) < loc.radius) {
                    playerInLocation = true;
                     if (currentLocationDiv.innerText !== loc.title) {
                        currentLocationDiv.innerHTML = `<span class="location-badge golden-text pulse">${loc.title}</span>`;
                    }
                    break;
                }
            }
            if (!playerInLocation) {
                if (currentLocationDiv.innerText !== '🚶 Exploring the Outskirts') {
                    currentLocationDiv.innerHTML = `<span class="location-badge golden-text">🚶 Exploring the Outskirts</span>`;
                }
            }
            
            // Interactable Objects
            interactables.forEach(obj => {
                if(obj.promptElement && obj.position && obj.radius) {
                    if (player.body.position.distanceTo(obj.position) < obj.radius) {
                        if (!obj.isPlayerNear) {
                            obj.isPlayerNear = true;
                            obj.promptElement.classList.add('show');
                        }
                    } else {
                        if (obj.isPlayerNear) {
                            obj.isPlayerNear = false;
                            obj.promptElement.classList.remove('show');
                        }
                    }
                }
            });
        }

        function updateEnvironment() {
            const currentName = timeNames[currentTimeOfDay];
            setTimeOfDay(currentName);
            updateAmbientSoundscape();
        }

        function forceNightMode() {
            const nightIndex = timeNames.indexOf('Starlit Night');
            if (nightIndex !== -1) {
                currentTimeOfDay = nightIndex;
                updateEnvironment();
            }
        }

        function forceDayMode() {
            const dayIndex = timeNames.indexOf('High Noon');
            if (dayIndex !== -1) {
                currentTimeOfDay = dayIndex;
                updateEnvironment();
            }
        }
        
        function updateNPCs(delta) {
            const time = clock.getElapsedTime();

            citizens.forEach(npc => {
                if (!npc.destination) {
                    chooseNewCitizenDestination(npc);
                }

                if (npc.state === 'walking') {
                    npc.walkTimer -= delta;
                    const toTarget = npc.destination.clone().sub(npc.model.position);
                    const distance = toTarget.length();

                    if (distance < 0.3 || npc.walkTimer <= 0) {
                        npc.state = 'idle';
                        npc.idleTimer = Math.random() * 3 + 2;
                        npc.model.position.y = npc.baseY;
                    } else {
                        toTarget.normalize();
                        npc.model.position.addScaledVector(toTarget, npc.speed * delta);
                        npc.model.position.y = npc.baseY;

                        const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                        npc.model.rotation.y = THREE.MathUtils.lerp(npc.model.rotation.y, targetAngle, 0.15);

                        npc.walkCycle += delta * npc.speed * 4;
                        const swing = Math.sin(npc.walkCycle);
                        if (npc.limbs.armL) npc.limbs.armL.rotation.x = swing * 0.5;
                        if (npc.limbs.armR) npc.limbs.armR.rotation.x = -swing * 0.5;
                        if (npc.limbs.legL) npc.limbs.legL.rotation.x = -swing * 0.6;
                        if (npc.limbs.legR) npc.limbs.legR.rotation.x = swing * 0.6;
                    }
                } else {
                    npc.idleTimer -= delta;
                    const relaxFactor = Math.min(1, delta * 5);
                    if (npc.limbs.armL) npc.limbs.armL.rotation.x = THREE.MathUtils.lerp(npc.limbs.armL.rotation.x, 0, relaxFactor);
                    if (npc.limbs.armR) npc.limbs.armR.rotation.x = THREE.MathUtils.lerp(npc.limbs.armR.rotation.x, 0, relaxFactor);
                    if (npc.limbs.legL) npc.limbs.legL.rotation.x = THREE.MathUtils.lerp(npc.limbs.legL.rotation.x, 0, relaxFactor);
                    if (npc.limbs.legR) npc.limbs.legR.rotation.x = THREE.MathUtils.lerp(npc.limbs.legR.rotation.x, 0, relaxFactor);

                    npc.model.position.y = npc.baseY + Math.sin(time * 1.5 + npc.animationOffset) * 0.02;

                    if (npc.idleTimer <= 0) {
                        npc.state = 'walking';
                        chooseNewCitizenDestination(npc);
                        npc.walkTimer = Math.random() * 5 + 3;
                        npc.model.position.y = npc.baseY;
                    }
                }
            });

            chickens.forEach(chicken => {
                chicken.timer -= delta;
                if (chicken.timer <= 0) {
                    if (chicken.state === 'pecking') {
                        chicken.state = 'walking';
                        chicken.destination.copy(getRandomWorldVector3(0, CHICKEN_WORLD_PADDING));
                        chicken.timer = Math.random() * 8 + 4; // walk for 4-12 seconds
                    } else {
                        chicken.state = 'pecking';
                        chicken.timer = Math.random() * 5 + 2; // peck for 2-7 seconds
                    }
                }

                if (chicken.state === 'walking') {
                    const dir = chicken.destination.clone().sub(chicken.model.position).normalize();
                    chicken.model.position.add(dir.multiplyScalar(chicken.speed * delta));
                    chicken.model.lookAt(chicken.destination);
                } else { // pecking
                    chicken.model.children[1].rotation.x = Math.sin(performance.now() * 0.01) * 0.5 + 0.5;
                    if (audioStarted && chicken.sound && canChickenCluck && Math.random() < 0.05) {
                        const now = Tone.now();
                        if (now > lastCluckTime) {
                            chicken.sound.triggerAttackRelease("C5", "8n", now);
                            lastCluckTime = now + 0.1;
                        }
                    }
                }
            });
        }
        
        function updateLabels() {
            interactables.forEach(npc => {
                const head = npc.model.getObjectByName("head") || npc.model;
                if (!head) return;

                const vector = new THREE.Vector3();
                head.getWorldPosition(vector);
                
                let yOffset = 0.5;
                if (npc.name === "Pnyx Scribe" || npc.name === "Bouleuterion Scribe" || npc.name === "Dikasteria Scribe") {
                    yOffset = 2.0;
                }
                if (
                    npc.model.isGroup &&
                    npc.model.children.length > 0 &&
                    npc.model.children[0].geometry &&
                    npc.model.children[0].geometry.type === "CylinderGeometry"
                ) { // Is a scroll
                    yOffset = 0.8;
                }
                vector.y += yOffset; 
                
                vector.project(camera);

                const x = (vector.x * .5 + .5) * renderer.domElement.clientWidth;
                const y = (vector.y * -.5 + .5) * renderer.domElement.clientHeight;
                
                if (npc.promptElement) {
                    npc.promptElement.style.left = `${x}px`;
                    npc.promptElement.style.top = `${y - 30}px`;
                }
            });
        }
        
        function updateSoundPositions(delta) {
            // Update listener to match camera
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            Tone.Listener.set({
                positionX: camera.position.x,
                positionY: camera.position.y,
                positionZ: camera.position.z,
                forwardX: forward.x,
                forwardY: forward.y,
                forwardZ: forward.z,
                upX: camera.up.x,
                upY: camera.up.y,
                upZ: camera.up.z
            });

            // Update sound source positions
            chickens.forEach((chicken) => {
                if (!chicken.panner) {
                    return;
                }
                chicken.panner.positionX.value = chicken.model.position.x;
                chicken.panner.positionY.value = chicken.model.position.y;
                chicken.panner.positionZ.value = chicken.model.position.z;
            });
            
        }

        function animate() {
            requestAnimationFrame(animate);
            canChickenCluck = true;

            const dt = clock.getDelta();
            const delta = dt;
            if (spaceNight) {
                spaceNight.update(dt, camera);
            }
            if (player && player.mixer) player.mixer.update(delta);
            externalAnimationMixers.forEach(m => m.update(delta));

            updateFPS();
            if (player && player.body) {
                updateControls(delta);
            }
            updateProximityInteractions();
            updateLabels();
            if (audioStarted) {
                updateSoundPositions(delta);
            }

            updateNightCycle(delta);
            
            world.step(1 / 60, delta, 3);
            physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });
            
            if (player && player.body && player.model) {
                player.model.position.copy(player.body.position);
                if (player.modelOffsetY !== undefined) {
                    player.model.position.y += player.modelOffsetY;
                }
                player.model.quaternion.copy(player.body.quaternion);
            }
            
            updatableObjects.forEach(obj => obj.tick(delta));

            updateNPCs(delta);
            updateCamera();
            updateMiniMap();
            if (typeof landmarkLabelUpdater === 'function') {
                landmarkLabelUpdater(camera);
            }

            composer.render();
        }

        // --- CONTROLS ---
        function createAmbientSounds() {
            if (crowdChatter) {
                return;
            }

            if (!masterBus) {
                masterBus = new Tone.Volume(-8).toDestination();
            }
            if (!environmentReverb) {
                environmentReverb = new Tone.Reverb({
                    decay: 3.8,
                    preDelay: 0.4,
                    wet: 0.35
                }).toDestination();
            }

            Tone.Transport.bpm.value = 66;

            // Marketplace crowd bed
            crowdChatter = new Tone.Noise("pink").start();
            crowdPanner = new Tone.Panner3D({
                positionX: marketAmbiencePosition.x,
                positionY: marketAmbiencePosition.y,
                positionZ: marketAmbiencePosition.z,
            });
            const crowdFilter = new Tone.AutoFilter({
                frequency: "4m",
                baseFrequency: 180,
                octaves: 2.5,
                depth: 0.6
            }).start();
            const crowdEQ = new Tone.EQ3(-10, 1, -12);
            marketVolume = new Tone.Volume(-20);
            crowdChatter.chain(crowdFilter, crowdEQ, marketVolume, crowdPanner);
            crowdPanner.connect(masterBus);
            crowdPanner.connect(environmentReverb);

            merchantSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: { attack: 0.02, decay: 0.3, sustain: 0.15, release: 0.6 }
            });
            const merchantVibrato = new Tone.Vibrato(5, 0.2).start();
            merchantVolume = new Tone.Volume(-26);
            const merchantPanner = new Tone.Panner3D({
                positionX: marketAmbiencePosition.x + scaleValue(4),
                positionY: marketAmbiencePosition.y,
                positionZ: marketAmbiencePosition.z - scaleValue(2),
            });
            merchantSynth.chain(merchantVibrato, merchantVolume, merchantPanner);
            merchantPanner.connect(masterBus);
            merchantPanner.connect(environmentReverb);

            merchantLoop = new Tone.Loop((time) => {
                const baseNotes = ["C4", "D4", "E4", "G4"];
                const baseNote = baseNotes[Math.floor(Math.random() * baseNotes.length)];
                merchantSynth.triggerAttackRelease(baseNote, "8n", time, 0.35);

                const replyDelay = Tone.Time("8n").toSeconds() * 0.75;
                const followNote = Tone.Frequency(baseNote).transpose(5).toNote();
                Tone.Transport.scheduleOnce((callTime) => {
                    merchantSynth.triggerAttackRelease(followNote, "8n", callTime, 0.25);
                }, time + replyDelay);
            }, "4m").start("+1m");
            merchantLoop.probability = 0.55;

            // Fountain and water movement
            fountainNoise = new Tone.Noise("white").start();
            fountainPanner = new Tone.Panner3D({
                positionX: fountainPosition.x,
                positionY: fountainPosition.y,
                positionZ: fountainPosition.z,
            });
            const fountainFilter = new Tone.Filter({
                type: "bandpass",
                frequency: 1200,
                Q: 1.2
            });
            const fountainAuto = new Tone.AutoFilter({
                frequency: 0.3,
                baseFrequency: 900,
                octaves: 1
            }).start();
            fountainVolume = new Tone.Volume(-28);
            fountainNoise.chain(fountainFilter, fountainAuto, fountainVolume, fountainPanner);
            fountainPanner.connect(masterBus);
            fountainPanner.connect(environmentReverb);

            // Hillside wind and trees
            windNoise = new Tone.Noise("brown").start();
            windPanner = new Tone.Panner3D({
                positionX: hillsideWindPosition.x,
                positionY: hillsideWindPosition.y,
                positionZ: hillsideWindPosition.z,
            });
            const windFilter = new Tone.Filter({
                type: "lowpass",
                frequency: 500,
                Q: 0.8
            });
            const windAuto = new Tone.AutoFilter({
                frequency: 0.05,
                baseFrequency: 200,
                octaves: 1.5,
                depth: 0.7
            }).start();
            const windLFO = new Tone.LFO({
                frequency: 0.015,
                min: 200,
                max: 600
            }).start();
            windLFO.connect(windFilter.frequency);
            windVolume = new Tone.Volume(-32);
            windNoise.chain(windAuto, windFilter, windVolume, windPanner);
            windPanner.connect(masterBus);
            windPanner.connect(environmentReverb);

            // Temple chanting ambience
            templeChantSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 1.5, decay: 0.5, sustain: 0.4, release: 4 }
            });
            const templeFilter = new Tone.Filter({
                type: "lowpass",
                frequency: 800,
                Q: 0.7
            });
            templeVolume = new Tone.Volume(-30);
            templeChantPanner = new Tone.Panner3D({
                positionX: templeChantPosition.x,
                positionY: templeChantPosition.y,
                positionZ: templeChantPosition.z,
            });
            templeChantSynth.chain(templeFilter, templeVolume, templeChantPanner);
            templeChantPanner.connect(masterBus);
            templeChantPanner.connect(environmentReverb);

            let chantIndex = 0;
            const chantChords = [
                ["C4", "G3", "E4"],
                ["D4", "A3", "F4"],
                ["E4", "B3", "G4"],
                ["G3", "D4", "B3"],
            ];
            templeChantLoop = new Tone.Loop((time) => {
                const chord = chantChords[chantIndex % chantChords.length];
                chantIndex++;
                templeChantSynth.triggerAttackRelease(chord, "2m", time, 0.25);
            }, "4m").start("+0.5m");
            templeChantLoop.probability = 0.85;

            // Harbor birds
            seagullSynth = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.05, release: 1.5 }
            });
            const seagullVibrato = new Tone.Vibrato(7, 0.4).start();
            seagullPanner = new Tone.Panner3D({
                positionX: harbourBirdsPosition.x,
                positionY: harbourBirdsPosition.y,
                positionZ: harbourBirdsPosition.z,
            });
            seagullVolume = new Tone.Volume(-32);
            seagullSynth.chain(seagullVibrato, seagullVolume, seagullPanner);
            seagullPanner.connect(masterBus);
            seagullPanner.connect(environmentReverb);

            const seagullDelay = Tone.Time("8n").toSeconds();
            seagullLoop = new Tone.Loop((time) => {
                const baseCalls = ["A5", "B5", "C6", "D6"];
                const base = baseCalls[Math.floor(Math.random() * baseCalls.length)];
                seagullSynth.triggerAttackRelease(base, "8n", time, 0.35);

                const responseNote = Tone.Frequency(base).transpose(-3).toNote();
                Tone.Transport.scheduleOnce((callTime) => {
                    seagullSynth.triggerAttackRelease(responseNote, "4n", callTime, 0.25);
                }, time + seagullDelay * (0.5 + Math.random() * 0.5));
            }, "6m").start("+1m");
            seagullLoop.probability = 0.4;

            // Blacksmith forge rhythm
            const blacksmithPanner = new Tone.Panner3D({
                positionX: blacksmithPosition.x,
                positionY: blacksmithPosition.y,
                positionZ: blacksmithPosition.z,
            });
            const blacksmithVolume = new Tone.Volume(-20);
            blacksmithSound = new Tone.MetalSynth({
                frequency: 150,
                envelope: { attack: 0.001, decay: 0.35, release: 0.2 },
                harmonicity: 8.1,
                modulationIndex: 24,
                resonance: 4000,
                octaves: 1.5
            });
            blacksmithSound.chain(blacksmithVolume, blacksmithPanner);
            blacksmithPanner.connect(masterBus);
            blacksmithPanner.connect(environmentReverb);

            blacksmithLoop = new Tone.Loop((time) => {
                const hitVelocity = 0.7 + Math.random() * 0.2;
                blacksmithSound.triggerAttackRelease("C3", "16n", time, hitVelocity);
                const eighth = Tone.Time("8n").toSeconds();

                Tone.Transport.scheduleOnce((accentTime) => {
                    blacksmithSound.triggerAttackRelease("G3", "32n", accentTime, hitVelocity * 0.7);
                }, time + eighth * (0.45 + Math.random() * 0.1));

                Tone.Transport.scheduleOnce((finishingTime) => {
                    blacksmithSound.triggerAttackRelease("C3", "16n", finishingTime, hitVelocity * 0.9);
                }, time + eighth * (0.95 + Math.random() * 0.1));
            }, "1m").start("+0.5m");
            blacksmithLoop.probability = 0.9;

            // Animal life around the Agora without bundling binary samples
            const createAnimalAmbience = ({ position, initialVolume, createSource, onLoop, interval, startOffset, probability }) => {
                const { source, chain = [] } = createSource();
                const volumeNode = new Tone.Volume(initialVolume);
                const pannerNode = new Tone.Panner3D({
                    positionX: position.x,
                    positionY: position.y,
                    positionZ: position.z,
                });

                source.chain(...chain, volumeNode, pannerNode);
                pannerNode.connect(masterBus);
                pannerNode.connect(environmentReverb);

                const loop = new Tone.Loop((time) => onLoop(time, source), interval).start(startOffset);
                loop.probability = probability;

                return {
                    source,
                    volume: volumeNode,
                    panner: pannerNode,
                    loop,
                };
            };

            animalAmbiences = {
                dog: createAnimalAmbience({
                    position: kennelPosition,
                    initialVolume: -28,
                    interval: "4m",
                    startOffset: "+1.5m",
                    probability: 0.35,
                    createSource: () => {
                        const synth = new Tone.MembraneSynth({
                            pitchDecay: 0.05,
                            octaves: 4,
                            oscillator: { type: "square" },
                            envelope: { attack: 0.001, decay: 0.45, sustain: 0, release: 0.3 },
                        });
                        const filter = new Tone.Filter({
                            type: "bandpass",
                            frequency: 380,
                            Q: 1.5,
                        });
                        return { source: synth, chain: [filter] };
                    },
                    onLoop: (time, synth) => {
                        const barkNote = Math.random() > 0.5 ? "G2" : "A2";
                        const barkVelocity = 0.4 + Math.random() * 0.25;
                        synth.triggerAttackRelease(barkNote, "16n", time, barkVelocity);
                        Tone.Transport.scheduleOnce((secondBarkTime) => {
                            synth.triggerAttackRelease(barkNote, "16n", secondBarkTime, barkVelocity * 0.8);
                        }, time + Tone.Time("16n").toSeconds() * (0.35 + Math.random() * 0.25));
                    },
                }),
                cat: createAnimalAmbience({
                    position: catAlleyPosition,
                    initialVolume: -30,
                    interval: "5m",
                    startOffset: "+2.2m",
                    probability: 0.3,
                    createSource: () => {
                        const synth = new Tone.Synth({
                            oscillator: { type: "triangle" },
                            envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.9 },
                        });
                        synth.portamento = 0.15;
                        const filter = new Tone.Filter({
                            type: "bandpass",
                            frequency: 900,
                            Q: 1.2,
                        });
                        const vibrato = new Tone.Vibrato(5, 0.12).start();
                        return { source: synth, chain: [filter, vibrato] };
                    },
                    onLoop: (time, synth) => {
                        const startNote = ["E4", "F4", "G4"][Math.floor(Math.random() * 3)];
                        const peakFrequency = Tone.Frequency(startNote).transpose(3).toFrequency();
                        const releaseDelay = 1.0 + Math.random() * 0.4;

                        synth.triggerAttack(startNote, time, 0.25);

                        Tone.Transport.scheduleOnce((glideTime) => {
                            synth.frequency.rampTo(peakFrequency, 0.4, glideTime);
                        }, time + 0.25);

                        Tone.Transport.scheduleOnce((releaseTime) => {
                            synth.triggerRelease(releaseTime);
                        }, time + releaseDelay);
                    },
                }),
                cow: createAnimalAmbience({
                    position: cowPasturePosition,
                    initialVolume: -28,
                    interval: "8m",
                    startOffset: "+2.8m",
                    probability: 0.45,
                    createSource: () => {
                        const synth = new Tone.AMSynth({
                            harmonicity: 0.6,
                            oscillator: { type: "sine" },
                            envelope: { attack: 0.3, decay: 0.6, sustain: 0.8, release: 2.4 },
                            modulation: { type: "triangle" },
                            modulationEnvelope: { attack: 0.2, decay: 0.4, sustain: 0.7, release: 1.6 },
                        });
                        const filter = new Tone.Filter({
                            type: "lowpass",
                            frequency: 280,
                            Q: 0.9,
                        });
                        const vibrato = new Tone.Vibrato(1.5, 0.25).start();
                        return { source: synth, chain: [filter, vibrato] };
                    },
                    onLoop: (time, synth) => {
                        const baseNote = ["C2", "D2", "A1"][Math.floor(Math.random() * 3)];
                        const dropTarget = Tone.Frequency(baseNote).transpose(-3).toFrequency();
                        const sustain = 1.8 + Math.random() * 0.9;

                        synth.triggerAttack(baseNote, time, 0.35);

                        Tone.Transport.scheduleOnce((glideTime) => {
                            synth.frequency.rampTo(dropTarget, 0.9, glideTime);
                        }, time + 0.5);

                        Tone.Transport.scheduleOnce((releaseTime) => {
                            synth.triggerRelease(releaseTime);
                        }, time + sustain);
                    },
                }),
            };

            if (Tone.Transport.state !== "started") {
                Tone.Transport.start();
            }

            updateAmbientSoundscape();
        }

        function updateAmbientSoundscape() {
            if (typeof Tone === 'undefined') {
                return;
            }

            const now = Tone.now ? Tone.now() : 0;
            const fadeVolume = (node, value) => {
                if (!node || !node.volume) return;
                if (typeof node.volume.cancelScheduledValues === 'function') {
                    node.volume.cancelScheduledValues(now);
                }
                if (typeof node.volume.rampTo === 'function') {
                    node.volume.rampTo(value, 3);
                } else {
                    node.volume.value = value;
                }
            };

            const setLoopProbability = (loop, value) => {
                if (loop && typeof loop.probability === 'number') {
                    loop.probability = value;
                }
            };

            const animalSoundSettings = {
                0: {
                    dog: { volume: -30, probability: 0.32 },
                    cat: { volume: -34, probability: 0.22 },
                    cow: { volume: -26, probability: 0.55 },
                },
                1: {
                    dog: { volume: -26, probability: 0.4 },
                    cat: { volume: -30, probability: 0.28 },
                    cow: { volume: -22, probability: 0.65 },
                },
                2: {
                    dog: { volume: -27, probability: 0.38 },
                    cat: { volume: -26, probability: 0.4 },
                    cow: { volume: -24, probability: 0.5 },
                },
                3: {
                    dog: { volume: -24, probability: 0.5 },
                    cat: { volume: -22, probability: 0.55 },
                    cow: { volume: -32, probability: 0.18 },
                },
                4: {
                    dog: { volume: -26, probability: 0.42 },
                    cat: { volume: -24, probability: 0.45 },
                    cow: { volume: -26, probability: 0.35 },
                },
            };

            const applyAnimalSettings = (timeIndex) => {
                if (!animalAmbiences) {
                    return;
                }

                const settings = animalSoundSettings[timeIndex];
                if (!settings) {
                    return;
                }

                Object.entries(settings).forEach(([name, config]) => {
                    const animal = animalAmbiences[name];
                    if (!animal) {
                        return;
                    }

                    if (typeof config.volume === 'number') {
                        fadeVolume(animal.volume, config.volume);
                    }

                    if (typeof config.probability === 'number') {
                        setLoopProbability(animal.loop, config.probability);
                    }
                });
            };

            switch (currentTimeOfDay) {
                case 0: // Golden Dawn
                    fadeVolume(marketVolume, -24);
                    fadeVolume(merchantVolume, -32);
                    fadeVolume(fountainVolume, -24);
                    fadeVolume(windVolume, -28);
                    fadeVolume(templeVolume, -26);
                    fadeVolume(seagullVolume, -28);
                    setLoopProbability(merchantLoop, 0.35);
                    setLoopProbability(seagullLoop, 0.45);
                    setLoopProbability(blacksmithLoop, 0.65);
                    applyAnimalSettings(0);
                    break;
                case 1: // Bright Noon
                    fadeVolume(marketVolume, -16);
                    fadeVolume(merchantVolume, -22);
                    fadeVolume(fountainVolume, -20);
                    fadeVolume(windVolume, -30);
                    fadeVolume(templeVolume, -24);
                    fadeVolume(seagullVolume, -24);
                    setLoopProbability(merchantLoop, 0.75);
                    setLoopProbability(seagullLoop, 0.55);
                    setLoopProbability(blacksmithLoop, 0.95);
                    applyAnimalSettings(1);
                    break;
                case 2: // Crimson Sunset
                    fadeVolume(marketVolume, -18);
                    fadeVolume(merchantVolume, -26);
                    fadeVolume(fountainVolume, -21);
                    fadeVolume(windVolume, -26);
                    fadeVolume(templeVolume, -22);
                    fadeVolume(seagullVolume, -30);
                    setLoopProbability(merchantLoop, 0.45);
                    setLoopProbability(seagullLoop, 0.35);
                    setLoopProbability(blacksmithLoop, 0.8);
                    applyAnimalSettings(2);
                    break;
                case 3: // Starlit Night
                    fadeVolume(marketVolume, -34);
                    fadeVolume(merchantVolume, -40);
                    fadeVolume(fountainVolume, -24);
                    fadeVolume(windVolume, -24);
                    fadeVolume(templeVolume, -18);
                    fadeVolume(seagullVolume, -40);
                    setLoopProbability(merchantLoop, 0.15);
                    setLoopProbability(seagullLoop, 0.2);
                    setLoopProbability(blacksmithLoop, 0.35);
                    applyAnimalSettings(3);
                    break;
                case 4: // Blue Hour
                default:
                    fadeVolume(marketVolume, -22);
                    fadeVolume(merchantVolume, -30);
                    fadeVolume(fountainVolume, -22);
                    fadeVolume(windVolume, -25);
                    fadeVolume(templeVolume, -20);
                    fadeVolume(seagullVolume, -32);
                    setLoopProbability(merchantLoop, 0.25);
                    setLoopProbability(seagullLoop, 0.3);
                    setLoopProbability(blacksmithLoop, 0.55);
                    applyAnimalSettings(4);
                    break;
            }
        }

        function initializeChickenAudio() {
            chickens.forEach((chicken) => {
                if (chicken.sound) {
                    return;
                }

                const panner = new Tone.Panner3D();
                const synth = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
                });

                synth.volume.value = -14;
                synth.connect(panner);

                if (masterBus && environmentReverb) {
                    panner.connect(masterBus);
                    panner.connect(environmentReverb);
                } else {
                    panner.toDestination();
                }

                panner.positionX.value = chicken.model.position.x;
                panner.positionY.value = chicken.model.position.y;
                panner.positionZ.value = chicken.model.position.z;
                chicken.sound = synth;
                chicken.panner = panner;
            });
        }

        function addEventListeners() {
            document.getElementById('start-button').addEventListener('click', async () => {
                document.getElementById('start-overlay').classList.add('fade-out');
                if (!audioStarted) {
                    try {
                        await Tone.start();
                        console.log("Audio context started.");
                        createAmbientSounds();
                        initializeChickenAudio();
                        audioStarted = true;
                    } catch (error) {
                        console.warn('Unable to start audio context:', error);
                    }
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('keydown', (e) => {
                if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    e.preventDefault();
                }
                controls[e.code] = true;
                if (e.code === 'KeyD' || e.code === 'KeyN') {
                    toggleKeyTimestamps[e.code] = performance.now();
                }
            });
            document.addEventListener('keyup', (e) => {
                controls[e.code] = false;
                if (e.code === 'KeyN') {
                    forceNightMode();
                    delete toggleKeyTimestamps[e.code];
                }
                if (e.code === 'KeyD') {
                    const downTime = toggleKeyTimestamps[e.code];
                    if (!downTime || performance.now() - downTime < 250) {
                        forceDayMode();
                    }
                    delete toggleKeyTimestamps[e.code];
                }
                if(e.code === 'KeyE') {
                    for(const obj of interactables) {
                        if(obj.isPlayerNear && obj.promptElement) {
                            obj.promptElement.querySelector('button').click();
                            break;
                        }
                    }
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                if(e.code === 'KeyT') {
                    currentTimeOfDay = (currentTimeOfDay + 1) % timeNames.length;
                    updateEnvironment();
                }
                if(e.code === 'KeyF') {
                    fogEnabled = !fogEnabled;
                    if (!fogEnabled) {
                        scene.fog = null;
                    }
                    updateEnvironment();
                }
                if(e.code === 'KeyX') {
                    isFlying = !isFlying;
                    if (player && player.body) {
                        player.body.velocity.set(0, 0, 0);
                        if (player.body.force) {
                            player.body.force.set(0, 0, 0);
                        }
                    }
                }
                if(e.code === 'KeyL') {
                    enhancedLighting = !enhancedLighting;
                    // Adjust base intensities if needed
                    updateEnvironment();
                }
                if(e.code === 'KeyM') {
                    soundEnabled = !soundEnabled;
                    Tone.getDestination().mute = !soundEnabled;
                }
                if(e.code === 'KeyP') {
                    document.getElementById('fps-counter').classList.toggle('show');
                }
            });
            
            document.getElementById('close-info-scroll').addEventListener('click', () => {
                document.getElementById('info-scroll-overlay').classList.remove('show');
            });
            
            document.querySelectorAll('.prompt .gemini-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const infoType = e.target.dataset.info;
                    if (infoType) {
                        showInfoScroll(infoType);
                    }
                });
            });

             document.getElementById('toggle-hud').addEventListener('click', () => {
                const hud = document.getElementById('hud');
                const button = document.getElementById('toggle-hud');
                hud.classList.toggle('hidden');
                if (hud.classList.contains('hidden')) {
                    button.textContent = 'Show UI';
                } else {
                    button.textContent = 'Hide UI';
                }
            });
        }
        
        function updateControls(delta) {
            if (!player || !player.body) return;
            
            // Handle rotation
            if (controls.KeyA) {
                player.body.angularVelocity.y = playerRotationSpeed;
            } else if (controls.KeyD) {
                player.body.angularVelocity.y = -playerRotationSpeed;
            } else {
                 player.body.angularVelocity.y = 0;
            }
            
            // Handle movement
            const moveDirection = new THREE.Vector3();
            if (controls.KeyW) moveDirection.z -= 1;
            if (controls.KeyS) moveDirection.z += 1;

            const hasHorizontalInput = moveDirection.lengthSq() > 0;
            const isMoving = controls.KeyW || controls.KeyS;

            if (player && player.actions && player.playAction) {
                const actionKeys = Object.keys(player.actions);
                if (actionKeys.length) {
                    const findActionKey = (needle) => actionKeys.find(name => name === needle) || actionKeys.find(name => name.includes(needle));
                    const walkActionName = findActionKey('walk');
                    const runActionName = findActionKey('run');
                    const idleActionName = findActionKey('idle');
                    const fallbackActionName = player.defaultActionName || actionKeys[0];
                    const targetActionName = isMoving
                        ? (walkActionName || runActionName || fallbackActionName)
                        : (idleActionName || walkActionName || runActionName || fallbackActionName);

                    if (targetActionName) {
                        player.playAction(targetActionName);
                    }
                }
            }


            const playerQuaternion = new THREE.Quaternion(
                player.body.quaternion.x,
                player.body.quaternion.y,
                player.body.quaternion.z,
                player.body.quaternion.w
            );

            if (hasHorizontalInput) {
                moveDirection.normalize();
                moveDirection.applyQuaternion(playerQuaternion);
            } else {
                moveDirection.set(0, 0, 0);
            }

            if (isFlying) {
                if (player.body.force) {
                    player.body.force.y += -world.gravity.y * player.body.mass;
                }

                let verticalVelocity = 0;
                if (controls.Space) verticalVelocity += flightVerticalSpeed;
                if (controls.ShiftLeft || controls.ShiftRight) verticalVelocity -= flightVerticalSpeed;

                const flightVelocity = new CANNON.Vec3(
                    moveDirection.x * flightSpeed,
                    verticalVelocity,
                    moveDirection.z * flightSpeed
                );

                if (player.body.velocity) {
                    player.body.velocity.copy(flightVelocity);
                }
            } else {
                const currentVelocity = new CANNON.Vec3(
                    moveDirection.x * playerSpeed,
                    player.body.velocity.y, // Preserve vertical velocity
                    moveDirection.z * playerSpeed
                );

                if (player.body.velocity) {
                    player.body.velocity.copy(currentVelocity);
                }

                if (!controls.KeyW && !controls.KeyS) {
                    player.body.velocity.x = 0;
                    player.body.velocity.z = 0;
                }
            }

            // Camera orbit
            if (controls.ArrowUp) cameraOffset.y += 2 * delta;
            if (controls.ArrowDown) cameraOffset.y -= 2 * delta;
            if (controls.ArrowLeft) cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), 2 * delta);
            if (controls.ArrowRight) cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), -2 * delta);
            
            cameraOffset.y = Math.max(1, Math.min(5, cameraOffset.y)); // Clamp camera height
            
        }
        
        function updateCamera() {
            if (!player || !player.body || !player.model) return;

            const playerPosition = new THREE.Vector3(
                player.body.position.x,
                player.body.position.y,
                player.body.position.z
            );
            
            const cameraTargetPosition = playerPosition.clone().add(cameraOffset);

            camera.position.lerp(cameraTargetPosition, 0.2);

            const lookAtPosition = playerPosition.clone();
            lookAtPosition.y += 1.5;

            camera.lookAt(lookAtPosition);
        }

        function addMiniMapDot(category, worldPos) {
            const mapContainer = document.getElementById('mini-map-container');
            if (!mapContainer || !worldPos) {
                return null;
            }

            const worldWidth = mapBounds.xMax - mapBounds.xMin;
            const worldDepth = mapBounds.zMax - mapBounds.zMin;
            if (worldWidth === 0 || worldDepth === 0) {
                return null;
            }

            const safeCategory = (category ?? 'cultural').toString().toLowerCase();
            const normalizedCategory = ['democracy', 'cultural', 'natural'].includes(safeCategory)
                ? safeCategory
                : 'cultural';

            const icon = document.createElement('div');
            icon.className = `map-icon map-icon-${normalizedCategory}`;

            const mapWidth = 200;
            const mapHeight = 200;
            const percentX = THREE.MathUtils.clamp((worldPos.x - mapBounds.xMin) / worldWidth, 0, 1);
            const percentZ = THREE.MathUtils.clamp((worldPos.z - mapBounds.zMin) / worldDepth, 0, 1);

            icon.style.left = `${percentX * mapWidth}px`;
            icon.style.top = `${percentZ * mapHeight}px`;

            mapContainer.appendChild(icon);
            return icon;
        }

        function createMapIcons() {
            const allLocations = [
                ...locations.map(l => ({...l, type: (l.type || 'cultural')})),
                { name: 'Pnyx', position: scaleLocation({ x: PNYX_POSITION.x, z: PNYX_POSITION.z }), type: 'democracy' },
                { name: 'Dikasteria', position: scaleLocation({ x: 0, z: -15 }), type: 'democracy' },
                { name: 'Bouleuterion', position: scaleLocation({ x: AGORA_FEATURES.bouleuterion.position.x, z: AGORA_FEATURES.bouleuterion.position.z }), type: 'democracy' }
            ];

            allLocations.forEach(loc => {
                if (!loc || !loc.position) {
                    return;
                }

                addMiniMapDot(loc.type, loc.position);
            });
        }

        async function setupLandmarks() {
            try {
                const { loadLandmarks } = await import('./src/landmarks-loader.js');

                const projectorInstance = window?.AthensGeo?.projector;
                const projectorFn = projectorInstance && typeof projectorInstance.project === 'function'
                    ? (lon, lat) => {
                        const { x, y } = projectorInstance.project({ lat, lon });
                        return new THREE.Vector3(scaleValue(x), 0, scaleValue(y));
                    }
                    : null;

                const { groups, update } = await loadLandmarks({
                    scene,
                    geoJsonUrl: './data/athens_places.geojson',
                    projector: projectorFn,
                    onPoint: (feature, pin, worldPos) => {
                        const props = feature.properties || {};
                        const name = props.title || props.name || 'Unnamed';
                        const rawCategory = (props.category || 'cultural').toString().toLowerCase();
                        const category = ['democracy', 'cultural', 'natural'].includes(rawCategory) ? rawCategory : 'cultural';

                        locations.push({
                            name,
                            position: worldPos.clone(),
                            radius: scaleValue(12),
                            title: `📍 ${name}`,
                            type: category
                        });

                        addMiniMapDot(category, worldPos);
                    }
                });

                landmarkGroups = groups;
                landmarkLabelUpdater = update;

                if (landmarkGroups?.democracy) landmarkGroups.democracy.visible = true;
                if (landmarkGroups?.cultural) landmarkGroups.cultural.visible = true;
                if (landmarkGroups?.natural) landmarkGroups.natural.visible = true;

                window.AthensLandmarks = { groups, update };
            } catch (error) {
                console.error('Failed to load landmarks:', error);
            }
        }

        function updateMiniMap() {
            if (!player || !player.body || !player.model) return;

            const playerIcon = document.getElementById('map-player');
            const mapWidth = 200;
            const mapHeight = 200;
            const worldWidth = mapBounds.xMax - mapBounds.xMin;
            const worldDepth = mapBounds.zMax - mapBounds.zMin;

            let percentX = (player.body.position.x - mapBounds.xMin) / worldWidth;
            let percentZ = (player.body.position.z - mapBounds.zMin) / worldDepth;
            percentX = THREE.MathUtils.clamp(percentX, 0, 1);
            percentZ = THREE.MathUtils.clamp(percentZ, 0, 1);

            let mapX = percentX * mapWidth;
            let mapY = percentZ * mapHeight;

            playerIcon.style.left = `${mapX}px`;
            playerIcon.style.top = `${mapY}px`;
            
            const euler = new THREE.Euler().setFromQuaternion(player.body.quaternion, 'YXZ');
            playerIcon.style.transform = `translate(-50%, -50%) rotate(${-(euler.y)}rad)`;
        }

        function showInfoScroll(type) {
            const info = infoData[type];
            if (info) {
                document.getElementById('info-title').textContent = info.title;
                document.getElementById('info-text').innerHTML = info.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                document.getElementById('info-scroll-overlay').classList.add('show');
            }
        }
        
        // Initialize the application
        init().catch((error) => {
            console.error('Failed to initialize Athens experience:', error);
        });
        
        } // End of main function
        
        // --- START ---
        window.onload = function() {
            initializeAthens();
        };

    </script>

    <script type="module">
        import { loadGeoJson } from './src/geo/geoLoader.js';
        import { LocalEquirectangularProjection } from './src/geo/projection.js';

        const origin = { lat: 37.9715379, lon: 23.7266531 }; // Parthenon
        const rotationDegrees = 0;
        const projector = new LocalEquirectangularProjection({ origin, rotationDegrees });

        loadGeoJson()
            .then((geoJson) => {
                if (!geoJson || !Array.isArray(geoJson.features)) {
                    console.warn('GeoJSON file did not contain any features to transform.');
                    return;
                }

                console.group('Athens GeoJSON → local meters');
                geoJson.features
                    .filter((feature) => feature?.geometry?.type === 'Point')
                    .forEach((feature) => {
                        const [lon, lat] = feature.geometry.coordinates;
                        const { x, y } = projector.project({ lat, lon });
                        const name = feature.properties?.title || feature.properties?.name || 'Unnamed feature';
                        console.log(name, { x, y, lat, lon });
                    });
                console.groupEnd();
            })
            .catch((error) => {
                console.error('Failed to load Athens GeoJSON data', error);
            });

        window.AthensGeo = {
            projector,
            setRotation: (degrees) => projector.setRotation(degrees)
        };
       
  // if your file lives at data/athens_places.geojson in the repo, this keeps it safe on GitHub Pages:
</script>

<script type="module">
  import { createLandmarkOverlay, LandmarkOverlay } from './src/map/landmarks.js';

  function waitForWorldBuilt() {
    if (typeof window === 'undefined') {
      return Promise.resolve();
    }
    if (window.athensWorldBuilt && window.scene && window.renderer) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const handler = () => {
        window.removeEventListener('athens-world-built', handler);
        resolve();
      };
      window.addEventListener('athens-world-built', handler, { once: true });
    });
  }

  const overlayCanvas = document.getElementById('landmarks-canvas');

  if (overlayCanvas) {
    try {
      await waitForWorldBuilt();
      const options = {
        geoJsonUrl: './data/athens_places.geojson',
        agoraDataUrl: './data/agora_local.json',
        showAgoraLayer: true,
        markerFill: '#FFD700',
        markerStroke: '#704c00',
        fitPadding: 48
      };

      let overlay = null;
      if (typeof createLandmarkOverlay === 'function') {
        overlay = createLandmarkOverlay(overlayCanvas, options);
        if (overlay && typeof overlay.then === 'function') {
          overlay = await overlay;
        }
      }

      if (!overlay) {
        const overlayNamespace = typeof window !== 'undefined' ? window.AthensMap : undefined;
        const OverlayClass = LandmarkOverlay || overlayNamespace?.LandmarkOverlay;
        if (OverlayClass) {
          overlay = new OverlayClass(overlayCanvas, options);
        }
      }

      if (overlay && typeof overlay.initialize === 'function') {
        const initResult = overlay.initialize();
        if (initResult && typeof initResult.then === 'function') {
          await initResult;
        }
      }

      if (overlay && typeof window !== 'undefined') {
        window.AthensLandmarkOverlay = overlay;
      }
    } catch (error) {
      console.error('Landmark overlay failed to initialize:', error);
    }
  } else {
    console.warn('landmarks-canvas not found; overlay disabled.');
  }
</script>
    <script type="module">
        const waitForWorld = () => {
            if (window.athensWorldBuilt && window.scene && window.renderer) {
                return Promise.resolve();
            }
            return new Promise((resolve) => {
                const handler = () => {
                    if (window.scene && window.renderer) {
                        window.removeEventListener('athens-world-built', handler);
                        resolve();
                    }
                };
                window.addEventListener('athens-world-built', handler);
            });
        };

        const applyMeshEnhancements = (root, renderer) => {
            const maxAnisotropy = renderer?.capabilities?.getMaxAnisotropy
                ? renderer.capabilities.getMaxAnisotropy()
                : null;

            root.traverse((child) => {
                if (!child.isMesh) return;

                child.castShadow = true;
                child.receiveShadow = true;

                const materials = Array.isArray(child.material) ? child.material : [child.material];
                materials.forEach((material) => {
                    if (!material) return;
                    ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'aoMap', 'emissiveMap'].forEach((key) => {
                        const texture = material[key];
                        if (texture && maxAnisotropy) {
                            texture.anisotropy = Math.max(texture.anisotropy || 0, maxAnisotropy);
                            texture.needsUpdate = true;
                        }
                    });
                });
            });
        };

        const placeObject = (object, x, y, z) => {
            if (typeof window.setScaledPosition === 'function') {
                window.setScaledPosition(object, x, y, z);
            } else {
                object.position.set(x, y, z);
            }
        };

        await waitForWorld();

        const { THREE, scene, renderer } = window;
        if (!THREE || !scene || !renderer) {
            console.error('THREE.js scene was not initialized before loading models.');
            throw new Error('Scene not ready');
        }

        if (typeof THREE.GLTFLoader !== 'function') {
            console.error('THREE.GLTFLoader is not available. Ensure the loader script is loaded before this module.');
            throw new Error('GLTFLoader unavailable');
        }

        const gltfLoader = new THREE.GLTFLoader();

        const loadTemple = () => {
            const templeGroup = new THREE.Group();
            gltfLoader.load(
                './data/models/greek_temple.glb',
                (gltf) => {
                    const temple = gltf.scene || new THREE.Group();
                    temple.scale.set(3, 3, 3);
                    templeGroup.add(temple);
                    applyMeshEnhancements(templeGroup, renderer);
                    placeObject(templeGroup, 90, 0, 35);
                    scene.add(templeGroup);
                },
                undefined,
                (error) => {
                    console.error('Error loading Greek temple model:', error);
                }
            );
        };

        const loadNPC = () => {
            const npcGroup = new THREE.Group();
            gltfLoader.load(
                './data/models/npc_athenian.glb',
                (gltf) => {
                    const npc = gltf.scene || new THREE.Group();
                    npc.scale.set(1.2, 1.2, 1.2);
                    npcGroup.add(npc);
                    applyMeshEnhancements(npcGroup, renderer);
                    placeObject(npcGroup, -10, 0, 5);
                    scene.add(npcGroup);

                    if (Array.isArray(gltf.animations) && gltf.animations.length) {
                        const mixers = window.externalAnimationMixers || (window.externalAnimationMixers = []);
                        const npcMixer = new THREE.AnimationMixer(npc);
                        gltf.animations.forEach((clip) => {
                            npcMixer.clipAction(clip).play();
                        });
                        mixers.push(npcMixer);
                    }
                },
                undefined,
                (error) => {
                    console.warn('NPC model failed to load:', error);
                }
            );
        };

        loadTemple();
        loadNPC();
    </script>


</body>
</html>

